<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>zouni</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zouni</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装mingw-w64"><a class="header" href="#安装mingw-w64">安装mingw-w64</a></h3>
<ol>
<li>官网<br />
https://www.mingw-w64.org/downloads/#sources</li>
<li>下载<br />
https://sourceforge.net/p/mingw-w64/mingw-w64/ci/master/tree/</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vscode-不能直接复制粘贴文件可以拖拽"><a class="header" href="#vscode-不能直接复制粘贴文件可以拖拽">vscode 不能直接复制粘贴文件，可以拖拽</a></h3>
<p>vscode 分为两个版本：user版本和System版本，user版本应该是不能拖拽的，system版本可以拖拽，官网下载system版本</p>
<p>选择 Other downloads
<img src="windows//res/windows/vscode_download.png" alt="下载vscode页面" />
选择System Installer 版本下载
<img src="windows//res/windows/system_installer.png" alt="system版本下载" /></p>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>windows新终端
<img src="windows//res/windows/w_ter.png" alt="windows terminal" /></p>
</li>
<li>
<p>可以自定义主题</p>
<ol>
<li>
<p>打开设置<br />
<img src="windows//res/windows/setting.png" alt="打开设置" /></p>
</li>
<li>
<p>在这里选择一个喜欢的 <a href="https://atomcorp.github.io/themes/">主题</a></p>
</li>
</ol>
<p><img src="windows//res/windows/theme_site.png" alt="选择主题" /></p>
<p>将选择好的主题配置信息，放在下图<code>schemes</code>集合里</p>
<p><img src="windows//res/windows/config_modify.png" alt="修改配置文件" /></p>
<p>修改上图<code>list</code>增加<code>colorScheme</code> 名字对应添加的schemes中的<code>name</code></p>
</li>
</ol>
<h2 id="不够炫酷修改背景图片"><a class="header" href="#不够炫酷修改背景图片">不够炫酷？修改背景图片，</a></h2>
<pre><code>"backgroundImage": "E:\\bg.png",
"backgroundImageOpacity": 0.3,
"backgroundImageStretchMode":"none", # 有四个选项 uniformToFill | none | fill | uniform 

</code></pre>
<p><img src="windows//res/windows/set_bg_image.png" alt="背景图设置" /><br />
<code>注意图片路径的反斜杠-转义或者用正斜杠</code>：'/' 否则会设置失败</p>
<h2 id="最终效果"><a class="header" href="#最终效果">最终效果：</a></h2>
<p><img src="windows//res/windows/design.png" alt="效果图" />
重新打开终端，ok</p>
<div style="break-before: page; page-break-before: always;"></div><p>clion配置toolschains:</p>
<ol>
<li>mingw64</li>
<li>wsl - ubuntu
<ol>
<li>打开终端</li>
<li>进入subsystem,安装ssh
<pre><code class="language-shell">small@small:~$ sudo apt-get install ssh
[sudo] password for small:
Reading package lists... Done
Building dependency tree
Reading state information... Done
openssh-server is already the newest version (1:8.2p1-4ubuntu0.2).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
</code></pre>
</li>
<li>编辑ssh配置文件：
<pre><code class="language-shell">small@small:/etc/ssh$ sudo vi sshd_config
# 解开以下注释
Port 2222
AddressFamily any
ListenAddress 0.0.0.0
ListenAddress ::

# 还有这里
# To disable tunneled clear text passwords, change to no here!
PasswordAuthentication yes
</code></pre>
</li>
<li>启动ssh
<pre><code class="language-shell">small@small:/etc/ssh$ sudo service ssh start
* Restarting OpenBSD Secure Shell server sshd
</code></pre>
</li>
<li>clion 测试链接就 ok了！</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="wsl-默认是不开启systemctl命令的开启方法"><a class="header" href="#wsl-默认是不开启systemctl命令的开启方法">WSL 默认是不开启systemctl命令的,开启方法：</a></h3>
<ol>
<li>
<p>安装daemonize</p>
<p>sudo apt-get install daemonize</p>
</li>
<li>
<p>执行以下命令：</p>
<p>sudo daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target</p>
<p>exec sudo nsenter -t $(pidof systemd) -a su - $LOGNAME</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="wsl-linux-连不上网"><a class="header" href="#wsl-linux-连不上网">wsl linux 连不上网</a></h2>
<h3 id="解决办法管理员权限打开命令行工具"><a class="header" href="#解决办法管理员权限打开命令行工具">解决办法：管理员权限打开命令行工具</a></h3>
<pre><code class="language-shell">wsl --shutdown
netsh winsock reset
netsh int ip reset all
netsh winhttp reset proxy
ipconfig /flushdns
</code></pre>
<p>重启电脑，重试</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="检查当前运行的wsl版本"><a class="header" href="#检查当前运行的wsl版本">检查当前运行的wsl版本</a></h3>
<pre><code>wsl -l -v
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">下载windows wsl2 linux内核</a></p>
<p><code>wsl --set-version &lt;distro name&gt; 2</code>，将 <code>&lt;distro name&gt;</code> 替换为要更新的 Linux 发行版的名称。<br />
例如，<code>wsl --set-version Ubuntu-20.04 2</code> 会将<code> Ubuntu 20.04</code> 发行版设置为使用 WSL 2</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="开发环境修改wsl-默认登录用户为root"><a class="header" href="#开发环境修改wsl-默认登录用户为root">开发环境修改wsl 默认登录用户为root</a></h2>
<h3 id="1-现在用的是ubuntu找到安装目录"><a class="header" href="#1-现在用的是ubuntu找到安装目录">1. 现在用的是<code>ubuntu</code>，找到安装目录</a></h3>
<pre><code class="language-shell">C:\Users\用户名\AppData\Local\Microsoft\WindowsApps\ubuntu版本.exe config --default-user root
</code></pre>
<p><img src="windows//res/windows/wsl_path.png" alt="" /></p>
<h3 id="2-执行命令"><a class="header" href="#2-执行命令">2. 执行命令</a></h3>
<pre><code>ubuntu2004.exe config --default-user root
</code></pre>
<h3 id="3-重新进入wsl就是root用户了"><a class="header" href="#3-重新进入wsl就是root用户了">3. 重新进入wsl,就是root用户了</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="powershell-查看环境变量"><a class="header" href="#powershell-查看环境变量">powershell 查看环境变量</a></h1>
<p><code>语法</code>：$env:环境变量名称</p>
<pre><code class="language-shell"># $env 后面紧跟要查看的环境变量名称
PS C:\Users\cao_c&gt; $env:GOPATH  
D:\workproject\go
</code></pre>
<p>设置环境变量</p>
<pre><code>$env:name=value
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="系统安装过程中常见问题-汇总"><a class="header" href="#系统安装过程中常见问题-汇总">系统安装过程中常见问题 汇总</a></h2>
<h2 id="1-windows只能安装到gpt磁盘如何解决"><a class="header" href="#1-windows只能安装到gpt磁盘如何解决">1. windows只能安装到GPT磁盘如何解决</a></h2>
<ol>
<li>
<p>进入选择语言界面操作：shift+F10 ，进入命令行操作；</p>
</li>
<li>
<p>输入命令：</p>
<ol>
<li>diskpart</li>
<li>list disk （列出所有磁盘）</li>
<li>select disk 0 （选中要安装的磁盘）这里是零</li>
<li>clean （注意：<code>这一步是格式化磁盘了</code>）</li>
<li>convert gpt 转换完之后也可以直接退出，重新进入系统引导安装流程了</li>
<li>list partition</li>
<li>create partition efi size=1000 (单位是M)</li>
<li>create partition msr size=1280</li>
<li>create partition primary size=102400 （根据需要设定分区大小）</li>
<li>exit 退出命令行</li>
</ol>
</li>
<li>
<p>重新进入安装流程，选择设定好的分区安装系统就ok了</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="无法生成dconfigmsi下的常规子目录的列表拒绝访问怎么解决"><a class="header" href="#无法生成dconfigmsi下的常规子目录的列表拒绝访问怎么解决">无法生成<code>D:config.msi</code>下的常规子目录的列表，拒绝访问。怎么解决</a></h2>
<p>无法生成D:config.msi下常规子文件夹的列表拒绝访问错误。</p>
<p>修改
打开注册表 ：<code>win+R</code> + <code>regedit</code></p>
<blockquote>
<p>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Explorer/User Shell Folders/下Personal</p>
</blockquote>
<h2 id="shell中输入python等-关键字会跳转到应用商店"><a class="header" href="#shell中输入python等-关键字会跳转到应用商店">shell中输入python等 关键字会跳转到应用商店</a></h2>
<blockquote>
<p>去掉<code>WindowsApps</code> 在环境变量中</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p><code>float</code>： 漂浮在页面上层，也就是Z轴
漂浮元素不占据原有位置；
漂浮起来后会先找依赖，根节点或一同漂浮的元素</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>数据库连接失败</p>
<pre><code>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client
    at Handshake.Sequence._packetToError (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\sequences\Sequence.js:47:14)
    at Handshake.ErrorPacket (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\sequences\Handshake.js:123:18)
    at Protocol._parsePacket (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Protocol.js:291:23)
    at Parser._parsePacket (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Parser.js:433:10)
    at Parser.write (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Parser.js:43:10)
    at Protocol.write (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Protocol.js:38:16)
    at Socket.&lt;anonymous&gt; (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\Connection.js:88:28)
    at Socket.&lt;anonymous&gt; (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\Connection.js:526:10)
    at Socket.emit (events.js:315:20)
    at addChunk (_stream_readable.js:302:12)
    --------------------
    at Protocol._enqueue (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Protocol.js:144:48)
    at Protocol.handshake (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\protocol\Protocol.js:51:23)
    at Connection.connect (D:\WorkProject\DeepLearning\python_basic\node_modules\mysql\lib\Connection.js:116:18)
    at Object.&lt;anonymous&gt; (D:\WorkProject\DeepLearning\python_basic\catch\game\test.js:10:12)
    at Module._compile (internal/modules/cjs/loader.js:1200:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1220:10)
    at Module.load (internal/modules/cjs/loader.js:1049:32)
    at Function.Module._load (internal/modules/cjs/loader.js:937:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)
    at internal/main/run_main_module.js:17:47 {
  code: 'ER_NOT_SUPPORTED_AUTH_MODE',
  errno: 1251,
  sqlMessage: 'Client does not support authentication protocol requested by server; consider upgrading MySQL client',
  sqlState: '08004',
  fatal: true
}
</code></pre>
<p>解决办法：</p>
<pre><code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';

flush privileges;
</code></pre>
<p>试了之后不好使！</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="查看版本"><a class="header" href="#查看版本">查看版本</a></h3>
<blockquote>
<p>npm -v</p>
</blockquote>
<h3 id="更新"><a class="header" href="#更新">更新</a></h3>
<blockquote>
<p>npm install -g npm</p>
</blockquote>
<h3 id="指定版本更新"><a class="header" href="#指定版本更新">指定版本更新</a></h3>
<blockquote>
<p>npm -g install npm@6.8.0</p>
</blockquote>
<h3 id="清理"><a class="header" href="#清理">清理</a></h3>
<blockquote>
<p>npm cache clean --force</p>
</blockquote>
<h3 id="查看当前使用的源"><a class="header" href="#查看当前使用的源">查看当前使用的源</a></h3>
<blockquote>
<p>npm config get registry</p>
</blockquote>
<h3 id="重置为官方源"><a class="header" href="#重置为官方源">重置为官方源</a></h3>
<blockquote>
<p>npm config set registry https://registry.npmjs.org/q</p>
</blockquote>
<h3 id="修改国内源"><a class="header" href="#修改国内源">修改国内源</a></h3>
<pre><code># 阿里源升级
http://npm.taobao.org =&gt; http://npmmirror.com
http://registry.npm.taobao.org =&gt; http://registry.npmmirror.com
</code></pre>
<h4 id="1-临时修改源"><a class="header" href="#1-临时修改源">1. 临时修改源</a></h4>
<blockquote>
<p>npm --registry http://registry.npmmirror.com install express</p>
</blockquote>
<h4 id="2-永久修改"><a class="header" href="#2-永久修改">2. 永久修改</a></h4>
<blockquote>
<p>npm config set registry http://registry.npmmirror.com</p>
</blockquote>
<h3 id="使用国内镜像可以使用-cnpm-命令行npm的定制版"><a class="header" href="#使用国内镜像可以使用-cnpm-命令行npm的定制版">使用国内镜像，可以使用 cnpm 命令行,npm的定制版</a></h3>
<blockquote>
<p>npm install -g cnpm --registry=https://registry.npmmirror.com</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>node -V</p>
<p>npm install gitbook-cli -g</p>
<p>gitbook -V</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="官网"><a class="header" href="#官网">官网</a></h2>
<p>https://nodejs.org/en/download/</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>vue 和jinjia2模板冲突：</p>
<ol>
<li>修改vue模板：</li>
</ol>
<pre><code>delimiters: ['{[', ']}']
</code></pre>
<ol start="2">
<li>修改jinjia2模板：</li>
</ol>
<pre><code>app.jinja_env.variable_start_string = '[['
app.jinja_env.variable_end_string = ']]'

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-生成公钥"><a class="header" href="#1-生成公钥">1. 生成公钥</a></h2>
<pre><code class="language-shell">ssh-keygen -t rsa -C "xxxxx@xxxxx.com"  
或
ssh-keygen -t ed25519 -C "xxxxx@xxxxx.com"  

</code></pre>
<h3 id="两种操作一样只是生成密钥的加密方式不同"><a class="header" href="#两种操作一样只是生成密钥的加密方式不同"><strong>两种操作一样只是生成密钥的加密方式不同</strong></a></h3>
<h2 id="2-查看公钥"><a class="header" href="#2-查看公钥">2. 查看公钥</a></h2>
<pre><code class="language-shell">cat ~/.ssh/id_rsa.pub
</code></pre>
<pre><code class="language-shell">PS C:\Users\sss&gt; cat ~/.ssh/id_ed25519.pub
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIL7iL5mVSeEYnMJvNhpTxZR/rv2WApe2+IkfL4iXlfCu xxxxx@xxx.com
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="将本地项目提交到远程仓库需要以下操作"><a class="header" href="#将本地项目提交到远程仓库需要以下操作">将本地项目提交到远程仓库需要以下操作：</a></h2>
<h3 id="1-本地提交"><a class="header" href="#1-本地提交">1. 本地提交</a></h3>
<pre><code class="language-shell">git init   初始化本地仓库
git add . 
git commit -m "###"      
</code></pre>
<h3 id="2-添加目标仓库地址"><a class="header" href="#2-添加目标仓库地址">2. 添加目标仓库地址</a></h3>
<pre><code>git remote add origin git@xx.xx.xx.xx:repos/xxx/xxx/xxx.git
</code></pre>
<h3 id="3-同步到远程仓库先-pull-后-push"><a class="header" href="#3-同步到远程仓库先-pull-后-push">3. 同步到远程仓库，先 <code>pull</code> 后 <code>push</code></a></h3>
<pre><code># 允许一些无关联的历史	
git pull origin master --allow-unrelated-histories      

git push origin 本地分支:远程分支

# 强制进行push
git push origin master -f  

</code></pre>
<h2 id="修改远程仓库地址3种方式"><a class="header" href="#修改远程仓库地址3种方式">修改远程仓库地址3种方式</a></h2>
<h3 id="1-直接修改"><a class="header" href="#1-直接修改">1. 直接修改</a></h3>
<pre><code>git remote set-url origin  [url]  

# 可以添加多个仓库地址，也就意味着可以同时把代码提交到多个仓库
git remote set-url --add origin [url]
</code></pre>
<h3 id="2-先删除后修改"><a class="header" href="#2-先删除后修改">2. 先删除后修改</a></h3>
<blockquote>
<p>删除</p>
</blockquote>
<pre><code>git remote rm origin  
</code></pre>
<h3 id="查看-remote-url"><a class="header" href="#查看-remote-url">查看 remote url</a></h3>
<blockquote>
<p>git remote -v</p>
</blockquote>
<h3 id="3-直接修改项目目录下git-文件夹下config配置文件"><a class="header" href="#3-直接修改项目目录下git-文件夹下config配置文件">3. 直接修改项目目录下<code>.git</code> 文件夹下<code>config</code>配置文件</a></h3>
<pre><code class="language-conf">[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = git@gitee.com:username/test.git //替换为目标仓库地址
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master
</code></pre>
<h3 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h3>
<p><code>! [rejected]        master -&gt; master (fetch first) error: failed to push some refs to 'gitee.com:smallcgq/document.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details</code></p>
<ul>
<li>--force 强制提交到master分支</li>
</ul>
<pre><code class="language-shell">git push --force origin master
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="branch"><a class="header" href="#branch">branch</a></h2>
<h3 id="创建分支"><a class="header" href="#创建分支">创建分支</a></h3>
<blockquote>
<p>git branch dev</p>
</blockquote>
<h3 id="切换分支"><a class="header" href="#切换分支">切换分支</a></h3>
<blockquote>
<p>git checkout dev</p>
</blockquote>
<h3 id="提交分支"><a class="header" href="#提交分支">提交分支</a></h3>
<blockquote>
<p>git push origin dev</p>
</blockquote>
<h3 id="合并分支"><a class="header" href="#合并分支">合并分支</a></h3>
<p>先切换到要合并的分支</p>
<blockquote>
<p>git checkout master
同步代码
git pull origin master
合并代码
git merge dev
这样dev分支就合并到了master</p>
</blockquote>
<h3 id="删除本地分支"><a class="header" href="#删除本地分支">删除本地分支</a></h3>
<blockquote>
<p>git branch -d branchname</p>
</blockquote>
<h3 id="强制删除分支--d"><a class="header" href="#强制删除分支--d">强制删除分支 -D</a></h3>
<blockquote>
<p>git branch -D branchname</p>
</blockquote>
<h3 id="删除远程分支"><a class="header" href="#删除远程分支">删除远程分支</a></h3>
<blockquote>
<p>git push origin --delete branchname</p>
</blockquote>
<h2 id="tag"><a class="header" href="#tag">tag</a></h2>
<h3 id="附注标签-"><a class="header" href="#附注标签-">附注标签 ：</a></h3>
<blockquote>
<p>git tag -a versionCode -m “1.2版本”</p>
</blockquote>
<h3 id="查看标签"><a class="header" href="#查看标签">查看标签：</a></h3>
<blockquote>
<p>git show tag</p>
</blockquote>
<h3 id="切换标签"><a class="header" href="#切换标签">切换标签：</a></h3>
<blockquote>
<p>git checkout tagname</p>
</blockquote>
<blockquote>
<p>git push origin --tag</p>
</blockquote>
<h3 id="打标签"><a class="header" href="#打标签">打标签</a></h3>
<blockquote>
<p>git tag -a mirror_v1.3_app_v2.0.12</p>
</blockquote>
<h2 id="删除本地tag"><a class="header" href="#删除本地tag">删除本地TAG</a></h2>
<blockquote>
<p>git tag -d v20190514</p>
</blockquote>
<h2 id="删除远程tag"><a class="header" href="#删除远程tag">删除远程TAG</a></h2>
<blockquote>
<p>git push origin :refs/tags/v3.3.2</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="撤销"><a class="header" href="#撤销">撤销</a></h3>
<p>撤销是在本地，回滚是操作远程</p>
<ol>
<li>在工作区的代码</li>
</ol>
<pre><code class="language-shell">git checkout -- a.txt   # 丢弃某个文件，或者  
git checkout -- .       # 丢弃全部
</code></pre>
<p><strong>注意</strong>：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。</p>
<ol start="2">
<li>代码git add到缓存区，并未commit提交</li>
</ol>
<pre><code class="language-shell">## 将本地commit的内容撤回，修改的文件内容不会消失
git reset HEAD~
git reset HEAD . 
#或者
git reset HEAD a.txt
</code></pre>
<p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p>
<ol start="3">
<li>文件执行了git add操作，但想撤销对其的修改（index内回滚）</li>
</ol>
<pre><code class="language-shell"># 取消暂存
git reset HEAD fileName
# 撤销修改
git checkout fileName
</code></pre>
<ol start="4">
<li>修改的文件已被git commit，但想再次修改不再产生新的Commit</li>
</ol>
<pre><code class="language-shell"># 修改最后一次提交
git add sample.txt
git commit --amend -m"说明"
</code></pre>
<ol start="5">
<li>已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</li>
</ol>
<pre><code class="language-shell">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]
</code></pre>
<h3 id="已add但是没commit"><a class="header" href="#已add但是没commit">已add，但是没commit</a></h3>
<pre><code>git reset HEAD~
</code></pre>
<h3 id="已commit不改变代码仅仅只是想取消这个操作"><a class="header" href="#已commit不改变代码仅仅只是想取消这个操作">已commit，不改变代码，仅仅只是想取消这个操作</a></h3>
<pre><code>git reset --soft HEAD^  # ^ 一次提交 ^^ 两次提交
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="回滚-回滚是远程仓库操作撤销是本地操作"><a class="header" href="#回滚-回滚是远程仓库操作撤销是本地操作">回滚 （回滚是远程仓库操作，撤销是本地操作）</a></h2>
<p>已进行git push，即已推送到<code>远程仓库</code>中。我们将已被提交到“远程仓库”的代码还原操作叫做<code>回滚</code>！</p>
<blockquote>
<p><code>注意</code>：<code>对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！</code></p>
</blockquote>
<h2 id="1-撤销指定文件到指定版本"><a class="header" href="#1-撤销指定文件到指定版本">1. 撤销指定文件到指定版本</a></h2>
<pre><code class="language-shell"># 查看指定文件的历史版本
git log &lt;filename&gt;
# 回滚到指定commitID
git checkout &lt;commitID&gt; &lt;filename&gt;
</code></pre>
<h2 id="2-删除最后一次远程提交"><a class="header" href="#2-删除最后一次远程提交">2. 删除最后一次远程提交</a></h2>
<ol>
<li>
<p>使用revert</p>
<pre><code class="language-shell">git revert HEAD
git push origin master
</code></pre>
</li>
<li>
<p>使用reset</p>
<pre><code class="language-shell">git reset --hard HEAD^
git push origin master -f
</code></pre>
</li>
</ol>
<p><code>二者区别</code>：</p>
<ul>
<li><code>revert</code>是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>
<li><code>reset</code>是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</li>
</ul>
<h4 id="回滚某次提交"><a class="header" href="#回滚某次提交">回滚某次提交</a></h4>
<pre><code class="language-shell"># 找到要回滚的commitID
git log
git revert commitID
</code></pre>
<h4 id="删除某次提交"><a class="header" href="#删除某次提交">删除某次提交</a></h4>
<pre><code class="language-shell">git log --oneline -n5
</code></pre>
<p><img src="git//res/git/git_1.png" alt="git1" /></p>
<pre><code class="language-shell">git rebase -i "commit id"^
</code></pre>
<p><strong>注意</strong>：需要注意最后的^号，意思是commit id的前一次提交</p>
<pre><code class="language-shell">git rebase -i "8475cb5"^
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="删除文件夹"><a class="header" href="#删除文件夹">删除文件夹</a></h3>
<pre><code>git rm --cached -r  dir_name
</code></pre>
<h3 id="删除文件"><a class="header" href="#删除文件">删除文件</a></h3>
<pre><code>git rm --cached filename
</code></pre>
<h3 id="删除后不用git-add-直接提交"><a class="header" href="#删除后不用git-add-直接提交">删除后不用<code>git add</code> 直接提交</a></h3>
<pre><code>git commit -m "desc"     
</code></pre>
<h3 id="提交"><a class="header" href="#提交">提交</a></h3>
<pre><code>git push
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="branch-1"><a class="header" href="#branch-1">branch</a></h2>
<h2 id="tag-1"><a class="header" href="#tag-1">tag</a></h2>
<h3 id="附注标签--1"><a class="header" href="#附注标签--1">附注标签 ：</a></h3>
<blockquote>
<p>git tag -a versionCode -m “1.2版本”</p>
</blockquote>
<h3 id="查看标签-1"><a class="header" href="#查看标签-1">查看标签：</a></h3>
<blockquote>
<p>git show tag</p>
</blockquote>
<h3 id="切换标签-1"><a class="header" href="#切换标签-1">切换标签：</a></h3>
<blockquote>
<p>git checkout tagname</p>
</blockquote>
<blockquote>
<p>git push origin --tag</p>
</blockquote>
<h3 id="打标签-1"><a class="header" href="#打标签-1">打标签</a></h3>
<blockquote>
<p>git tag -a mirror_v1.3_app_v2.0.12</p>
</blockquote>
<h2 id="删除本地tag-1"><a class="header" href="#删除本地tag-1">删除本地TAG</a></h2>
<blockquote>
<p>git tag -d v20190514</p>
</blockquote>
<h2 id="删除远程tag-1"><a class="header" href="#删除远程tag-1">删除远程TAG</a></h2>
<blockquote>
<p>git push origin :refs/tags/v3.3.2</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一次使用git没有环境"><a class="header" href="#第一次使用git没有环境">第一次使用git，没有环境？</a></h1>
<h3 id="1-先安装git"><a class="header" href="#1-先安装git">1. 先安装git</a></h3>
<h3 id="2-生成公钥用来添加到远程仓库"><a class="header" href="#2-生成公钥用来添加到远程仓库">2. 生成公钥，用来添加到远程仓库</a></h3>
<ol>
<li>生成公钥</li>
</ol>
<pre><code class="language-shell"># 生成公钥，然后一路回车
ssh-keygen -t rsa -C "cao_cgq@163.com"
</code></pre>
<ol start="2">
<li>查看公钥
<img src="git//res/git/git_6.png" alt="查看公钥" /></li>
</ol>
<h3 id="3-复制公钥打开码云--个人头像点设置-找到安全设置-ssh公钥"><a class="header" href="#3-复制公钥打开码云--个人头像点设置-找到安全设置-ssh公钥">3. 复制公钥，打开码云-&gt; 个人头像点设置-&gt;找到安全设置-&gt;SSH公钥</a></h3>
<p><img src="git//res/git/git_7.png" alt="查看公钥" /></p>
<p>添加完公钥之后，就可以接下来的步骤了</p>
<h3 id="怎么样将代码提交到远程仓库"><a class="header" href="#怎么样将代码提交到远程仓库">怎么样将代码提交到远程仓库</a></h3>
<h3 id="1-在码云新建仓库beego_first"><a class="header" href="#1-在码云新建仓库beego_first">1. 在码云新建仓库，beego_first</a></h3>
<p><img src="git//res/git/git_3.png" alt="新建仓库" /></p>
<h3 id="2-本地项目路径下初始化仓库"><a class="header" href="#2-本地项目路径下初始化仓库">2. 本地项目路径下初始化仓库</a></h3>
<pre><code class="language-shell">git init
</code></pre>
<p><img src="git//res/git/git_2.png" alt="初始化" /></p>
<h3 id="3-本地项目添加远程仓库"><a class="header" href="#3-本地项目添加远程仓库">3. 本地项目添加远程仓库</a></h3>
<pre><code class="language-shell"># git remote add origin 仓库地址
git remote add origin git@gitee.com:SmallMrCao/beego_first.git
</code></pre>
<p><img src="git//res/git/git_4.png" alt="初始化" /></p>
<h3 id="4-添加完之后先pull然后再add"><a class="header" href="#4-添加完之后先pull然后再add">4. 添加完之后先pull，然后再add</a></h3>
<pre><code class="language-shell">git pull
git add *
</code></pre>
<p>出现这个问题，说明在add之前没有pull，需要执行以下命令，把无关的内容pull下来</p>
<p><img src="git//res/git/git_5.png" alt="没有关联" /></p>
<pre><code class="language-shell">git pull origin master --allow-unrelated-histories
</code></pre>
<h3 id="5-最后执行提交就完成了"><a class="header" href="#5-最后执行提交就完成了">5. 最后执行提交就完成了</a></h3>
<pre><code class="language-shell">git push
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="gitlab-删除默认main-分支"><a class="header" href="#gitlab-删除默认main-分支">gitlab 删除默认<code>main</code> 分支</a></h3>
<ol>
<li>将默认分支修改为master<br />
Settings -&gt; Repository -&gt; Default branch</li>
<li>Repository -&gt; Branches -&gt; 删除</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="拉取主仓库"><a class="header" href="#拉取主仓库">拉取主仓库</a></h2>
<p>同步主项目加上 <code>--recurse-submodules</code> 递归拉取子项目</p>
<pre><code>git clone git@github.com:smallcgq/xbook.git --recurse-submodules
</code></pre>
<h2 id="添加其他仓库到当前仓库"><a class="header" href="#添加其他仓库到当前仓库">添加其他仓库到当前仓库</a></h2>
<pre><code>git submodule add https://github.com/alex-shpak/hugo-book themes/book

git clone https://github.com/alex-shpak/hugo-book --recursive
</code></pre>
<ul>
<li>添加完成项目根目录下会多出一个 <code>.gitmodules</code> 文件</li>
</ul>
<h2 id="同步其他仓库更新"><a class="header" href="#同步其他仓库更新">同步其他仓库更新</a></h2>
<pre><code>//一步到位，不用挨个查找，直接遍历一遍
git submodule foreach git pull
</code></pre>
<h2 id="删除submodule"><a class="header" href="#删除submodule">删除submodule</a></h2>
<pre><code>git submodule deinit themes/book
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="主要目录介绍"><a class="header" href="#主要目录介绍">主要目录介绍</a></h3>
<ul>
<li>/ ：根目录，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</li>
<li>/bin ：bin 就是二进制（binary）英文缩写。在一般的系统当中，都可以在这个目录下找到linux常用的命令。系统所需要的那些命令位于此目录。</li>
<li>/boot ：Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。</li>
<li>/cdrom ：这个目录在刚刚安装系统的时候是空的。可以将光驱文件系统挂在这个目录下。例如：mount /dev/cdrom /cdrom</li>
<li>/dev ：dev 是设备（device)的英文缩写。这个目录对所有的用户都十分重要。因为在这个目录中包含了所有linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序。这一点和常用的windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。</li>
<li>/etc ：etc这个目录是linux系统中最重要的目录之一。在这个目录下存放了系统管理时要用到的各种配置文件和子目录。要用到的网络配置文件，文件系统，x系统配置文件，设备配置信息，设置用户信息等都在这个目录下。</li>
<li>/home：如果建立一个用户，用户名是"xx",那么在/home目录下就有一个对应的/home/xx路径，用来存放用户的主目录。</li>
<li>/lib：lib是库（library）英文缩写。这个目录是用来存放系统动态连接共享库的。几乎所有的应用程序都会用到这个目录下的共享库。因此，千万不要轻易对这个目录进行什么操作，一旦发生问题，系统就不能工作了。</li>
<li>/lost+found ：在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。正在上传、重新上传、取消Linux系统有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。</li>
<li>/mnt ：这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fstab的定义。</li>
<li>/media ：有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。</li>
<li>/opt ：这里主要存放那些可选的程序。</li>
<li>/proc ：可以在这个目录下获取系统信息。这些信息是在内存中，由系统自己产生的。</li>
<li>/root ：Linux超级权限用户root的家目录。</li>
<li>/sbin ：这个目录是用来存放系统管理员的系统管理程序。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin ：/usr/X11R6/sbin或/usr/local/sbin目录是相似的，凡是目录sbin中包含的都是root权限才能执行的。</li>
<li>/selinux ：对SElinux的一些配置文件目录，SElinux可以让linux更加安全。</li>
<li>/srv ： 服务启动后，所需访问的数据目录，举个例子来说，www服务启动读取的网页数据就可以放在/srv/www中</li>
<li>/sys ：Linux 内核中设计较新的一种虚拟的基于内存的文件系统，它的作用与 proc 有些类似，但除了与 proc 相同的具有查看和设定内核参数功能之外，还有为 Linux 统一设备模型作为管理之用。</li>
<li>/tmp ：临时文件目录，用来存放不同程序执行时产生的临时文件。有时用户运行程序的时候，会产生临时文件。/tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。</li>
<li>/usr：这是linux系统中占用硬盘空间最大的目录。用户的很多应用程序和文件都存放在这个目录下。在这个目录下，可以找到那些不适合放在/bin或/etc目录下的额外的工具</li>
<li>/usr/local ：这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts)放到/usr/local目录下面。</li>
<li>/usr/share ：系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。</li>
<li>/var ：这个目录的内容是经常变动的，看名字就知道，可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/ www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="删除本地分支-1"><a class="header" href="#删除本地分支-1">删除本地分支</a></h2>
<pre><code>git branch -d branchname
//强制删除 -D
git branch -D branchname 
</code></pre>
<h2 id="删除远程分支-1"><a class="header" href="#删除远程分支-1">删除远程分支</a></h2>
<pre><code>git push origin --delete branchname

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="删除文件夹-1"><a class="header" href="#删除文件夹-1">删除文件夹</a></h3>
<pre><code>git rm --cached -r  dir_name
</code></pre>
<h3 id="删除文件-1"><a class="header" href="#删除文件-1">删除文件</a></h3>
<pre><code>git rm --cached filename
</code></pre>
<h3 id="删除后不用git-add-直接提交-1"><a class="header" href="#删除后不用git-add-直接提交-1">删除后不用<code>git add</code> 直接提交</a></h3>
<pre><code>git commit -m "desc"     
</code></pre>
<h3 id="提交-1"><a class="header" href="#提交-1">提交</a></h3>
<pre><code>git push
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="回滚-回滚是远程仓库操作撤销是本地操作-1"><a class="header" href="#回滚-回滚是远程仓库操作撤销是本地操作-1">回滚 （回滚是远程仓库操作，撤销是本地操作）</a></h2>
<p>已进行git push，即已推送到<code>远程仓库</code>中。我们将已被提交到“远程仓库”的代码还原操作叫做<code>回滚</code>！</p>
<blockquote>
<p><code>注意</code>：<code>对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！</code></p>
</blockquote>
<h2 id="1-撤销指定文件到指定版本-1"><a class="header" href="#1-撤销指定文件到指定版本-1">1. 撤销指定文件到指定版本</a></h2>
<pre><code class="language-shell"># 查看指定文件的历史版本
git log &lt;filename&gt;
# 回滚到指定commitID
git checkout &lt;commitID&gt; &lt;filename&gt;
</code></pre>
<h2 id="2-删除最后一次远程提交-1"><a class="header" href="#2-删除最后一次远程提交-1">2. 删除最后一次远程提交</a></h2>
<ol>
<li>
<p>使用revert</p>
<pre><code class="language-shell">git revert HEAD
git push origin master
</code></pre>
</li>
<li>
<p>使用reset</p>
<pre><code class="language-shell">git reset --hard HEAD^
git push origin master -f
</code></pre>
</li>
</ol>
<p><code>二者区别</code>：</p>
<ul>
<li><code>revert</code>是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>
<li><code>reset</code>是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</li>
</ul>
<h4 id="回滚某次提交-1"><a class="header" href="#回滚某次提交-1">回滚某次提交</a></h4>
<pre><code class="language-shell"># 找到要回滚的commitID
git log
git revert commitID
</code></pre>
<h4 id="删除某次提交-1"><a class="header" href="#删除某次提交-1">删除某次提交</a></h4>
<pre><code class="language-shell">git log --oneline -n5
</code></pre>
<p><img src="git//res/git/git_1.png" alt="git1" /></p>
<pre><code class="language-shell">git rebase -i "commit id"^
</code></pre>
<p><strong>注意</strong>：需要注意最后的^号，意思是commit id的前一次提交</p>
<pre><code class="language-shell">git rebase -i "8475cb5"^
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="撤销-1"><a class="header" href="#撤销-1">撤销</a></h3>
<p>撤销是在本地，回滚是操作远程</p>
<ol>
<li>在工作区的代码</li>
</ol>
<pre><code class="language-shell">git checkout -- a.txt   # 丢弃某个文件，或者  
git checkout -- .       # 丢弃全部
</code></pre>
<p><strong>注意</strong>：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。</p>
<ol start="2">
<li>代码git add到缓存区，并未commit提交</li>
</ol>
<pre><code class="language-shell">## 将本地commit的内容撤回，修改的文件内容不会消失
git reset HEAD~
git reset HEAD . 
#或者
git reset HEAD a.txt
</code></pre>
<p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p>
<ol start="3">
<li>文件执行了git add操作，但想撤销对其的修改（index内回滚）</li>
</ol>
<pre><code class="language-shell"># 取消暂存
git reset HEAD fileName
# 撤销修改
git checkout fileName
</code></pre>
<ol start="4">
<li>修改的文件已被git commit，但想再次修改不再产生新的Commit</li>
</ol>
<pre><code class="language-shell"># 修改最后一次提交
git add sample.txt
git commit --amend -m"说明"
</code></pre>
<ol start="5">
<li>已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</li>
</ol>
<pre><code class="language-shell">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]
</code></pre>
<h3 id="已add但是没commit-1"><a class="header" href="#已add但是没commit-1">已add，但是没commit</a></h3>
<pre><code>git reset HEAD~
</code></pre>
<h3 id="已commit不改变代码仅仅只是想取消这个操作-1"><a class="header" href="#已commit不改变代码仅仅只是想取消这个操作-1">已commit，不改变代码，仅仅只是想取消这个操作</a></h3>
<pre><code>git reset --soft HEAD^  # ^ 一次提交 ^^ 两次提交
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-创建磁盘阵列"><a class="header" href="#1-创建磁盘阵列">1. 创建磁盘阵列</a></h3>
<pre><code>`ctrl+r`  创建磁盘阵列
</code></pre>
<h3 id="2-启用磁盘阵列f12-进入bios-选择-dataseting-选择-raid"><a class="header" href="#2-启用磁盘阵列f12-进入bios-选择-dataseting-选择-raid">2. 启用磁盘阵列：F12 进入bios 选择 dataseting 选择 raid</a></h3>
<h3 id="3-安装系统--f2-选择u盘安装"><a class="header" href="#3-安装系统--f2-选择u盘安装">3. 安装系统  f2 选择U盘安装</a></h3>
<ol>
<li>按<code>e</code> 把DVD改成U盘，那么得先知道U盘是哪个</li>
<li>按<code>c</code> 进入命令行， <code>blkid</code> 查看详细盘符说明</li>
<li>hd:/dev/sda4 quit</li>
<li>ctrl + x 执行安装流程</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="设置grub2-分辨率"><a class="header" href="#设置grub2-分辨率">设置grub2 分辨率</a></h3>
<ol>
<li>进入<code>grub</code> 命令行<br />
在<code>grub</code> 启动界面，按下<code>c</code> 键进入命令行界面</li>
<li>查询支持的分辨率<br />
输入 <code>videoinfo</code> 得到支持的分辨率列表</li>
<li>命令行设置选择的分辨率<br />
输入<code>terminal_output console</code>  进入终端模式，输入 <code>set gfxmode=1024x768</code> (x 不是*)</li>
<li>退出<br />
<code>terminal_output gfxterm</code> 退出到图形模式</li>
</ol>
<h3 id="进入系统设置"><a class="header" href="#进入系统设置">进入系统设置</a></h3>
<p>/boot/grub/grub.cfg</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="键盘失灵"><a class="header" href="#键盘失灵">键盘失灵</a></h3>
<p>1.安装软件后键盘鼠标失灵，需要安装xserver包
xserver-xorg-input-all
保证电脑能联网，或者通过ssh远程连接</p>
<pre><code>sudo apt install xserver-xorg-input-all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="给系统设置固定ip"><a class="header" href="#给系统设置固定ip">给系统设置固定IP</a></h3>
<p>定位到目录：</p>
<pre><code class="language-shell">cd /etc/sysconfig/network-scripts

ifcfg-em1      ifdown-eth   ifdown-ppp       ifup          ifup-ipv6   ifup-routes    init.ipv6-global
ifcfg-em1.bak  ifdown-ib    ifdown-routes    ifup-aliases  ifup-isdn   ifup-sit       network-functions
ifcfg-em2      ifdown-ippp  ifdown-sit       ifup-bnep     ifup-plip   ifup-Team      network-functions-ipv6
ifcfg-lo       ifdown-ipv6  ifdown-Team      ifup-eth      ifup-plusb  ifup-TeamPort
ifdown         ifdown-isdn  ifdown-TeamPort  ifup-ib       ifup-post   ifup-tunnel
ifdown-bnep    ifdown-post  ifdown-tunnel    ifup-ippp     ifup-ppp    ifup-wireless
</code></pre>
<p><code>vi</code> 编辑 <code>ifcfg-em1</code>文件， 这个文件是对应网卡的脚本内容，直接修改：增加如下几项，包括IP地址，网关等等</p>
<pre><code class="language-shell">IPADDR="192.168.2.6"
NETMASK="255.255.255.0"
GATEWAY="192.168.1.1"
NETWORK="192.168.1.0"
DNS1="192.168.1.1"
</code></pre>
<h3 id="修改完成后重启network"><a class="header" href="#修改完成后重启network">修改完成后，重启network</a></h3>
<pre><code class="language-shell">service network restart
</code></pre>
<p>ending...</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="华为源"><a class="header" href="#华为源">华为源</a></h3>
<pre><code class="language-shell">sudo sed -i "s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g" /etc/apt/sources.list
sudo sed -i "s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g" /etc/apt/sources.list
# 如果之前用的aliyun的
sudo sed -i "s@http://.*mirrors.aliyun.com@http://repo.huaweicloud.com@g" /etc/apt/sources.list
sudo sed -i "s@http://.*mirrors.aliyun.com@http://repo.huaweicloud.com@g" /etc/apt/sources.list
</code></pre>
<h3 id="阿里源"><a class="header" href="#阿里源">阿里源</a></h3>
<pre><code class="language-shell"># 先备份原sources.list 文件
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
# sed 命令替换域名
sudo sed -i 's/security.ubuntu/mirrors.aliyun/g' /etc/apt/sources.list
sudo sed -i 's/archive.ubuntu/mirrors.aliyun/g' /etc/apt/sources.list
sudo apt update
sudo apt-get upgrade    //更新已安装的包到最新，这个是可选的


sudo sed -i 's/repo.huaweicloud/mirrors.aliyun/g' /etc/apt/sources.list
sudo sed -i 's/repo.huaweicloud/mirrors.aliyun/g' /etc/apt/sources.list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="修改系统时区"><a class="header" href="#修改系统时区">修改系统时区</a></h3>
<pre><code class="language-shell">
sudo rm -f /etc/localtime
sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
<p>source:<br />
https://m.php.cn/article/488386.html</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="卸载软件"><a class="header" href="#卸载软件">卸载软件</a></h3>
<ol>
<li>apt-get autoremove 删除相关联的所有包</li>
</ol>
<pre><code>sudo apt-get autoremove docker docker-ce docker-engine  docker.io  containerd runc
</code></pre>
<ol start="2">
<li>看看还有没有</li>
</ol>
<pre><code>dpkg -l | grep docker
</code></pre>
<ol start="3">
<li>卸载一切有关联的软件</li>
</ol>
<pre><code>sudo apt-get autoremove docker-ce-*
</code></pre>
<ol start="4">
<li>删除配置和相关目录</li>
</ol>
<pre><code>sudo rm -rf /etc/systemd/system/docker.service.d
sudo rm -rf /var/lib/docker
</code></pre>
<ol start="5">
<li>卸载完毕</li>
</ol>
<pre><code>docker --version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="定时任务"><a class="header" href="#定时任务">定时任务</a></h3>
<ol>
<li>查看定时任务</li>
</ol>
<pre><code class="language-shell">crontab -l
</code></pre>
<ol start="2">
<li>编辑定时任务</li>
</ol>
<pre><code class="language-shell">crontab -e
</code></pre>
<p>每周五23点定时关机</p>
<pre><code class="language-shell">0 23 * * 5 /usr/sbin/shutdown now
</code></pre>
<p><strong>命令必须是完整路径：/usr/sbin/shutdown</strong></p>
<p><strong>查看命令路径：which</strong></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th>命令</th><th>描述</th><th>注解</th></tr></thead><tbody>
<tr><td>ls -h</td><td>比如:20M 文件大小以给人看的格式显示</td><td></td></tr>
<tr><td>crontab</td><td><a href="linux/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html">定时任务</a></td><td></td></tr>
<tr><td>cat filename</td><td>查看文件</td><td></td></tr>
<tr><td>tail filename -n linenum</td><td>查看文件指定多少行</td><td></td></tr>
<tr><td>reboot</td><td>普通重启</td><td></td></tr>
<tr><td>shutdown -r now</td><td>立即重启(root)</td><td></td></tr>
<tr><td>shutdown -r 10</td><td>10分钟后重启</td><td></td></tr>
<tr><td>shutdown -r 20:00</td><td>8点重启</td><td></td></tr>
<tr><td>halt</td><td>立刻关机</td><td></td></tr>
<tr><td>poweroff</td><td>立刻关机</td><td></td></tr>
<tr><td>shutdown -h now</td><td>立刻关机(root)</td><td></td></tr>
<tr><td>shutdown -h 10</td><td>10分钟后关机</td><td></td></tr>
<tr><td>ps</td><td><a href="linux/%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B.html">查找进程</a></td><td></td></tr>
<tr><td>sudo apt-get remove</td><td>删除软件</td><td>不会删除配置文件</td></tr>
<tr><td>sudo apt-get purge mysql</td><td>彻底删除</td><td></td></tr>
</tbody></table>
</div>
<h2 id="文件"><a class="header" href="#文件">文件</a></h2>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>描述</th><th>注解</th></tr></thead><tbody>
<tr><td>scp</td><td>上传下载文件</td><td></td></tr>
<tr><td>scp root@host:/root/log.txt /log.txt</td><td>下载文件</td><td></td></tr>
<tr><td>scp /log.txt root@host:/root/log.txt</td><td>上传文件</td><td></td></tr>
<tr><td>scp -r root@host:/root/logs /path</td><td>下载文件夹</td><td></td></tr>
<tr><td>scp -r /path root@host:/root/logs</td><td>上传文件夹</td><td></td></tr>
<tr><td>du -sh ./*</td><td>输出当前目录包含的所有文件大小</td><td>方便用于查找大文件</td></tr>
<tr><td>df -h</td><td>输出当前目录下所有文件总大小</td><td>查看存储情况</td></tr>
</tbody></table>
</div>
<h3 id="tar-压缩文件"><a class="header" href="#tar-压缩文件">tar 压缩文件</a></h3>
<ol>
<li>文件解压缩</li>
</ol>
<blockquote>
<p>tar -xvf xxx.tar</p>
</blockquote>
<ol start="2">
<li>查看压缩文件</li>
</ol>
<blockquote>
<p>tar -t xxx.tar</p>
</blockquote>
<h3 id="sed-流编辑"><a class="header" href="#sed-流编辑">sed 流编辑</a></h3>
<ol>
<li>p  输出文件指定行</li>
</ol>
<blockquote>
<p>sed -n '1p' text.txt</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-拷贝或创建软链接---etcsystemdsystem"><a class="header" href="#1-拷贝或创建软链接---etcsystemdsystem">1. 拷贝或创建软链接 -&gt; /etc/systemd/system</a></h3>
<pre><code>sudo cp /lib/systemd/system/rc-local.service /etc/systemd/system
</code></pre>
<h3 id="2-编辑-rc-localservice-文件增加如下内容"><a class="header" href="#2-编辑-rc-localservice-文件增加如下内容">2. 编辑 rc-local.service 文件，增加如下内容：</a></h3>
<pre><code class="language-shell">[Install]  
WantedBy=multi-user.target
Alias=rc-local.service
</code></pre>
<h3 id="3-创建etcrclocal"><a class="header" href="#3-创建etcrclocal">3. 创建/etc/rc.local</a></h3>
<pre><code>#!/bin/sh

/home/zouni88/dns/alidns dns &amp;
</code></pre>
<h3 id="4-增加可执行权限"><a class="header" href="#4-增加可执行权限">4. 增加可执行权限</a></h3>
<pre><code>chmod +x /etc/rc.local
</code></pre>
<h3 id="最后测试"><a class="header" href="#最后测试">最后测试</a></h3>
<p>启动</p>
<pre><code>systemctl start rc-local.service
</code></pre>
<p>查看状态</p>
<pre><code>system status rc-local.service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="进程相关"><a class="header" href="#进程相关">进程相关</a></h3>
<pre><code># 查找进程
ps auxf |grep uwsgi

# 查看当前进程
pstree -ap|grep gunicorn

# 杀死 进程
kill -9 544

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>内核版本</p>
<pre><code class="language-Shell">uname -a
</code></pre>
<p>所有版本信息</p>
<pre><code class="language-Shell">lsb_release -a
</code></pre>
<p>centos 查看版本</p>
<pre><code class="language-Shell">cat /etc/redhat-release
</code></pre>
<p>结果</p>
<pre><code class="language-Shell">CentOS Linux release 8.1.1911 (Core)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>a. 获取当前IP，优先显示IPV6：
https://ip.netarm.com
b. 获取IPV4：
https://ipv4.netarm.com
c. 获取IPV6：
https://ipv6.netarm.com</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="查看硬盘使用情况"><a class="header" href="#查看硬盘使用情况">查看硬盘使用情况</a></h2>
<h3 id="1-查看挂载的硬盘空间使用情况"><a class="header" href="#1-查看挂载的硬盘空间使用情况">1. 查看挂载的硬盘空间使用情况</a></h3>
<blockquote>
<p>df -h</p>
</blockquote>
<h3 id="2-当前目录下文件硬盘使用"><a class="header" href="#2-当前目录下文件硬盘使用">2. 当前目录下文件硬盘使用</a></h3>
<blockquote>
<p>du -h</p>
</blockquote>
<h3 id="3-推荐查看所有硬盘"><a class="header" href="#3-推荐查看所有硬盘">3. 推荐，查看所有硬盘</a></h3>
<blockquote>
<p>lsblk</p>
</blockquote>
<blockquote>
<p>blkid</p>
</blockquote>
<h3 id="4-fdisk--l-硬盘名分区名-命令可以显示或操作磁盘分区表"><a class="header" href="#4-fdisk--l-硬盘名分区名-命令可以显示或操作磁盘分区表">4. <code>fdisk -l</code> 硬盘名|分区名 命令可以显示或操作磁盘分区表</a></h3>
<blockquote>
<p>fdisk -l</p>
</blockquote>
<blockquote>
<p>fdisk -l /dev/sda</p>
</blockquote>
<h3 id="查看大文件"><a class="header" href="#查看大文件">查看大文件</a></h3>
<blockquote>
<p>du -h -x --max-depth=1</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="查看硬盘使用情况-1"><a class="header" href="#查看硬盘使用情况-1">查看硬盘使用情况</a></h3>
<pre><code>df -h
</code></pre>
<h3 id="查看大文件-1"><a class="header" href="#查看大文件-1">查看大文件</a></h3>
<pre><code>du -h -x --max-depth=1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="查看指定端口占用情况"><a class="header" href="#查看指定端口占用情况">查看指定端口占用情况</a></h3>
<blockquote>
<p>netstat -apn|grep 8888</p>
</blockquote>
<blockquote>
<p>lsof -i:8080</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="linux-设置静态ip"><a class="header" href="#linux-设置静态ip">linux 设置静态IP</a></h3>
<ol>
<li>查看网卡</li>
</ol>
<pre><code class="language-shell">root@zouni:~# ifconfig
    eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
            inet 192.168.1.6  netmask 255.255.255.0  broadcast 192.168.1.255
            inet6 fe80::2247:47ff:fe98:9e30  prefixlen 64  scopeid 0x20&lt;link&gt;
            inet6 240e:305:7880:36d2:2247:47ff:fe98:9e30  prefixlen 64  scopeid 0x0&lt;global&gt;
            ether 20:47:47:98:9e:30  txqueuelen 1000  (Ethernet)
            RX packets 15733  bytes 3827041 (3.8 MB)
            RX errors 0  dropped 8440  overruns 0  frame 0
            TX packets 3586  bytes 376173 (376.1 KB)
            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
            device interrupt 16

    enp3s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
            ether 00:e0:51:46:0b:01  txqueuelen 1000  (Ethernet)
            RX packets 0  bytes 0 (0.0 B)
            RX errors 0  dropped 0  overruns 0  frame 0
            TX packets 0  bytes 0 (0.0 B)
            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

    lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
            inet 127.0.0.1  netmask 255.0.0.0
            inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
            loop  txqueuelen 1000  (Local Loopback)
            RX packets 14175  bytes 21113848 (21.1 MB)
            RX errors 0  dropped 0  overruns 0  frame 0
            TX packets 14175  bytes 21113848 (21.1 MB)
            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<ol start="2">
<li>设置网卡配置</li>
</ol>
<pre><code class="language-shell">root@zouni:/etc/network# cd /etc/netplan
root@zouni:/etc/netplan# ls
00-installer-config.yaml
root@zouni:/etc/netplan# vi 00-installer-config.yaml

# This is the network config written by 'subiquity'
network:
  ethernets:
    eno1:
      dhcp4: no
      dhcp6: no
      addresses: [192.168.1.6/24]
      optional: true
      gateway4: 192.168.1.1
      nameservers:
        addresses: [192.168.1.1,114.114.114.114]


    enp3s0:
      dhcp4: true
  version: 2
</code></pre>
<ol start="3">
<li>重启网卡</li>
</ol>
<pre><code>root@zouni:/etc/netplan# netplan apply
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linux-防火墙-ufw-firewalld-iptables"><a class="header" href="#linux-防火墙-ufw-firewalld-iptables">Linux 防火墙 <code>ufw</code> <code>firewalld</code> <code>iptables</code></a></h2>
<ol>
<li>默认：iptables</li>
</ol>
<h2 id="2-ubuntu--ufw"><a class="header" href="#2-ubuntu--ufw">2. <code>ubuntu</code> : <code>ufw</code></a></h2>
<ul>
<li>ufw 查询防火墙状态</li>
</ul>
<pre><code class="language-shell">查看开放端口：

sudo ufw status
允许80端口开放：

sudo ufw allow 80
允许22端口开放：

sudo ufw allow 22
启动防火墙：

sudo ufw enable
重启防火墙使端口配置生效：

sudo ufw reload

ufw status
# 关闭
ufw disable
</code></pre>
<h2 id="3-红帽系列-firewall"><a class="header" href="#3-红帽系列-firewall">3. 红帽系列 <code>firewall</code></a></h2>
<pre><code class="language-shell">systemctl status firewalld
# 启动防火墙
systemctl start firewalld
# 停止防火墙
systemctl stop firewalld
# 永久停用防火墙
systemctl disable firewalld
# 启用防火墙
systemctl enable firewalld
</code></pre>
<ul>
<li>防火墙开放指定端口</li>
</ul>
<pre><code class="language-shell"># permanent 永久
# 开放8080端口
firewall-cmd --permanent --zone=public --add-port=8080/tcp
# 查询8080端口开放情况，若返回success，则为开放成功
# --zone docker 
firewall-cmd --zone=public --query-port=8080/tcp
# 重启防火墙
firewall-cmd --reload
</code></pre>
<ul>
<li>其它防火墙命令</li>
</ul>
<pre><code>启动： systemctl start firewalld
查看状态： systemctl status firewalld
停止： systemctl disable firewalld
禁用： systemctl stop firewalld
启动服务：systemctl start firewalld.service
关闭服务：systemctl stop firewalld.service
重启服务：systemctl restart firewalld.service
服务的状态：systemctl status firewalld.service
在开机时启用一个服务：systemctl enable firewalld.service
在开机时禁用一个服务：systemctl disable firewalld.service
查看服务是否开机启动：systemctl is-enabled firewalld.service
查看已启动的服务列表：systemctl list-unit-files|grep enabled
查看启动失败的服务列表：systemctl --failed
查看版本： firewall-cmd --version
查看帮助： firewall-cmd --help
显示状态： firewall-cmd --state
查看所有打开的端口： firewall-cmd --zone=public --list-ports
更新防火墙规则： firewall-cmd --reload
查看区域信息: firewall-cmd --get-active-zones
查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0
拒绝所有包：firewall-cmd --panic-on
取消拒绝状态： firewall-cmd --panic-off
查看是否拒绝： firewall-cmd --query-panic
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ssh-rootip-ssh登录时提示permission-denied-please-try-again"><a class="header" href="#ssh-rootip-ssh登录时提示permission-denied-please-try-again"><code>ssh root@ip</code> ssh登录时提示「permission denied please try again」</a></h3>
<blockquote>
<p>sudo vi /etc/ssh/sshd_config</p>
</blockquote>
<p>编辑</p>
<blockquote>
<p>PermitRootLogin yes
保存，重启ssh服务
service sshd restart</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>查看ftp默认用户主目录在哪里
Yum install finger</p>
<p>finger ftp
[root@OX39Ø6c finger ftp
Login: ftp
Directory: / var/ftp
Never logged in.
No mail.
No Plan.
Name:
FTP User
Shell:
/sbin/nologin /</p>
<p>修改默认目录
vim /etc/passwd</p>
<p>[root@OX39Ø6c vim /etc/passwd
ftp:x:14:50: FTP</p>
<p>修改/var/ftp 为想要修改的目录路径
然后重启vsftpd服务 service vsftpd restart</p>
<p>如果修改之后仍不能用，需要关闭  SELinux</p>
<ol>
<li>修改/etc/selinux/config文件中的SELINUX="" 为 disabled ，然后重启。</li>
<li>如果不想重启系统，使用命令setenforce 0</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>1.查看是否安装ftp服务</p>
<p>rpm -q vsftpd</p>
<p>2.安装ftp服务</p>
<p>yum install vsftpd</p>
<p>3.开机启动</p>
<p> chkconfig vsftpd on</p>
<p>4.启动服务</p>
<p> service vsftpd start</p>
<p>5.重新启动vsftpd</p>
<p>service vsftpd restart</p>
<p>来自 <a href="https://www.cnblogs.com/surge/p/3868270.html">https://www.cnblogs.com/surge/p/3868270.html</a></p>
<p>修改相关配置项在 /etc/vsftpd/vsftpd.conf中</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>KL散度 -&gt; 相对熵</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">
import tensorflow as tf
# 这一步在网络初始化后
mode.summary()

tf.summary.create_file_writer('logs')

</code></pre>
<h3 id="指定要监听的工作日志目录"><a class="header" href="#指定要监听的工作日志目录">指定要监听的工作日志目录</a></h3>
<pre><code class="language-shell">tensorboard --logdir logs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>docker run -itd --name=tensorflow -p 8888:8888 -v D:\docker\tf:/tmp -w /tmp 90338865fe9</p>
<p>Cannot connect:Cannot connect to the Docker daemon at tcp://localhost:2375,Is the docker daemon running?</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>tensorlfow math.log() 是以自然常数<code>e</code>为底 转化为以<code>2</code>为底：</strong><br />
根据对数换底公式：<br />
∵</p>
<p><img src="ML/tensorflow//res/tensorflow/log.png" alt="log2" /></p>
<pre><code>∴ loge(4)/loge(2) = log2(4) = 2
</code></pre>
<p>代码实例：</p>
<pre><code class="language-python">import tensorflow as tf
x = tf.math.log(4.)/tf.math.log(2.)

</code></pre>
<p>Out:</p>
<pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=2.0&gt;
</code></pre>
<p>效果等同于 numpy log2(4)</p>
<pre><code class="language-python">import numpy as np

np.log2(4)
</code></pre>
<p>Out:</p>
<pre><code>2.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="常用函数"><a class="header" href="#常用函数">常用函数</a></h2>
<h3 id="unstack"><a class="header" href="#unstack">unstack</a></h3>
<p>作用：把向量按照维度拆分</p>
<p><img src="ML/tensorflow//res/tensorflow/tensor_1.png" alt="unstack" /></p>
<h3 id="gather"><a class="header" href="#gather">gather</a></h3>
<p>通过索引获取 标量或者向量</p>
<p><img src="ML/tensorflow//res/tensorflow/tensor_2.png" alt="gather" /></p>
<h3 id="gather_nd"><a class="header" href="#gather_nd">gather_nd</a></h3>
<p>可以索引多维</p>
<p><code>argmax</code> 最大值的索引</p>
<pre><code>tf.argmax([1,2,3,4,5,6,7,8])

&lt;tf.Tensor: shape=(), dtype=int64, numpy=7&gt;
</code></pre>
<p><code>softmax</code> 概率最大的索引</p>
<div style="break-before: page; page-break-before: always;"></div><p>张量是一维
二维是矩阵
张量</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><p>官网地址</p>
<blockquote>
<p>https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=CentOS&amp;target_version=8&amp;target_type=runfilelocal</p>
</blockquote>
<pre><code class="language-Shell">wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run
sudo sh cuda_10.2.89_440.33.01_linux.run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python"># %%
import tensorflow as tf
from matplotlib import pyplot as plt

x = tf.zeros([2, 2], dtype=tf.int32)
# 如果要画一个灰度图，那么如下
# 填充一个[2,2]的矩阵为128 也就是灰色值
# [[255,255],
# [255,255]]
z = tf.fill([2, 2], 128)
# 在最后一个维度展开一次，变成[2,2,1]
z = tf.expand_dims(z, axis=-1)
# 在最后一个维度平铺3次
# [2,2,3]
z = tf.tile(z, [1, 1, 3])
plt.imshow(z)
plt.show()

</code></pre>
<p><img src="ML/tensorflow/%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0//res/tensorflow/fill1.png" alt="fil" /></p>
<pre><code class="language-python"># %%
# 画一个红色的图，也很简单
# 三个通道不同颜色 比如洋红色的rgb色值[255,0,255]
r = tf.fill([3, 3], 255)
g = tf.zeros([3, 3],dtype=tf.int32)
b = r
img = tf.stack([r, g, b], axis=-1)
img.shape
# 一个3x3的图片就诞生了
plt.imshow(img)
plt.show()
</code></pre>
<p><img src="ML/tensorflow/%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0//res/tensorflow/fill2.png" alt="fill2" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="经常遇到的问题"><a class="header" href="#经常遇到的问题">经常遇到的问题：</a></h2>
<h3 id="读取本地存储文件权限受限"><a class="header" href="#读取本地存储文件权限受限">读取本地存储文件权限受限</a></h3>
<ul>
<li>open failed: EACCES (Permission denied)</li>
</ul>
<pre><code>//manifest.xml application标签
&lt;application 
    android:requestLegacyExternalStorage="true"
/&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新版本-buildgralde"><a class="header" href="#新版本-buildgralde">新版本 build.gralde</a></h1>
<pre><code class="language-groovy">plugins {
    id "org.springframework.boot" version "2.2.2.RELEASE"
}
</code></pre>
<p>旧版本</p>
<pre><code class="language-groovy">//Using legacy plugin application
buildscript {
  repositories {
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath "org.springframework.boot:spring-boot-gradle-plugin:2.2.2.RELEASE"
  }
}

apply plugin: "org.springframework.boot"
</code></pre>
<h1 id="android-studio-运行-main-方法-报错"><a class="header" href="#android-studio-运行-main-方法-报错">android studio 运行 main 方法 报错</a></h1>
<pre><code>SourceSet with name ‘main‘ not found
</code></pre>
<p>解决：./idea/gradle.xml -&gt; <GradleProjectSettings> 节点下 加入下面这句</p>
<pre><code>&lt;option name="delegatedBuild" value="false" /&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="android//res/android/style.jpg" alt="style" /></p>
<ol>
<li>colorPrimary 应用的主要色调，actionBar默认使用该颜色，Toolbar导航栏的底色</li>
<li>colorPrimaryDark 应用的主要暗色调，statusBarColor默认使用该颜色</li>
<li>statusBarColor 状态栏颜色，默认使用colorPrimaryDark</li>
<li>windowBackground 窗口背景颜色</li>
<li>navigationBarColor 底部栏颜色</li>
<li>colorForeground 应用的前景色，ListView的分割线，switch滑动区默认使用该颜色</li>
<li>colorBackground 应用的背景色，popMenu的背景默认使用该颜色</li>
<li>colorAccent CheckBox，RadioButton，SwitchCompat等一般控件的选中效果默认采用该颜色</li>
<li>colorControlNormal CheckBox，RadioButton，SwitchCompat等默认状态的颜色。</li>
<li>colorControlHighlight 控件按压时的色调</li>
<li>colorControlActivated 控件选中时的颜色，默认使用colorAccent</li>
<li>colorButtonNormal 默认按钮的背景颜色</li>
<li>editTextColor：默认EditView输入框字体的颜色。</li>
<li>textColor Button，textView的文字颜色</li>
<li>textColorPrimaryDisableOnly RadioButton checkbox等控件的文字</li>
<li>textColorPrimary 应用的主要文字颜色，actionBar的标题文字默认使用该颜色</li>
<li>colorSwitchThumbNormal: switch thumbs 默认状态的颜色. (switch off)</li>
</ol>
<h3 id="全局标题栏"><a class="header" href="#全局标题栏">全局标题栏</a></h3>
<ol>
<li>fitsSystemWindows 生效前提：当前页面没有标题栏，并且状态栏或者底部导航栏透明</li>
<li>fitsSystemWindows = true，表示内容区不延伸到状态栏或底部导航栏</li>
<li>fitsSystemWindows = false，表示内容区延伸到状态栏或底部导航栏</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="打开第三方站点需要保留登录状态webview需要接受cookie按照官方提供的api-cookiemanager可以实现"><a class="header" href="#打开第三方站点需要保留登录状态webview需要接受cookie按照官方提供的api-cookiemanager可以实现">打开第三方站点需要保留登录状态，webview需要接受cookie，按照官方提供的API <code>CookieManager</code>可以实现</a></h3>
<pre><code class="language-java">// 1. 在loadurl之前调用接受cookie方法
android.webkit.CookieManager cookieManager = android.webkit.CookieManager.getInstance();
cookieManager.setAcceptThi~rdPartyCookies(this,true);
// 2. onPageFinished 
CookieManager.getInstance().flush();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Classloader 分为三种：
1: pathClassloader: Android 用来加载系统文件 和 应用的主文件
2: DexClassloader: Android 用来加载 jar/apk/dex 文件
3: URLClassloader: 可以加载java的jar包,但是Dalvik 虚拟机不支持这种加载方式</p>
<pre><code class="language-java">public class ProxyActivity extends AppCompatActivity {

    private ProxyActivityInterface pluginObj;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //在这里拿到了真实跳转的activity 拿出来 再去启动真实的activity

        String className = getIntent().getStringExtra("ClassName");

        //通过反射在去启动一个真实的activity 拿到Class对象
        try {
            Class&lt;?&gt; plugClass = getClassLoader().loadClass(className);
            Constructor&lt;?&gt; pluginConstructor = plugClass.getConstructor(new Class[]{});
            //因为插件的activity实现了我们的标准
            pluginObj = (ProxyActivityInterface) pluginConstructor.newInstance(new Object[]{});
            pluginObj.attach(this);//注入上下文
            pluginObj.onCreate(new Bundle());//一定要调用onCreate 
        } catch (Exception e) {
            if (e.getClass().getSimpleName() .equals("ClassCastException")){
                //我这里是直接拿到异常判断的 ，也可的 拿到上面的plugClass对象判断有没有实现我们的接口
                finish();
                Toast.makeText(this,"非法页面",Toast.LENGTH_LONG).show();
                return;
            }
            e.printStackTrace();
        }
    }
]
    //为什么要重写这个呢 因为这个是插件内部startactivity调用的 将真正要开启的activity的类名穿过来
    //然后取出来，启动我们的占坑的activity 在我们真正要启动的赛进去
    @Override
    public void startActivity(Intent intent) {
        String className1=intent.getStringExtra("ClassName");
        Intent intent1 = new Intent(this, ProxyActivity.class);
        intent1.putExtra("ClassName", className1);
        super.startActivity(intent1);
    }

    //重写classLoader
    @Override
    public ClassLoader getClassLoader() {
        return HookManager.getInstance().getClassLoader();
    }

    //重写Resource
    @Override
    public Resources getResources() {
        return HookManager.getInstance().getResource();
    }

    @Override
    protected void onStart() {
        super.onStart();
        pluginObj.onStart();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        pluginObj.onDestroy();
    }

    @Override
    protected void onPause() {
        super.onPause();
        pluginObj.onPause();
    }
}
</code></pre>
<pre><code class="language-java">public class HookManager {
    private static final HookManager ourInstance = new HookManager();
    private Resources resources;
    private DexClassLoader loader;
    public PackageInfo packageInfo;

    public static HookManager getInstance() {
        return ourInstance;
    }

    private HookManager() {
    }


    //用来加载插件
    public void loadPlugin(Activity activity) {
        // 假如这里是从网络获取的插件 我们直接从sd卡获取 然后读取到我们的cache目录
        String pluginName = "plugin.apk";
        File filesDir = activity.getDir("plugin", activity.MODE_PRIVATE);
        String filePath = new File(filesDir, pluginName).getAbsolutePath();
        File file = new File(filePath);
        if (file.exists()) {
            file.delete();
        }
        FileInputStream is = null;
        FileOutputStream os = null;
        //读取的目录
        try {
            is = new FileInputStream(new File(Environment.getExternalStorageDirectory(), pluginName));
            //要输入的目录
            os = new FileOutputStream(filePath);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        try {
            int len = 0;
            byte[] buffer = new byte[1024];
            while ((len = is.read(buffer)) != -1) {
                os.write(buffer, 0, len);
            }
            File f = new File(filePath);
            if (f.exists()) {
                Toast.makeText(activity, "dex overwrite", Toast.LENGTH_SHORT).show();
            }
            loadPathToPlugin(activity);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                os.close();
                is.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }


    }

    private void loadPathToPlugin(Activity activity) {
        File filesDir = activity.getDir("plugin", activity.MODE_PRIVATE);
        String name = "plugin.apk";
        String path = new File(filesDir, name).getAbsolutePath();

        //然后我们开始加载我们的apk 使用DexClassLoader
        File dexOutDir = activity.getDir("dex", activity.MODE_PRIVATE);
        loader = new DexClassLoader(path, dexOutDir.getAbsolutePath(), null, activity.getClassLoader());

        //通过PackAgemanager 来获取插件的第一个activity是哪一个
        PackageManager packageManager = activity.getPackageManager();
        packageInfo = packageManager.getPackageArchiveInfo(path, PackageManager.GET_ACTIVITIES);


        //然后开始加载我们的资源 肯定要使用Resource 但是它是AssetManager创建出来的 就是AssertManager 有一个addAssertPath 这个方法 但是私有的 所有使用反射
        Class&lt;?&gt; assetManagerClass = AssetManager.class;
        try {
            AssetManager assertManagerObj = (AssetManager) assetManagerClass.newInstance();
            Method addAssetPathMethod = assetManagerClass.getMethod("addAssetPath", String.class);
            addAssetPathMethod.setAccessible(true);
            addAssetPathMethod.invoke(assertManagerObj, path);
            //在创建一个Resource
            resources = new Resources(assertManagerObj, activity.getResources().getDisplayMetrics(), activity.getResources().getConfiguration());
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    //对外提供插件的classLoader
    public ClassLoader getClassLoader() {
        return loader;
    }

    //插件中的Resource
    public Resources getResource() {
        return resources;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-android-studio-生成jar包"><a class="header" href="#1-android-studio-生成jar包">1. android studio 生成jar包</a></h3>
<pre><code class="language-groovy">task makeJar(type: Copy) {
    delete 'build/libs/mylibrary.jar' //删除已经存在的jar包
    from('build/intermediates/compile_library_classes_jar/
    debug/') //从该目录下加载要打包的文件,这里实际上是编译后的classes.jar文件的目录
    into('build/libs/')//jar包的保存目录
    include('classes.jar')//设置过滤，只打包classes文件
    rename('classes.jar', 'dynamic_temp.jar')//重命名，mylibrary.jar 根据自己的需求设置
}
makeJar.dependsOn(build)
</code></pre>
<h3 id="1-找到android-sdk-以下路径配置到环境变量目的是为了使用-dx-命令"><a class="header" href="#1-找到android-sdk-以下路径配置到环境变量目的是为了使用-dx-命令">1. 找到android sdk ，以下路径配置到环境变量，目的是为了使用 dx 命令</a></h3>
<p><code>D:\WorkRome\android\Sdk\build-tools\30.0.3</code></p>
<h3 id="2--一键生成-jar"><a class="header" href="#2--一键生成-jar">2.  一键生成 jar</a></h3>
<ul>
<li>--output 最终输出jar包</li>
<li>temp.jar 目标jar<br />
<code>dx --dex --output=object.jar temp.jar</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="获取app签名信息"><a class="header" href="#获取app签名信息">获取APP签名信息</a></h3>
<pre><code class="language-java">public static String getSingInfo(Context context) {
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);
        Signature[] signs = packageInfo.signatures;
        Signature sign = signs[0];
        byte[] signByteArray = sign.toByteArray();

        return md5(signByteArray);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public static String md5(byte[] data){
    if(data == null || data.length == 0){
        return null;
    }
    StringBuffer hexString = new StringBuffer();
    try {
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(data);
        byte[] hash = md.digest();
        for (int i = 0; i &lt; hash.length; i++) {
            if ((0xff &amp; hash[i]) &lt; 0x10) {
                hexString.append("0" + Integer.toHexString((0xFF &amp; hash[i])));
            } else {
                hexString.append(Integer.toHexString(0xFF &amp; hash[i]));
            }
        }
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return hexString.toString().toUpperCase();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-java">RoleManager roleManager = getSystemService(RoleManager.class);
Intent intent = roleManager.createRequestRoleIntent(RoleManager.ROLE_SMS);
startActivityForResult(intent,666);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-gradle-task-assembledebug"><a class="header" href="#running-gradle-task-assembledebug">Running Gradle task 'assembleDebug'...</a></h1>
<p>卡在 Running Gradle task 'assembleDebug'... 不动</p>
<p>解决方案：</p>
<ol>
<li>检查 ./gradle 是否下载成功</li>
<li>检查 <code>gradle</code> 默认代理是否正常<br />
<code>gradle</code> 配置文件默认在 <code>~/.gradle/gradle.properties</code>
注释掉下面几行代码即可：</li>
</ol>
<pre><code class="language-yaml"># Sun Jul 05 10:38:23 CST 2020
# systemProp.http.proxyHost=127.0.0.1
# systemProp.http.proxyPort=50030
# systemProp.https.proxyHost=127.0.0.1
# systemProp.https.proxyPort=50030
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>项目打包命名方式：</li>
</ol>
<ul>
<li>apk 命名： 项目名+打包日期+版本号</li>
<li>version_name 命名：version_name + <code>es</code></li>
<li>es:环境变量（alpha or release） 分别对应 测试环境和生产环境，后续根据项目变化进一步扩展   <code>alpha beta release</code></li>
</ul>
<ol start="2">
<li>发布测试版本，统一通过蒲公英平台发布</li>
<li>正式版本每一个版本统一交由测试管理并记录</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注解说明"><a class="header" href="#注解说明">注解说明</a></h1>
<h2 id="module-告知hilt如何提供被注解类的实例"><a class="header" href="#module-告知hilt如何提供被注解类的实例">@Module ：告知hilt如何提供被注解类的实例</a></h2>
<h2 id="installincomponentclass--告知hilt模块用在哪个类中"><a class="header" href="#installincomponentclass--告知hilt模块用在哪个类中">@InstallIn(Component::class) : 告知hilt模块用在哪个类中</a></h2>
<h2 id="binds--注入函数接口无法通过构造函数实例化接口添加这个注解告知hilt"><a class="header" href="#binds--注入函数接口无法通过构造函数实例化接口添加这个注解告知hilt">@Binds : 注入函数（接口无法通过构造函数实例化）,接口添加这个注解告知hilt</a></h2>
<ol>
<li>根据函数返回类型提供哪个接口实例，</li>
<li>根据函数参数提供对应实例</li>
</ol>
<h2>@Provides: 注入函数，类不能被构造函数实例化（来自第三方库或必须通过构造函数创建实例），只能通过提供函数的方
式来获取一个实例化结果</h2>
<p>hilt会从带注解的函数得到信息：</p>
<ol>
<li>根据函数返回类型提供对应实例</li>
<li>根据函数参数提供对应实例</li>
<li>函数主体得到需要的依赖项实例</li>
</ol>
<h2 id="entrypoint注入接口为hilt不支持的类型注解"><a class="header" href="#entrypoint注入接口为hilt不支持的类型注解">@EntryPoint：注入接口,为hilt不支持的类型注解</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>#workmanager 轻量级后台任务管理</p>
<h2 id="worker--任务体"><a class="header" href="#worker--任务体">worker  任务体</a></h2>
<pre><code class="language-kotlin">class DatabaseWork(context: Context, workerParams: WorkerParameters) : Worker(context,workerParams) {
    companion object{

    }

    override fun doWork(): Result {
        Log.e("cgq","start")
        val data = Data.Builder().putString("cgq","woker-data").build()
        setProgressAsync(data)
        return Result.success()
    }

}

</code></pre>
<h2 id="workerrequest--执行任务"><a class="header" href="#workerrequest--执行任务">workerRequest  执行任务</a></h2>
<h2 id="workermanager-enqueue-添加任务"><a class="header" href="#workermanager-enqueue-添加任务">WorkerManager enqueue 添加任务</a></h2>
<pre><code class="language-kotlin">    val workRequest: WorkRequest = OneTimeWorkRequestBuilder&lt;DatabaseWork&gt;().build()
    //状态回调，添加一个任务观察者
    WorkManager.getInstance(requireActivity()).getWorkInfoByIdLiveData(workRequest.id).observe(requireActivity()){
        when (it.state) {
            WorkInfo.State.RUNNING -&gt; Log.e("cgq", "running======")
            WorkInfo.State.CANCELLED -&gt; Log.e("cgq", "cancelled======")
            WorkInfo.State.SUCCEEDED -&gt;Log.e("cgq", "success======")
            else -&gt; Log.e("cgq", "都不对")
        }
    }
    WorkManager.getInstance(requireContext()).enqueue(workRequest)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p><code>android jetpack</code>框架组件</p>
<p><code>databinding</code>; 数据绑定库</p>
<p><code>livedata</code>: 数据观察类，</p>
<p><code>Room</code>: 数据库</p>
<p><code>Viewmodel</code>: 绑定activity或者fragment生命周期，</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="注解"><a class="header" href="#注解">注解</a></h3>
<p>注解就是一种特殊的注释/解释，分两种情况:<br />
1.在代码编写阶段，编译器会看到的，并且明白是什么意思；<br />
2. 在运行阶段，反射机制，动态代理等应用。</p>
<h3 id="元注解"><a class="header" href="#元注解">元注解</a></h3>
<p>给注解加一个注释/ 注解上的注解；比如某个注解的作用域通过元注解告诉编译器，还有注解的生命周期等。<br />
@Target<br />
ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上<br />
ElementType.FIELD：允许作用在属性字段上<br />
ElementType.METHOD：允许作用在方法上<br />
ElementType.PARAMETER：允许作用在方法参数上<br />
ElementType.CONSTRUCTOR：允许作用在构造器上<br />
ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上<br />
ElementType.ANNOTATION_TYPE：允许作用在注解上<br />
ElementType.PACKAGE：允许作用在包上</p>
<div style="break-before: page; page-break-before: always;"></div><p>1.修改textview的约束条件</p>
<pre><code>app:layout_constraintStart_toEndOf="@+id/textView3"
改为
app:layout_constraintLeft_toRightOf="@+id/textView3"
</code></pre>
<p>注意 其他的start end也都改为left right </p>
<p>2.其他属性搭配：</p>
<pre><code>android:layout_height="wrap_content"
搭配：app:layout_constrainedWidth="true"

android:layout_height="wrap_content"
搭配：app:layout_constrainedHeight="false"（不写默认即false）

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="区间使用"><a class="header" href="#区间使用">区间使用</a></h3>
<p><code>1..10</code>: 1-10 区间内的数字打印（ 包含10）</p>
<pre><code class="language-Kotlin">fun main() {
    for(i in 1 .. 10){
        print(i)
    }
}
</code></pre>
<pre><code class="language-Kotlin">//until 不包含10   step:指定步长，每隔 两个输出一个
for(i in 1 until 10 step 2){
    print(i)
}
</code></pre>
<p><code>10 downTo 1</code>:倒着输出区间 10-1</p>
<pre><code class="language-Kotlin">for(i in 10 downTo 1 step 1){
    print(i)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>双冒号 :: 返回函数体</p>
<pre><code class="language-kotlin">class Apply(){
    var name = "cao"
    var age = 12

    fun print(){
        println("name is $name,age is $age")
    }
    
}

fun main() {
    var app = Apply()
    app.apply {
        name = "zhang"
        age = 1
    }

    val print = app::print
    print()
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="常用sql"><a class="header" href="#常用sql">常用sql</a></h3>
<p>删除字段</p>
<blockquote>
<p>alter table users drop column col_name;</p>
</blockquote>
<p>修改字段数据类型</p>
<blockquote>
<p>alter table users alter column col_name new_type;</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-配置"><a class="header" href="#mysql-配置">mysql 配置</a></h1>
<h3 id="首先查看centos是否已经安装了mysql源"><a class="header" href="#首先查看centos是否已经安装了mysql源">首先查看centos是否已经安装了mysql源</a></h3>
<pre><code>yum list installed mysql*
如果有就删除
yum remove mysql-community-*

</code></pre>
<h3 id="安装mysql源"><a class="header" href="#安装mysql源">安装mysql源</a></h3>
<pre><code class="language-数据库官网地址">https://dev.mysql.com/downloads/repo/yum/
</code></pre>
<pre><code>wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
</code></pre>
<h3 id="安装mysql"><a class="header" href="#安装mysql">安装mysql</a></h3>
<pre><code>yum -y install mysql57-community-release-el7-10.noarch.rpm
</code></pre>
<h3 id="查看是否已经安装了数据库源"><a class="header" href="#查看是否已经安装了数据库源">查看是否已经安装了数据库源</a></h3>
<pre><code>yum repolist all | grep mysql
</code></pre>
<h3 id="查看数据库源"><a class="header" href="#查看数据库源">查看数据库源</a></h3>
<pre><code>/etc/yum.repos.d/mysql-community.repo
修改源可用 mysql80  enable = 1
</code></pre>
<h3 id="安装数据库服务"><a class="header" href="#安装数据库服务">安装数据库服务</a></h3>
<pre><code>yum install mysql-server
</code></pre>
<h3 id="启动mysql"><a class="header" href="#启动mysql">启动mysql</a></h3>
<pre><code>systemctl start mysqld.service
</code></pre>
<h3 id="查看状态"><a class="header" href="#查看状态">查看状态</a></h3>
<pre><code>systemctl status mysqld.service
</code></pre>
<h3 id="查看初始密码"><a class="header" href="#查看初始密码">查看初始密码</a></h3>
<pre><code>grep "password" /var/log/mysqld.log
</code></pre>
<h3 id="修改密码"><a class="header" href="#修改密码">修改密码</a></h3>
<pre><code>mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';

mysql&gt; ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'
</code></pre>
<p><strong>注意:密码设置必须要大小写字母数字和特殊符号（,/';:等）,不然不能配置成功</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p>修改配置文件，无密码登录
编辑文件：</p>
<pre><code>/etc/mysql/mysq.conf.d/mysqld.cnf

</code></pre>
<p>加入<code>skip-grant-tables</code>
跳过密码登录；</p>
<p>重启mysql服务</p>
<pre><code>systemctl restart mysql.service
</code></pre>
<p>进入mysql</p>
<pre><code># mysql;
# use mysql;
# 更新密码为空
# UPDATE user SET authentication_string='' WHERE User='root' AND Host ='localhost';

# flush privileges;
退出

</code></pre>
<p>注释掉<code>skip-grant-tables</code></p>
<h3 id="重启mysql无密码登录"><a class="header" href="#重启mysql无密码登录">重启mysql，无密码登录</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="开启mysql的远程访问-两种方式"><a class="header" href="#开启mysql的远程访问-两种方式">开启mysql的远程访问 两种方式</a></h3>
<ul>
<li>方式1</li>
</ul>
<pre><code class="language-shell">grant all privileges on *.* to 'root'@'192.168.1.145' identified by '123456' with grant option;
</code></pre>
<pre><code class="language-shell">flush privileges;
</code></pre>
<ul>
<li>方式2</li>
</ul>
<pre><code class="language-shell">use mysql;
update user set host = '%' where user = 'root';
</code></pre>
<p><strong>更细权限之后，一定要刷新一下，否则不会生效</strong></p>
<pre><code class="language-shell">flush privileges;
</code></pre>
<ul>
<li>方式3</li>
</ul>
<pre><code class="language-shell">  此处为设置root用户远程
  mysql -uroot -p  #输入密码

  use mysql;

  update user set host = '%' where user = 'root';

  select host, user from user;

  flush privileges;
</code></pre>
<h3 id="去掉配置文件中bind-address"><a class="header" href="#去掉配置文件中bind-address">去掉配置文件中<code>bind-address</code></a></h3>
<pre><code class="language-shell">bind-address          = 127.0.0.1
</code></pre>
<pre><code class="language-shell"># bind-address          = 127.0.0.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>容器运行 <code>postgres</code></p>
<pre><code class="language-shell">docker run -itd --name=pg -p 5678:5432 -v /home/zouni/postgres:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456  -e ALLOW_IP_RANGE=0.0.0.0/0 --restart always POSTGRES_USER='postgres' postgres

docker run -itd --name pg --restart always -e POSTGRES_USER='postgres' -e POSTGRES_PASSWORD=123456 -e ALLOW_IP_RANGE=0.0.0.0/0 -v /home/zouni/postgres:/var/lib/postgresql -p 5432:5432  postgres

docker run -itd --name mpg --restart always -e TZ=PRC -e POSTGRES_USER='root'  -e POSTGRES_PASSWORD='123456' -e POSTGRES_DB='facepark' -e ALLOW_IP_RANGE=0.0.0.0/0 -v /home/zouni/postgres/data:/var/lib/postgresql/data -p 5432:5432  postgres
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="表字段使用geography报错"><a class="header" href="#表字段使用geography报错">表字段使用geography报错</a></h3>
<p>因为要使用地理坐标来表示附近用户，需要空间坐标转换</p>
<blockquote>
<p>type "geography" does not exist
解决方法：
CREATE EXTENSION Postgis;</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="时区设置"><a class="header" href="#时区设置">时区设置</a></h3>
<ol>
<li>
<p>第一种方法
<img src="database/postgresql//res/postgresql/timezone1.png" alt="时区设置" /></p>
</li>
<li>
<p>如果不好使，再换第二种方法：</p>
</li>
</ol>
<pre><code>serverTimezone    Asia/Shanghai
</code></pre>
<p><img src="database/postgresql//res/postgresql/timezone.png" alt="时区设置" /></p>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>相当与mysql的show databases;</li>
</ol>
<pre><code class="language-sql">select datname from pg_database;    
</code></pre>
<ol start="2">
<li>相当于mysql的show tables;</li>
</ol>
<pre><code class="language-sql">SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';   
</code></pre>
<p>public 是默认的schema的名字</p>
<ol start="3">
<li>相当与mysql的describe table_name;</li>
</ol>
<pre><code class="language-sql">SELECT column_name FROM information_schema.columns WHERE table_name ='table_name';  
</code></pre>
<p>'table_name'是要查询的表的名字</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-下载配置环境变量"><a class="header" href="#1-下载配置环境变量">1. 下载&amp;配置环境变量</a></h3>
<h3 id="2-生成默认配置文件"><a class="header" href="#2-生成默认配置文件">2. 生成默认配置文件</a></h3>
<pre><code class="language-shell">containerd config default &gt; d:/path
</code></pre>
<h3 id="3-启动"><a class="header" href="#3-启动">3. 启动</a></h3>
<pre><code class="language-shell">containerd
</code></pre>
<h3 id="4-查看版本"><a class="header" href="#4-查看版本">4. 查看版本</a></h3>
<pre><code class="language-shell">ctr version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dial-unix-runcontainerdcontainerdsock-connect-permission-denied"><a class="header" href="#dial-unix-runcontainerdcontainerdsock-connect-permission-denied">dial unix /run/containerd/containerd.sock: connect: permission denied"</a></h3>
<p>正常修改权限就可以了，开发电脑用的wsl2,goland-&gt; run target-&gt; wsl，这种方式进行开发调试的。</p>
<ul>
<li>解决方法： 修改wsl 默认登录用户为root</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><pre><code class="language-yaml">mysql:
    image: mysql:8.0
    container_name: mysql-container
    restart: always
    environment:
      # 设置 MySQL 根用户密码
      MYSQL_ROOT_PASSWORD: your_root_password
      # 可选：创建一个额外的数据库
      MYSQL_DATABASE: your_database_name
      # 可选：创建一个额外的用户并授权
      MYSQL_USER: your_username
      MYSQL_PASSWORD: your_user_password
    ports:
      # 将容器的 3306 端口映射到主机的 3306 端口
      - "3306:3306"
    volumes:
      # 数据卷挂载，确保数据持久化
      - mysql-data:/var/lib/mysql
      # 可选：挂载自定义配置文件
      # - ./my.cnf:/etc/mysql/conf.d/my.cnf
    networks:
      - mysql-network
    # 可选：设置 MySQL 字符集
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-windows-安装步骤"><a class="header" href="#1-windows-安装步骤">1. Windows 安装步骤</a></h2>
<ol>
<li>
<p>安装：
官网下载 <code>https://hub.docker.com/</code>对应版本</p>
</li>
<li>
<p>设置：</p>
<ul>
<li>修改 <code>registry-mirrors</code> 镜像地址
<ul>
<li>https://reg-mirror.qiniu.com</li>
<li>http://hub-mirror.c.163.com/</li>
<li>https://registry.docker-cn.com</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>{
  "registry-mirrors":[
      "https://reg-mirror.qiniu.com",
      "http://hub-mirror.c.163.com/",
      "https://registry.docker-cn.com"
  ],
  "builder": {
    "gc": {
      "defaultKeepStorage": "20GB",
      "enabled": true
    }
  },
  "experimental": false,
  "features": {
    "buildkit": true
  }
}
</code></pre>
<p><img src="container/docker//res/docker/docker_1.png" alt="docker" /></p>
<h2 id="2-centos-安装步骤"><a class="header" href="#2-centos-安装步骤">2. CentOS 安装步骤</a></h2>
<h3 id="官网-1"><a class="header" href="#官网-1">官网</a></h3>
<p>https://docs.docker.com/engine/install/centos/#prerequisites
先卸载旧版本</p>
<pre><code>sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
</code></pre>
<p>安装yum-utils软件包（提供yum-config-manager 实用程序）并设置稳定的存储库。</p>
<pre><code>sudo yum install -y yum-utils

sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>开始安装引擎</p>
<pre><code>sudo yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>启动</p>
<pre><code>sudo systemctl start docker
</code></pre>
<p>测试是否正常</p>
<pre><code>sudo docker run hello-world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="镜像操作"><a class="header" href="#镜像操作">镜像操作：</a></h3>
<ol>
<li>从仓库搜索镜像：<code>docker search image-name</code><br />
搜索结果过滤:</li>
</ol>
<pre><code class="language-Shell">	#是否是官方提供：  
	docker search --filter "is-official=true" image_name
	# 是否是自动化构建：  
	docker search --filter "is-automated=true" image_name
	# 大于多少个`star`  
	docker search --filter stars=3 image_name
</code></pre>
<pre><code>下载镜像：
</code></pre>
<pre><code class="language-Shell">docker pull image_name
</code></pre>
<ol start="2">
<li>本地镜像的查看：</li>
</ol>
<pre><code class="language-Shell">docker images
</code></pre>
<ol start="3">
<li>删除：</li>
</ol>
<pre><code class="language-Shell">docker rmi image_name
</code></pre>
<ol start="4">
<li>修改镜像名字：</li>
</ol>
<pre><code class="language-Shell">docker tag images_id 要推送的主机地址/镜像名：版本号
</code></pre>
<ol start="5">
<li>push到docker仓库</li>
</ol>
<pre><code class="language-Shell"># 前提是已经在docker服务注册并创建了仓库
docker push 刚刚修改的镜像名字（要推送的主机地址/镜像名：版本号）这一长串
</code></pre>
<h3 id="容器基本操作"><a class="header" href="#容器基本操作">容器基本操作：</a></h3>
<ol>
<li>查看容器：</li>
</ol>
<pre><code class="language-shell">docker ps
</code></pre>
<ol start="2">
<li>创建容器:</li>
</ol>
<pre><code class="language-Shell">docker run -itd --name=container_name images_name
</code></pre>
<blockquote>
<p><strong>-i</strong>: 以交互模式运行容器;<br />
<strong>-d</strong>: 后台运行;<br />
<strong>-t</strong>: 为容器重新分配一个伪输入终端;<br />
<strong>--name</strong>: 容器名字;</p>
</blockquote>
<ol start="3">
<li>查看所有容器:</li>
</ol>
<pre><code class="language-Shell">docker ps -a
</code></pre>
<ol start="4">
<li>停止容器：</li>
</ol>
<pre><code class="language-Shell">docker stop container_name
</code></pre>
<ol start="5">
<li>重启容器:</li>
</ol>
<pre><code class="language-Shell">docker restart container_name
</code></pre>
<ol start="6">
<li>删除容器: # 删除之前要先停止</li>
</ol>
<pre><code class="language-Shell">docker rm container_name
</code></pre>
<h3 id="容器修改与保存"><a class="header" href="#容器修改与保存">容器修改与保存</a></h3>
<ol>
<li>进入容器</li>
</ol>
<pre><code class="language-Shell">docker exec -it container_name /bin/bash
</code></pre>
<ol start="2">
<li>修改容器提交:</li>
</ol>
<pre><code class="language-Shell">docker commit -a "author" -m "modify" container_name/container_id new_image_name:tag_name
</code></pre>
<h3 id="端口映射"><a class="header" href="#端口映射">端口映射</a></h3>
<pre><code class="language-Shell">docker run -itd --name=container_name -p 8888:80 images_name
</code></pre>
<blockquote>
<p><code>-p</code> 8888 指的是 宿主机端口-&gt;端口映射到容器80端口  访问：127.0.0.1:8888</p>
<p><code>注意:</code> 命令顺序不能反，<code>image_name</code> 在最后</p>
</blockquote>
<p><img src="container/docker//res/docker/docker_2.png" alt="oper" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>创建容器：</p>
<pre><code>docker run -itd --name=container_name images_name
</code></pre>
<p>常用参数说明：</p>
<p><code>-p 88:80</code><br />
端口映射：</p>
<pre><code>88:宿主机端口  
80:容器端口
docker run -itd --name=ct_name -p 88:80 img_name
</code></pre>
<p><code>-v</code> : 文件挂载(宿主机文件目录：容器文件目录)</p>
<p><code>-itd</code></p>
<blockquote>
<p><strong>-i</strong>: 以交互模式运行容器;<br />
<strong>-d</strong>: 后台运行;<br />
<strong>-t</strong>: 为容器重新分配一个伪输入终端;</p>
</blockquote>
<p><code>--name</code></p>
<blockquote>
<p><strong>--name</strong>: 容器名字;</p>
</blockquote>
<p>``</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="启动失败"><a class="header" href="#启动失败">启动失败</a></h2>
<p>查看日志</p>
<pre><code>docker logs -f -t --tail 20 nginx
</code></pre>
<h2 id="操作无权限"><a class="header" href="#操作无权限">操作无权限</a></h2>
<blockquote>
<p>aa-remove-unknown</p>
</blockquote>
<h2 id="修改容器端口映射"><a class="header" href="#修改容器端口映射">修改容器端口映射</a></h2>
<ol>
<li>编辑容器配置文件 <code>/var/lib/docker/containers/{containersid}/hostconfig.json</code></li>
</ol>
<pre><code class="language-shell">root@zouni:/var/lib/docker/containers/572a9b8574dcc5077c7c4ec139e4e044e80696f78d1e658d0e735e183944cd28# ls
572a9b8574dcc5077c7c4ec139e4e044e80696f78d1e658d0e735e183944cd28-json.log  hostconfig.json  mounts
checkpoints                                                                hostname         resolv.conf
config.v2.json                                                             hosts            resolv.conf.hash
</code></pre>
<p>！！先关掉docker,然后修改其中绑定的端口,重启docker就可以了</p>
<blockquote>
<p>,"PortBindings":{"5432/tcp":[{"HostIp":"","HostPort":"8099"}]}</p>
</blockquote>
<h2 id="端口映射本地可以访问远程不能访问"><a class="header" href="#端口映射本地可以访问远程不能访问">端口映射，本地可以访问，远程不能访问！！！</a></h2>
<ol>
<li>检查防火墙</li>
</ol>
<pre><code class="language-shell">#查看防火墙状态，运行中
root@zouni:/# firewall-cmd --state
running
#查看放开的端口，开放这几个端口，8088为放开
root@zouni:/# firewall-cmd --list-all
You're performing an operation over default zone ('public'),
but your connections/interfaces are in zone 'docker' (see --get-active-zones)
You most likely need to use --zone=docker option.

public
  target: default
  icmp-block-inversion: no
  interfaces:
  sources:
  services: dhcpv6-client ssh
  ports: 8088/tcp 8099/tcp 5432/tcp 443/tcp  # 开放的端口列表
  protocols:
  forward: yes
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks:
  rich rules:

</code></pre>
<ol start="2">
<li>检查ip转发</li>
</ol>
<pre><code class="language-shell">root@zouni:/# sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1   # 正常 = 1

</code></pre>
<ol start="3">
<li>检查docker 网卡设置</li>
</ol>
<pre><code>docker容器启动后外部无法连接
		1第一种
			sudo service docker stop
			sudo ip link set dev docker0 down            %关闭docker虚拟网卡
			sudo brctl delbr docker0
			sudo iptables -t nat -F POSTROUTING
			sudo brctl addbr docker0
			sudo ip addr add 172.16.10.1/24 dev docker0
			sudo ip link set dev docker0 up 				%开启docker虚拟网卡
			systemctl  restart  docker
			brctl命令需要安装： yum install -y bridge-utils
			
		2.第二种
			systemctl stop docker
			ifconfig docker0 down
			brctl delbr docker0
			systemctl start docker
# 原文链接：https://blog.csdn.net/CSDN877425287/article/details/106909673
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="文件挂载"><a class="header" href="#文件挂载">文件挂载</a></h3>
<blockquote>
<p>docker run -itd --name=small_nginx -p 8888:80 -v d:/index.html:/usr/share/nginx/html/index.html small/nginx</p>
</blockquote>
<ul>
<li><strong>-v</strong> 表示： 宿主机文件路径：容器文件路径</li>
<li><strong>-p</strong> 表示: 宿主机ip:容器ip</li>
</ul>
<p>这里修改了nginx默认启动页面关联到本地</p>
<p><img src="container/docker//res/docker/docker_4.png" alt="filemount" /></p>
<h3 id="文件目录挂载"><a class="header" href="#文件目录挂载">文件目录挂载</a></h3>
<blockquote>
<p>docker run -itd --name=small_mysql -p 33066:3306 -v d:/docker/mysql/:/var/lib/mysql/ -e MYSQL_ROOT_PASSWORD=123456 mysql</p>
</blockquote>
<ul>
<li><strong>-e</strong> 表示：向容器内传参，ex:设定数据库密码：<code>MYSQL_ROOT_PASSWORD=123456</code></li>
</ul>
<p>docker run -itd --name=flask_mysql -p 33066:3306 -v /var/lib/mysql:/var/lib/mysql/ -e MYSQL_ROOT_PASSWORD=123456 mysql</p>
<div style="break-before: page; page-break-before: always;"></div><p><code>docker</code>打开设置<br />
Expose daemon on tcp://localhost:2375 without TLS<br />
<img src="container/docker//res/docker/pycharm_1.png" alt="docker" />
设置连接docker
<img src="container/docker//res/docker/pycharm_2.png" alt="docker1" /></p>
<p>显示<code>Connection successfull</code> 表示连接成功了</p>
<p>接下来配置<code>python</code> 解释器
<img src="container/docker//res/docker/pycharm_3.png" alt="pycharm" />
如果已经创建了容器，就会自动加载</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="下载镜像"><a class="header" href="#下载镜像">下载镜像</a></h3>
<pre><code># 官方提供的mysql镜像
docker pull mysql
</code></pre>
<h3 id="创建容器"><a class="header" href="#创建容器">创建容器</a></h3>
<pre><code>docker run -itd --name=mysql -p 3307:3306 -v ./data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<ul>
<li>-p 指定3306端口映射宿主机</li>
<li>-v 数据库文件映射到宿主机</li>
<li>-e 指定参数 ‘MYSQL_ROOT_PASSWORD’ 设置数据库密码</li>
</ul>
<h3 id="进入容器"><a class="header" href="#进入容器">进入容器</a></h3>
<pre><code>docker exec -it mysql_wxc bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="容器互联"><a class="header" href="#容器互联">容器互联</a></h3>
<pre><code class="language-shell">docker run -itd --name=small_nginx --link container_name:alias -v path:local_path image_name
</code></pre>
<ul>
<li><strong>--link</strong> 表示：被挂载容器名：别名</li>
</ul>
<pre><code>docker run -itd --name=flask_t -p 81:80 --link flask_mysql:flask_mysql -v /root/small/mysql/:/var/lib/mysql flask:1.2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="搭建本地仓库"><a class="header" href="#搭建本地仓库">搭建本地仓库</a></h2>
<h3 id="搜索-官方仓库"><a class="header" href="#搜索-官方仓库">搜索 官方仓库</a></h3>
<pre><code class="language-shell">docker search registry
</code></pre>
<h3 id="下载仓库"><a class="header" href="#下载仓库">下载仓库</a></h3>
<pre><code class="language-shell">docker pull registry
</code></pre>
<h3 id="创建容器-1"><a class="header" href="#创建容器-1">创建容器</a></h3>
<pre><code>docker run -d -p 5000:5000 --restart=always --privileged=true --name=registry-small -v d:/docker/registry:/var/lib/registry registry
</code></pre>
<h3 id="修改镜像准备推送-到仓库容器"><a class="header" href="#修改镜像准备推送-到仓库容器">修改镜像，准备推送 到仓库容器</a></h3>
<pre><code>docker tag image_id registry_name:port/images_name
</code></pre>
<h3 id="修改hosts-增加-域名"><a class="header" href="#修改hosts-增加-域名">修改hosts 增加 域名</a></h3>
<pre><code>127.0.0.1 registry_name
</code></pre>
<h3 id="推送镜像到私有仓库"><a class="header" href="#推送镜像到私有仓库">推送镜像到私有仓库</a></h3>
<pre><code class="language-shell">docker push registry_name:port/images_name
</code></pre>
<h3 id="查看镜像是否推送成功"><a class="header" href="#查看镜像是否推送成功">查看镜像是否推送成功</a></h3>
<p><code>windows</code> 浏览器 可以直接打开</p>
<blockquote>
<p>http://127.0.0.1:5000/v2/_catalog</p>
</blockquote>
<p><img src="container/docker//res/docker/docker_registry_1.png" alt="registry_catalog" /></p>
<p>查看版本号</p>
<blockquote>
<p>http://127.0.0.1:5000/v2/alpine/tags/list</p>
</blockquote>
<p><img src="container/docker//res/docker/docker_registry_2.png" alt="registry_version" /></p>
<p><code>linux</code> 查看同样的方法 用命令查看</p>
<pre><code class="language-Shell">curl -X GET http://127.0.0.1:5000/v2/_catalog
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装uwsgi--报各种-致命错误"><a class="header" href="#安装uwsgi--报各种-致命错误">安装uwsgi  报各种 致命错误</a></h3>
<ol>
<li>缺少c编译器</li>
</ol>
<pre><code class="language-Shell">File "uwsgiconfig.py", line 742, in __init__
    raise Exception("you need a C compiler to build uWSGI")
Exception: you need a C compiler to build uWSGI
</code></pre>
<p>首次安装软件，需要先更新源。</p>
<pre><code class="language-Shell">apk update
apk add gcc
</code></pre>
<ol start="2">
<li>执行<code>pip3 install uWSGI</code></li>
</ol>
<pre><code class="language-python">In file included from core/socket.c:1:0:
./uwsgi.h:165:19: fatal error: stdio.h: No such file or directory
compilation terminated.
In file included from core/logging.c:2:0:
./uwsgi.h:165:19: fatal error: stdio.h: No such file or directory
compilation terminated.
In file included from core/utils.c:1:0:
./uwsgi.h:165:19: fatal error: stdio.h: No such file or directory
compilation terminated.
In file included from core/protocol.c:1:0:
./uwsgi.h:165:19: fatal error: stdio.h: No such file or directory
compilation terminated.
</code></pre>
<p>缺乏C语言的标准库</p>
<pre><code class="language-Shell">apk add libc-dev
</code></pre>
<ol start="3">
<li>继续安装 <code>pip3 install uwsgi</code></li>
</ol>
<pre><code class="language-python">In file included from core/logging.c:2:0:
    ./uwsgi.h:238:26: fatal error: linux/limits.h: No such file or directory
    compilation terminated.
    In file included from core/utils.c:1:0:
    ./uwsgi.h:238:26: fatal error: linux/limits.h: No such file or directory
    compilation terminated.
    In file included from core/protocol.c:1:0:
    ./uwsgi.h:238:26: fatal error: linux/limits.h: No such file or directory
    compilation terminated.
    In file included from core/socket.c:1:0:
    ./uwsgi.h:238:26: fatal error: linux/limits.h: No such file or directory
    compilation terminated.
</code></pre>
<p>缺乏Linux相关的头文件</p>
<pre><code class="language-Shell">apk add linux-headers
</code></pre>
<ol start="4">
<li>由于uWSGI功能众多，所以，使用的参数不同，需要的功能也会有差异。
在使用--static-map等参数时，可能会有额外的编译依赖，否则会有运行时报错。</li>
</ol>
<pre><code>!!! no internal routing support, rebuild with pcre support !!!
</code></pre>
<p>PCRE（Perl Compatible Regular Expressions）是一个Perl库，包括 perl 兼容的正则表达式库。
编译依赖为pcre-dev，运行依赖为pcre。</p>
<ol start="5">
<li>运行时，某些功能需要访问/etc/mime.types文件。</li>
</ol>
<pre><code>!!! no /etc/mime.types file found !!!
</code></pre>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。 是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</p>
<p>这个东西对应的Alpine库是mailcap。</p>
<blockquote>
<p>最终通过以下命令安装成功</p>
</blockquote>
<pre><code class="language-Shell">RUN apk update &amp;&amp; apk add \
        libuuid \
        pcre \
        mailcap \
        gcc \
        libc-dev \
        linux-headers \
        pcre-dev \
    &amp;&amp; pip install --no-cache-dir uWSGI&gt;=2.0.15 \
    &amp;&amp; apk del \
        gcc \
        libc-dev \
        linux-headers \
    &amp;&amp; rm -rf /tmp/*
</code></pre>
<h3 id="虽然成功了但是由于有部分python库无法在alpine上使用比如opencv-python-原因是alpine的libc不是gnu的而是musl-libc-详见cannot-install-opencv-contrib-python-from-alpine-linux--issue-75--skvarkopencv-python"><a class="header" href="#虽然成功了但是由于有部分python库无法在alpine上使用比如opencv-python-原因是alpine的libc不是gnu的而是musl-libc-详见cannot-install-opencv-contrib-python-from-alpine-linux--issue-75--skvarkopencv-python">虽然成功了，但是由于有部分Python库，无法在Alpine上使用，比如opencv-python。 原因是，Alpine的libc不是GNU的，而是musl libc。 详见：Cannot install opencv-contrib-python from Alpine Linux · Issue #75 · skvark/opencv-python。</a></h3>
<blockquote>
<p>I completely forgot that Alpine Linux is based on musl libc and not on GNU libc and thus it's not a GNU/Linux distribution. Manylinux supports only GNU/Linux.</p>
</blockquote>
<h1 id="所以放弃使用alpine"><a class="header" href="#所以放弃使用alpine">所以放弃使用<code>alpine</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><p><code>alpine</code> 启动没有<code>/bin/bash</code>
docker</p>
<p><code>alpine</code>软件安装</p>
<pre><code>apk add python3
</code></pre>
<p>修改成aliyun源</p>
<blockquote>
<ol>
<li><code>vi /etc/apk/repositories</code></li>
<li>https://mirrors.aliyun.com/alpine/</li>
</ol>
</blockquote>
<p>or</p>
<p><strong>sed</strong> 命令修改 仓库文件</p>
<pre><code>  sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories
</code></pre>
<pre><code>  阿里云镜像源地址：
  https://developer.aliyun.com/mirror/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>DockerFile 分为四部分：基础镜像、维护者、镜像操作指令、容器启动时执行指令</p>
<p><code>WORKDIR</code> 指定工作目录，类似于 cd,定位到某一个目录</p>
<pre><code class="language-Shell">WORKDIR /usr/local/nginx
</code></pre>
<p><code>RUN</code> 构建镜像时运行指令</p>
<pre><code class="language-shell">RUN apk add nginx &amp;&amp; mkdir /run/nginx/
</code></pre>
<p>构建指令：</p>
<pre><code class="language-Shell">docker build -f dockerfile-path .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="运行构建dockerfile"><a class="header" href="#运行构建dockerfile">运行构建dockerfile</a></h3>
<ol>
<li><code>-f</code> 指定dockerfile 文件构建镜像</li>
</ol>
<pre><code>docker build -f D:\docker\dockerfile\Dockerfile
</code></pre>
<ol start="2">
<li><code>-t</code></li>
</ol>
<pre><code>docker build -t image_name:tag .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code>docker run -itd --name=nginx -p 80:80 -p 443:443 -v /usr/local/small/nginx/conf.d:/etc/nginx/conf.d -v /usr/local/small/web/facepark/static:/root/web/facepark/static nginx:2.0
</code></pre>
<pre><code>docker run -itd --name=nginx -p 80:80 -p 443:443 -v /home/zouni/nginx/conf.d:/etc/nginx/conf.d -v /home/zouni/web/static:/home/zouni/web/static nginx:latest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>docker run -p 6379:6379 --name redis -v /root/redis/redis.conf:/etc/redis/redis.conf -v /root/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</p>
<p>docker run -itd --name redis -p 6379:6379 -v /root/redis/redis.conf:/etc/redis/redis.conf -v /root/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</p>
<h3 id="查看配置文件挂载"><a class="header" href="#查看配置文件挂载">查看配置文件挂载</a></h3>
<pre><code class="language-shell">docker inspect redis| grep Mounts -A 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<pre><code class="language-shell">pip3 install podman-compose
</code></pre>
<ol>
<li>创建卷</li>
</ol>
<blockquote>
<p>podman volume create data</p>
</blockquote>
<ol start="2">
<li>启动容器
podman-compose up</li>
</ol>
<pre><code class="language-yaml">version: 3.7
 
services:
  reverse-proxy:
    image: docker.io/library/caddy:alpine
    container_name: caddy-vishwambhar
    command: caddy run --config /etc/caddy/Caddyfile
    restart: always
    ports:
      - "8080:80"
      - "8443:443"
    volumes:
      - /docker-volumes/caddy/Caddyfile:/etc/caddy/Caddyfile:Z
      - /docker-volumes/caddy/site:/srv:Z
      - /docker-volumes/caddy/caddy_data:/data:Z
      - /docker-volumes/caddy/caddy_config:/config:Z
      - /docker-volumes/caddy/ssl:/etc/ssl:Z
    labels:
      - io.containers.autoupdate=registry
      - pratham.container.category=proxy
    environment:
      - TZ=Asia/Kolkata
    depends_on:
      - gitea-web
 
  gitea-web:
    image: docker.io/gitea/gitea:latest
    container_name: gitea-govinda
    restart: always
    ports:
      - "8010:3000"
      - "8011:22"
    volumes:
      - /docker-volumes/gitea/web:/data:Z
      - /docker-volumes/gitea/ssh:/data/git/.ssh:Z
      - /etc/localtime:/etc/localtime:ro
    labels:
      - io.containers.autoupdate=registry
      - pratham.container.category=gitea
    environment:
      - RUN_MODE=prod
      - DISABLE_SSH=false
      - START_SSH_SERVER=true
      - SSH_PORT=22
      - SSH_LISTEN_PORT=22
      - ROOT_URL=https://git.mydomain.com
      - DOMAIN=git.mydomain.com
      - SSH_DOMAIN=git.mydomain.com
      - GITEA__database__DB_TYPE=postgres
      - GITEA__database__HOST=gitea-db:5432
      - GITEA__database__NAME=gitea
      - GITEA__database__USER=gitea
      - GITEA__database__PASSWD=/run/secrets/gitea_database_user_password
      - GITEA__service__DISABLE_REGISTRATION=true
      - TZ=Asia/Kolkata
    depends_on:
      - gitea-db
    secrets:
      - gitea_database_user_password
 
  gitea-db:
    image: docker.io/library/postgres:14-alpine
    container_name: gitea-chitragupta
    restart: always
    volumes:
      - /docker-volumes/gitea/database:/var/lib/postgresql/data:Z
    labels:
      - io.containers.autoupdate=registry
      - pratham.container.category=gitea
    environment:
      - POSTGRES_USER=gitea
      - POSTGRES_PASSWORD=/run/secrets/gitea_database_user_password
      - POSTGRES_DB=gitea
      - TZ=Asia/Kolkata
    secrets:
      - gitea_database_user_password
 
secrets:
gitea_database_user_password:
external: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>rust note</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = String::from("hello");

let y = &amp;x[..2] // output: he  
let z = &amp;x[..=2] // output: hel 包含x[2]
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>&amp;x[..2]</code> 这里是对字符串<code>x</code>的引用，必须要加<code>&amp;</code>符号，否则会报错</li>
<li>如果是获得所有权 则不能用切片</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h3>
<p>语法： ' 单引号开头 ：<code>&amp;'a</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[test]
fn live_test(){
    let x = String::from("hello");
    let y = "hi";
    let z = live(&amp;x[..=2],y); //&amp;[..=2]
    println!("{}",z);
}

fn live&lt;'c&gt;(x: &amp;'c str,y: &amp;'c str) -&gt; &amp;'c str{
    if x.len()&gt;y.len(){
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="rust-引用类似java中的对象引用如果是直接赋值某个变量就意味着所有权转移"><a class="header" href="#rust-引用类似java中的对象引用如果是直接赋值某个变量就意味着所有权转移">rust 引用类似java中的对象引用，如果是直接赋值某个变量，就意味着所有权转移</a></h3>
<ul>
<li>引用|借用是指向被引用内存地址</li>
<li>所有权转移，原变量失效不可再用</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = String::from("hello");
let y = &amp;x;
println!("x的内存地址：{:p}",y);
let z = &amp;y;
println!("{:p}",*z);
println!("{:p}",&amp;z);
println!("{:p}",&amp;x);
<span class="boring">}</span></code></pre></pre>
<h3 id="所有权规则ownership-rules"><a class="header" href="#所有权规则ownership-rules">所有权规则（Ownership Rules）</a></h3>
<h4 id="1每个值都有一个所有者each-value-has-one-owner"><a class="header" href="#1每个值都有一个所有者each-value-has-one-owner">1.每个值都有一个所有者（Each value has one owner）</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("hello"); // s1 是 "hello" 的所有者
let s2 = s1;                    // 所有权从 s1 移动到 s2
// println!("{}", s1);          // 错误！s1 已经不再有效
<span class="boring">}</span></code></pre></pre>
<h4 id="2-同一时刻只能有一个所有者only-one-owner-at-a-time"><a class="header" href="#2-同一时刻只能有一个所有者only-one-owner-at-a-time">2. 同一时刻只能有一个所有者（Only one owner at a time）</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("hello");
let s2 = s1;                    // s1 的所有权移动到 s2
// s1 在这里已经无效了
<span class="boring">}</span></code></pre></pre>
<h4 id="3-当所有者离开作用域时值会被丢弃value-is-dropped-when-owner-goes-out-of-scope"><a class="header" href="#3-当所有者离开作用域时值会被丢弃value-is-dropped-when-owner-goes-out-of-scope">3. 当所有者离开作用域时，值会被丢弃（Value is dropped when owner goes out of scope）</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from("hello"); // s 进入作用域
    // 使用 s
} // s 离开作用域，内存被自动释放
<span class="boring">}</span></code></pre></pre>
<p>移动语义（Move Semantics）
基本类型（实现了 Copy trait）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;        // x 被复制给 y，x 仍然有效
println!("{}", x); // 正常工作
<span class="boring">}</span></code></pre></pre>
<p>复杂类型（未实现 Copy trait）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("hello");
let s2 = s1;        // s1 的所有权移动到 s2
// println!("{}", s1); // 编译错误！
<span class="boring">}</span></code></pre></pre>
<p>借用规则（Borrowing Rules）</p>
<ol>
<li>不可变借用规则</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("hello");
let r1 = &amp;s;    // 不可变借用
let r2 = &amp;s;    // 另一个不可变借用
// let r3 = &amp;mut s; // 错误！不能同时有可变和不可变借用
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>可变借用规则</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("hello");
let r1 = &amp;mut s;    // 可变借用
// let r2 = &amp;mut s; // 错误！不能同时有多个可变借用
// let r3 = &amp;s;     // 错误！不能同时有可变和不可变借用
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>借用必须始终有效</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r;                // 声明引用
    {
        let x = 5;        // x 进入作用域
        r = &amp;x;           // r 引用 x
    } // x 离开作用域，r 变成了悬垂引用
    // println!("{}", r); // 错误！
}</code></pre></pre>
<p>智能指针解决方案
Rc - 引用计数</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let data = Rc::new(String::from("hello"));
let data_clone1 = Rc::clone(&amp;data);    // 引用计数 +1
let data_clone2 = Rc::clone(&amp;data);    // 引用计数 +1
// 当所有 Rc 都离开作用域时，数据被释放
<span class="boring">}</span></code></pre></pre>
<p>RefCell - 运行时借用检查</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let data = RefCell::new(5);
*data.borrow_mut() += 10;              // 可变借用
println!("{}", *data.borrow());        // 不可变借用
<span class="boring">}</span></code></pre></pre>
<p>Rc<RefCell> - 组合使用</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

let data = Rc::new(RefCell::new(5));
let data_clone = Rc::clone(&amp;data);
*data_clone.borrow_mut() += 10;        // 修改共享数据
println!("{}", *data.borrow());        // 看到修改后的值
<span class="boring">}</span></code></pre></pre>
<h3 id="生命周期lifetimes"><a class="header" href="#生命周期lifetimes">生命周期（Lifetimes）</a></h3>
<p>基本语法</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<p>生命周期省略规则</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 编译器自动推断生命周期
fn first_word(s: &amp;str) -&gt; &amp;str { ... }  // 等同于 fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str
<span class="boring">}</span></code></pre></pre>
<p>实际应用示例
你的 CubeSat 项目中的使用</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let base = Rc::new(RefCell::new(GroundStation { radio_freq: 87.65 }));
// Rc 允许多个所有者
// RefCell 允许运行时借用检查
// 结合使用可以安全地共享可变状态

let sat = base.borrow().connect(id);     // 不可变借用
base.borrow_mut().radio_freq += 1.0;    // 可变借用
<span class="boring">}</span></code></pre></pre>
<h3 id="rust-的所有权系统通过以下方式保证内存安全"><a class="header" href="#rust-的所有权系统通过以下方式保证内存安全">Rust 的所有权系统通过以下方式保证内存安全：</a></h3>
<ul>
<li>编译时检查 - 防止悬垂引用和数据竞争</li>
<li>零成本抽象 - 运行时没有垃圾收集器开销</li>
<li>明确的所有权语义 - 代码意图清晰，易于理解</li>
<li>智能指针 - 在需要时提供额外的灵活性</li>
</ul>
<p>以上转自：https://www.cnblogs.com/JohannaFeng/p/19050150</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="str和string区别"><a class="header" href="#str和string区别">str和String区别：</a></h3>
<p>通俗讲 String就像是<code>笔记本</code>,可以往里面写字符串；而str就像是一个<code>标签</code>,引用了<code>笔记本</code>里的一段内容；</p>
<ul>
<li>String 是 Rust 标准库提供的可变、拥有所有权的字符串类型，底层是堆分配，可以动态增长和修改。</li>
<li>str 是不可变的字符串切片类型，通常以 &amp;str 形式出现，指向某个字符串的一部分，不能直接修改内容。</li>
<li>String 可以通过 .as_str() 方法转换为 &amp;str，而 &amp;str 可以通过 .to_string() 或 String::from() 转换为 String。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = String::from("hi zouni");
let y:&amp;str = &amp;x[1..2];

//&amp;str -&gt; String
let x = "world";
let y:String = x.to_string();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="trait-函数集合类似java中的interface接口"><a class="header" href="#trait-函数集合类似java中的interface接口">trait 函数集合，类似java中的interface接口</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User{
    name:String,
    age:i8
}

trait Hello{
    fn hello(&amp;self) -&gt; String;
    fn print(&amp;self){
        print!("hello trait");
    }
}

impl Hello for User{
    fn hello(&amp;self) -&gt; String {
        format!("hello {}",self.name)
    }
}

#[test]
fn trait_test(){
    let u = User{name:String::from("zhangsan"),age:18};
    u.print();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="模块--mod"><a class="header" href="#模块--mod">模块  mod</a></h3>
<p>mod 组织代码结构；</p>
<p>内部模块
外部调用模块内函数—&gt; pub 修饰符</p>
<pre><pre class="playground"><code class="language-rust">mod mod_test{
    pub fn hello(){
        println!("hi");
    }
    pub mod mod_inner{
        pub fn hello1(){
            println!("hi inner mod");
        }
    }
}

fn main(){
    //这里要调用模块 mod_test()
    crate::mod_test::hello();
}</code></pre></pre>
<ul>
<li><code>main</code>函数要调用模块<code>mod_test</code>中的函数<code>hello()</code> ，函数必须要有权限修饰符<code>pub</code></li>
<li>模块之间调用，被调用模块同一个包下可以随便调用，否则也要<code>pub</code>修饰符修饰。</li>
</ul>
<blockquote>
<p>crate::mod_test::hello();</p>
</blockquote>
<h3 id="注解-1"><a class="header" href="#注解-1">注解</a></h3>
<p>写了代码却不用，会被警告⚠️，加上<code>#[allow(unused)]</code>注解可以去掉警告，对编译器有效。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extern-c-学习记录"><a class="header" href="#extern-c-学习记录">extern "C" 学习记录</a></h2>
<pre><code class="language-C++">// A.cpp
//告诉编译器这里修饰的是C语言的代码，
extern "C" {
    //在编译阶段，不会被编译成C++这样的fun_int_int符号，即使找不到函数也不会报错
    void fun(int a,int b){
        
    }
}
</code></pre>
<pre><code class="language-C++">//B.cpp
#include "A.h"
int main(){
    //对于C++来说，因为有函数重载的机制，编译后的函数会以 函数名 + 形参 来命名，
    //对于C来说，没有函数重载，不会被转成fun_int_int这样的符号
    fun(1,2); 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="配置环境"><a class="header" href="#配置环境">配置环境</a></h3>
<p>第一次打开Clion,首先配置Toolchains,这里使用了Mingw</p>
<p><img src="C_CXX//res/CXX/toolchain.png" alt="toolchains" /></p>
<p><img src="C_CXX//res/CXX/clion1.png" alt="设置" /></p>
<p>配置Cmake options,增加以下参数：</p>
<pre><code>-DCMAKE_SYSTEM_NAME=Android
-DANDROID_NDK="E:\WorkRoom\android\sdk_root\ndk\22.1.7171670"
-DANDROID_TOOLCHAIN_NAME=aarch64-linux-android-clang3.5
-DCMAKE_TOOLCHAIN_FILE="E:\WorkRoom\android\sdk_root\ndk\22.1.7171670\build\cmake\android.toolchain.cmake"
-DANDROID_PLATFORM="android-21"
-DANDROID_TOOLCHAIN="clang"
-DCMAKE_C_FLAGS="-fpic -fexceptions -frtti"
-DCMAKE_CXX_FLAGS="-fpic -fexceptions -frtti"
-DANDROID_STL="c++_static"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>#include &lt;stdio.h&gt;
int main(int argc, char const *argv[])
{
    printf('123');
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="原码反码补码的概念和理解"><a class="header" href="#原码反码补码的概念和理解">原码反码补码的概念和理解</a></h2>
<h2 id="1-原码"><a class="header" href="#1-原码">1. 原码</a></h2>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]<br />
即<br />
[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h2 id="2-反码"><a class="header" href="#2-反码">2. 反码</a></h2>
<p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h2 id="3-补码"><a class="header" href="#3-补码">3. 补码</a></h2>
<p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<p>转自：<a href="https://blog.csdn.net/zl10086111/article/details/80907428">https://blog.csdn.net/zl10086111/article/details/80907428</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="编译过程描述"><a class="header" href="#编译过程描述">编译过程描述</a></h3>
<p>//生成预处理文件<br />
g++ -o HelloWorld.ii -E HelloWorld.cpp<br />
//生成汇编文件<br />
g++ -o HelloWorld.s -S HelloWorld.ii<br />
//生成二进制也就是目标文件<br />
g++ -o HelloWorld.o -c HelloWorld.s<br />
//生成可执行文件
g++ -o HelloWorld.exe HelloWorld.o</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="clion-stm32-开发环境搭建"><a class="header" href="#clion-stm32-开发环境搭建">clion+ stm32 开发环境搭建</a></h1>
<p><a href="https://www.jetbrains.com/help/clion/2021.2/embedded-development.html">参考jetbrains官方指导</a></p>
<h1 id="准备"><a class="header" href="#准备">准备</a></h1>
<h2 id="1-clion"><a class="header" href="#1-clion">1. clion</a></h2>
<h2 id="2-gcc-arm-none-eabi"><a class="header" href="#2-gcc-arm-none-eabi">2. gcc-arm-none-eabi</a></h2>
<p><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">下载 gcc-arm-none-eabi-10.3-2021.10-win32.exe</a>
一键安装：最后一步勾选（path添加到环境变量，否则编译程序找不到编译器）</p>
<h2 id="3-mingw-get-setupexe"><a class="header" href="#3-mingw-get-setupexe">3. mingw-get-setup.exe</a></h2>
<p>安装之后，配置clion Toolchains 环境就可以了</p>
<h2 id="4-stm32cubemx-winzip"><a class="header" href="#4-stm32cubemx-winzip">4. stm32cubemx-win.zip</a></h2>
<p>这一步没什么特殊 一键安装</p>
<h2 id="5-openocd"><a class="header" href="#5-openocd">5. OpenOCD</a></h2>
<h3 id="51-openocd-配置"><a class="header" href="#51-openocd-配置">5.1 openOCD 配置</a></h3>
<p>配置ST-link烧写器配置文件
stm32f103_stlink.cfg</p>
<pre><code class="language-config">source [find interface/stlink.cfg]
transport select hla_swd
source [find target/stm32f1x.cfg]
adapter speed 2000  // adapter_khz 2000
</code></pre>
<p>保存到openOCD脚本目录下：<br />
D:\WorkRoom\embedded\stm32\OpenOCD-20210729-0.11.0\share\openocd\scripts\board</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="串口引脚定义"><a class="header" href="#串口引脚定义">串口引脚定义</a></h3>
<ol>
<li>DTR : 数据终端准备好</li>
<li>RTS: 请求发送</li>
<li>RXD: 接收</li>
<li>TXD: 发送</li>
<li>CTS: 清除发送</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ttl"><a class="header" href="#ttl">TTL</a></h3>
<ul>
<li>
<p>输出 <code>1</code> :=&gt; 电压大于等于 <code>2.4v</code>  <code>0</code> :=&gt; 电压小于等于 <code>0.4v</code></p>
</li>
<li>
<p>输入 <code>1</code> :=&gt; 电压大于等于<code>2.0v</code>  <code>0</code> :=&gt; 电压小于等于<code>0.8v</code></p>
</li>
</ul>
<p>TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限（噪声容限是指在前一极输出为最坏的情况下，为保证后一极正常工作，所允许的最大噪声幅度 。噪声容限越大说明容许的噪声越大，电路的抗干扰性越好 。）就只有（0.8-0）/2=0.4V，高电平的噪声容限为（5-2.4）/2=1.3V。</p>
<h3 id="cmos"><a class="header" href="#cmos">CMOS</a></h3>
<ul>
<li>
<p>输出 L：<code>0</code> &lt;0.1<em>Vcc ； <code>1</code> H：&gt;0.9</em>Vcc。</p>
</li>
<li>
<p>输入 L：<code>0</code> &lt;0.3<em>Vcc ； <code>1</code> H：&gt;0.7</em>Vcc.</p>
</li>
</ul>
<p>由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。</p>
<p>CMOS电平能够驱动TTL电平；</p>
<p>TTL电平不能驱动CMOS电平，需要加上拉电阻</p>
<h3 id="rs232"><a class="header" href="#rs232">RS232</a></h3>
<ul>
<li>逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。</li>
</ul>
<p>RS232的电平标准为+12V为逻辑负，-12为逻辑正，TTL电平为5V为逻辑正，0为逻辑负</p>
<h3 id="rs485"><a class="header" href="#rs485">RS485</a></h3>
<ul>
<li>RS485采用差分信号负逻辑，逻辑"1”以两线间的电压差为-(2~6)V表示;逻辑"0"以两线间的电压差为+(2~6)V表示。</li>
</ul>
<p>TTL接口电平常见的有3.3V和5V的。通过在0和TTL电平之间摆动，来传输数据。需要通讯双方“约定”好速率。也就是说，通过TTL电平传输的UART接口是一种不传输时钟的"异步通讯"方式。</p>
<p>而RS485接口，简单说就是把TTL的“0-3.3V/5V之间摆动”的信号，转换为“5V压差颠倒反转的AB线信号”，并且扩流驱动电缆电容。简单说就是这样。</p>
<p>所以可以理解为，RS485是以TTL数据源的总线驱动芯片。</p>
<p>RS485采用差分信号逻辑，更适合长距离、高速传输。</p>
<p>接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片， 且该电平与TTL电平兼容，可方便与TTL电路连接。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-交叉编译-ffmpeg---aarch64"><a class="header" href="#1-交叉编译-ffmpeg---aarch64">1. 交叉编译 ffmpeg -&gt; aarch64</a></h1>
<h2 id="11参数说明"><a class="header" href="#11参数说明">1.1参数说明：</a></h2>
<pre><code>--cross-prefix 指定交叉编译工具链路径
--arch 指定cpu指令集架构
--target-os 目标系统 linux
--cc  c 编译器 默认：cc  这里指定clang  google官方已经在ndk去掉了gcc
--enable-cross-compile 开启交叉编译
--disable-static 关闭静态编译
--enable-shared 开启shared表示编译动态链接库
--disable-ffmpeg 不开启ffmpeg 模块
--disable-ffplay 不开启ffplay 播放器模块
--disable-ffprobe 不开启ffprobe 音视频分析模块
</code></pre>
<h2 id="12设置环境变量"><a class="header" href="#12设置环境变量">1.2设置环境变量</a></h2>
<p>NDK版本：android-ndk-r22b</p>
<pre><code class="language-shell">export NDK_ROOT=/mnt/e/WorkRoom/ubuntu/android-ndk-r22b/toolchains/llvm/prebuilt/linux-x86_64
export SYSROOT=$NDK_ROOT/sysroot
</code></pre>
<h2 id="13-执行-configure"><a class="header" href="#13-执行-configure">1.3 执行 ./configure</a></h2>
<p><strong>需要注意</strong>：新版本ndk工具链取消了gcc编译器，默认编译器是clang,配置项目里面需要指定c/c++ 编译器</p>
<blockquote>
<p>--cc=$NDK_ROOT/bin/armv7a-linux-androideabi21-clang <br />
--cxx=$NDK_ROOT/bin/armv7a-linux-androideabi21-clang++</p>
</blockquote>
<p>完整的编译参数如下：</p>
<pre><code class="language-shell">small@small:~$ ./configure  \
--prefix=/mnt/e/WorkRoom/ffmpeg/ffarm \
--arch=aarch64 \
--cpu=armv8 \
--target-os=android \
--sysroot=$SYSROOT \
--cross-prefix=$NDK_ROOT/bin/aarch64-linux-android- \
--extra-cflags="-I$SYSROOT/usr/include -fPIC -DANDROID -mfpu=neon -mfloat-abi=softfp " \
--extra-ldflags="-L$SYSROOT/usr/lib" \
--cc=$NDK_ROOT/bin/aarch64-linux-android21-clang \
--nm=$NDK_ROOT/bin/aarch64-linux-android-nm \
--cxx=$NDK_ROOT/bin/aarch64-linux-android21-clang++ \
--enable-runtime-cpudetect \
--enable-neon \
--enable-shared \
--enable-asm \
--disable-static \
--enable-cross-compile \
--enable-small \
--enable-jni \
--enable-mediacodec \
--enable-gpl \
--enable-decoder=h264_mediacodec \
--disable-doc \
--disable-debug \
--disable-ffmpeg \
--disable-ffplay \
--disable-ffprobe \
--disable-postproc \
--disable-avdevice \
--disable-symver \
--disable-stripping
</code></pre>
<pre><code># --enable-hwaccel=h264_mediacodec \
# --enable-asm \
</code></pre>
<p>armv7-a</p>
<pre><code>./configure  \
--prefix=/mnt/e/WorkRoom/ffmpeg/ffarm \
--arch=arm \
--cpu=armv7-a \
--target-os=android \
--sysroot=$SYSROOT \
--cross-prefix=$NDK_ROOT/bin/arm-linux-android- \
--extra-cflags="-I$SYSROOT/usr/include -fPIC -DANDROID -mfpu=neon -mfloat-abi=softfp " \
--extra-ldflags="-L$SYSROOT/usr/lib" \
--cc=$NDK_ROOT/bin/armv7a-linux-androideabi21-clang \
--nm=$NDK_ROOT/bin/arm-linux-androideabi-nm \
--cxx=$NDK_ROOT/bin/armv7a-linux-androideabi21-clang++ \
--enable-runtime-cpudetect \
--enable-neon \
--enable-shared \
--enable-asm \
--disable-static \
--enable-cross-compile \
--enable-small \
--enable-jni \
--enable-mediacodec \
--enable-gpl \
--enable-decoder=h264_mediacodec \
--disable-doc \
--disable-debug \
--disable-ffmpeg \
--disable-ffplay \
--disable-ffprobe \
--disable-postproc \
--disable-avdevice \
--disable-symver \
--disable-stripping
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>输入视频，输出转码后的视频</p>
<blockquote>
<p>ffmpeg -i intput.mp4 output.mp4</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>参考文章：https://zhuanlan.zhihu.com/p/73984438</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linux-编译-ffmpeg"><a class="header" href="#linux-编译-ffmpeg">linux 编译 ffmpeg</a></h2>
<ol>
<li>
<p>下载源码<br />
<a href="https://github.com/FFmpeg/FFmpeg">下载ffmpeg源码</a> 或者通过git clone源码：</p>
<pre><code>git clone git@github.com:FFmpeg/FFmpeg.git
</code></pre>
</li>
<li>
<p>进入源码根目录，执行<code>./configure</code> 出现如下错误：</p>
<pre><code>nasm/yasm not found
</code></pre>
<p>需要下载yasm汇编器</p>
</li>
<li>
<p>下载yasm汇编器</p>
<pre><code>wget https://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz
</code></pre>
<p>解压安装  :</p>
<pre><code class="language-shell">tar -zxvf yasm-1.3.0.tar.gz
</code></pre>
<p>进入解压后目录</p>
<pre><code>cd yasm-1.3.0

./configure
# 接着 
make 
sudo make install
</code></pre>
<p>接着返回 ffmpeg目录，执行命令</p>
<pre><code>small@small:~/FFmpeg$
./configure --prefix="/usr/local/ffmpeg/" --enable-libx264 --enable-gpl --enable-nonfree --enable-libfdk-aac
</code></pre>
<p>出现如下显示就代表成功了：</p>
<pre><code class="language-shell">small@small:~/FFmpeg$ ./configure
install prefix            /usr/local
source path               .
C compiler                gcc
C library                 glibc
ARCH                      x86 (generic)
big-endian                no
runtime cpu detection     yes
standalone assembly       yes
x86 assembler             yasm
MMX enabled               yes
MMXEXT enabled            yes
3DNow! enabled            yes
3DNow! extended enabled   yes
SSE enabled               yes
SSSE3 enabled             yes
AESNI enabled             yes
AVX enabled               yes
AVX2 enabled              yes
AVX-512 enabled           yes
XOP enabled               yes
...
</code></pre>
</li>
</ol>
<h2 id="启用第三方模块支持libfdk_aac和libx264需要单独下载编译"><a class="header" href="#启用第三方模块支持libfdk_aac和libx264需要单独下载编译">启用第三方模块支持：libfdk_aac和libx264，需要单独下载编译</a></h2>
<p>出现如下错误</p>
<h3 id="1-error-libfdk_aac-not-found"><a class="header" href="#1-error-libfdk_aac-not-found">1. ERROR: libfdk_aac not found</a></h3>
<pre><code class="language-shell">small@small:~/FFmpeg$ ./configure --enable-libx264 --enable-libfdk-aac --enable-gpl --enable-nonfree
ERROR: libfdk_aac not found

If you think configure made a mistake, make sure you are using the latest
version from Git.  If the latest version fails, report the problem to the
ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.
Include the log file "ffbuild/config.log" produced by configure as this will help
solve the problem.
</code></pre>
<p><a href="https://sourceforge.net/projects/opencore-amr/files/fdk-aac/">下载libfdk_aac库</a>：
https://sourceforge.net/projects/opencore-amr/files/fdk-aac/</p>
<pre><code class="language-shell">./configure  # 配置
make  # 编译
make install # 编译安装
</code></pre>
<h3 id="2-error-libx264-not-found"><a class="header" href="#2-error-libx264-not-found">2. ERROR: libx264 not found</a></h3>
<pre><code class="language-shell">small@small:~/FFmpeg$ ./configure --enable-libx264 --enable-libfdk-aac --
ERROR: libx264 not found

If you think configure made a mistake, make sure you are using the latest
version from Git.  If the latest version fails, report the problem to the
ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.
Include the log file "ffbuild/config.log" produced by configure as this will help
solve the problem.

</code></pre>
<p><a href="https://www.videolan.org/developers/x264.html">下载libx264</a> ：https://www.videolan.org/developers/x264.html</p>
<p>代码库：git clone https://code.videolan.org/videolan/x264.git<br />
下载完继续：</p>
<pre><code class="language-shell">./configure  --enable-shared
make  
make install
</code></pre>
<h3 id="3-还没完又出现新的错误了"><a class="header" href="#3-还没完又出现新的错误了">3. 还没完，又出现新的错误了：</a></h3>
<pre><code class="language-shell">small@small:~/x264$ ./configure
Found no assembler
Minimum version is nasm-2.13
If you really want to compile without asm, configure with --disable-asm.
</code></pre>
<p><a href="https://www.nasm.us/pub/nasm/releasebuilds/2.15/">下载nasm目前最新版</a> :https://www.nasm.us/pub/nasm/releasebuilds/2.15/
继续编译安装：</p>
<pre><code class="language-shell">./configure  
make  
make install
</code></pre>
<h3 id="4-回到上一步继续编译x264"><a class="header" href="#4-回到上一步继续编译x264">4. 回到上一步，继续编译x264:</a></h3>
<pre><code class="language-shell">./configure  --enable-shared # --enable-shared 这里很重要
make  
make install
</code></pre>
<h3 id="5-最终回到ffmpeg继续编译"><a class="header" href="#5-最终回到ffmpeg继续编译">5. 最终回到ffmpeg继续编译:</a></h3>
<pre><code class="language-shell">small@small:~/FFmpeg$ ./configure --enable-libx264 --enable-libfdk-aac --
small@small:~/FFmpeg$ make
small@small:~/FFmpeg$ make install
</code></pre>
<h3 id="6-make-nothing-to-be-done-for-all"><a class="header" href="#6-make-nothing-to-be-done-for-all">6. make: Nothing to be done for 'all'.</a></h3>
<p>有时候需要重新编译，会遇到这个错误，需要 clean</p>
<pre><code class="language-shell">make clean
</code></pre>
<h3 id="7-最后还有个问题就是找不到so-库的问题"><a class="header" href="#7-最后还有个问题就是找不到so-库的问题">7. 最后还有个问题就是找不到<code>.so</code> 库的问题</a></h3>
<pre><code class="language-shell">small@small:/usr/lib$ ffmpeg
ffmpeg: error while loading shared libraries: libx264.so.161: cannot open shared object file: No such file or directory
</code></pre>
<p>这个问题一看就是没找到动态库，libx264默认安装路径是 <code>/usr/local/lib</code> 目录，解决这个问题的方法就是建个软连接或者直接把库移动到 <code>/usr/lib</code> 目录:</p>
<pre><code class="language-shell">small@small:/usr/local/lib$ sudo ln -s /usr/local/lib/libx264.so.161 /usr/lib/libx264.so.161
</code></pre>
<p>大功告成，没有报错；</p>
<h3 id="8-接下来试试看是否正常"><a class="header" href="#8-接下来试试看是否正常">8. 接下来试试看是否正常：</a></h3>
<pre><code class="language-shell">small@small:~$ ffmpeg -i YOLOv3.mp4 YO.flv
ffmpeg version 4.3.git Copyright (c) 2000-2021 the FFmpeg developers
  built with gcc 9 (Ubuntu 9.3.0-17ubuntu1~20.04)
  configuration: --enable-libx264 --enable-libfdk-aac --enable-gpl --enable-nonfree
  libavutil      56. 66.100 / 56. 66.100
  libavcodec     58.125.101 / 58.125.101
  libavformat    58. 68.100 / 58. 68.100
  libavdevice    58. 12.100 / 58. 12.100
  libavfilter     7.107.100 /  7.107.100
  libswscale      5.  8.100 /  5.  8.100
  libswresample   3.  8.100 /  3.  8.100
  libpostproc    55.  8.100 / 55.  8.100
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'YOLOv3.mp4':
  Metadata:
    major_brand     : mp42
    minor_version   : 0
    compatible_brands: isommp42
    creation_time   : 2018-10-29T06:43:27.000000Z
  Duration: 00:03:45.70, start: 0.000000, bitrate: 2072 kb/s
  Stream #0:0(und): Video: h264 (Main) (avc1 / 0x31637661), yuv420p(tv, bt709), 1280x720 [SAR 1:1 DAR 16:9], 1942 kb/s, 29.97 fps, 29.97 tbr, 90k tbn, 59.94 tbc (default)
  ...
</code></pre>
<h3 id="9-看一下转换结果没有问题"><a class="header" href="#9-看一下转换结果没有问题">9. 看一下转换结果，没有问题~</a></h3>
<pre><code class="language-shell">small@small:~$ ls
FFmpeg      fdk-aac-2.0.1         log.txt              nasm-2.15.tar.gz  x264
YO.flv      fdk-aac-2.0.1.tar.gz  nasm-2.13.03.tar.gz  python            
YOLOv3.mp4  go                    nasm-2.15            test.go           yasm-1.3.0.tar.gz
</code></pre>
<p>收工</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>The package spell-check cannot load the system dictionary for zh-CN. See the settings for ways of changing the languages used, resolving missing dictionaries, or hiding this warning.</p>
<p><img src="atom//res/atom/atom_1.png" alt="atom" /></p>
<ol>
<li><code>Use Locales</code> 前面的勾选去掉</li>
<li>下面添加 <code>en-US</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>个人博客</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="github创建项目"><a class="header" href="#github创建项目">github创建项目</a></h3>
<ol>
<li>创建仓库，项目名字要用<code>username.github.io</code></li>
</ol>
<blockquote>
<p>git clone https://github.com/username/username.github.io</p>
</blockquote>
<ol start="2">
<li>编辑后提交</li>
</ol>
<blockquote>
<p>cd username.github.io</p>
</blockquote>
<blockquote>
<p>echo "Hello World" &gt; index.html</p>
</blockquote>
<ol start="3">
<li>直接预览就可以了</li>
</ol>
<blockquote>
<p>git add --all</p>
</blockquote>
<blockquote>
<p>git commit -m "Initial commit"</p>
</blockquote>
<blockquote>
<p>git push -u origin main</p>
</blockquote>
<ol start="4">
<li>浏览器访问 https://username.github.io.</li>
</ol>
<p><a href="https://pages.github.com/">Github官方说明</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化"><a class="header" href="#初始化">初始化</a></h1>
<ol>
<li>
<p>下载hugo已发布版本</p>
</li>
<li>
<p>配置环境变量：<br />
2.1. 创建 <code>bin</code> 文件夹，将<code>hugo.exe</code> 放在<code>bin</code>文件夹下；<br />
2.2. 配置换进变量：将<code>hugo/bin/</code>目录添加到 <code>path</code> 中；</p>
</li>
<li>
<p>创建站点：</p>
<blockquote>
<p>hugo new site path/project_name</p>
</blockquote>
</li>
<li>
<p>运行站点：</p>
<blockquote>
<p>cd path/project_name  //定位到当前站点目录</p>
</blockquote>
<blockquote>
<p>hugo server //运行服务</p>
</blockquote>
</li>
<li>
<p>部署：</p>
<blockquote>
<p>hugo   //hugo 命令构建站点
build完后的站点文件夹下 <code>public</code> 目录</p>
</blockquote>
</li>
</ol>
<h1 id="设置主题"><a class="header" href="#设置主题">设置主题</a></h1>
<p>主题选择：https://themes.gohugo.io/tags/dark/</p>
<blockquote>
<p>cd themes</p>
</blockquote>
<blockquote>
<p>git clone git@github.com:setsevireon/photophobia.git</p>
</blockquote>
<blockquote>
<p>git submodule add https://github.com/alex-shpak/hugo-book</p>
</blockquote>
<blockquote>
<p>themes/book</p>
</blockquote>
<h1 id="启动本地调试"><a class="header" href="#启动本地调试">启动本地调试</a></h1>
<blockquote>
<p>hugo server --theme=photophobia --buildDrafts --watch</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="搭建个人博客站点可以把平时学习或工作中的一些笔记或知识点积累的东西分享到-分享几种实现博客搭建的方式"><a class="header" href="#搭建个人博客站点可以把平时学习或工作中的一些笔记或知识点积累的东西分享到-分享几种实现博客搭建的方式">搭建个人博客站点，可以把平时学习或工作中的一些笔记或知识点积累的东西分享到 ，分享几种实现博客搭建的方式</a></h3>
<h3 id="1-github-pages-静态网页托管服务"><a class="header" href="#1-github-pages-静态网页托管服务">1. github pages 静态网页托管服务</a></h3>
<p><a href="https://pages.github.com/">这里有官方说明</a>  分分钟搭建起来</p>
<ol>
<li>首先根据前面我写的 hugo 教程，先创建自己的网站内容先。</li>
<li>创建仓库，仓库名称 <em>注意</em>： <code>github 账户名</code>+<code>github.io</code> 比如：<a href="blog/hugo/zouni88.github.io">zouni88.github.io</a></li>
<li>内容提交</li>
</ol>
<pre><code># 仓库 down 到本地
git clone git@github.com:Yourname/Yourname.github.io.git
# 切换分支到master，默认应该是main
git checkout -b master
# 查看分支
git branch
    main
    * master
# 添加 index.html文件,并编辑
touch index.html
# 提交
git push --set-upstream origin master
</code></pre>
<ol start="4">
<li>大功告成，浏览器打开： <code>Yourname.github.io</code></li>
</ol>
<h3 id="2-gitee-pages-静态网页托管服务"><a class="header" href="#2-gitee-pages-静态网页托管服务">2. gitee pages 静态网页托管服务</a></h3>
<p>使用方法和<code>github pages</code> 类似, <a href="https://gitee.com/help/articles/4136#article-header0">官方帮助文档</a></p>
<h3 id="3-gitbook买个域名先"><a class="header" href="#3-gitbook买个域名先">3. gitbook,买个域名先</a></h3>
<p>这个就是要根据自己的网络情况了，不是每次都能顺利打开。</p>
<h3 id="4-如果有能力就自己搭建服务或购买云服务"><a class="header" href="#4-如果有能力就自己搭建服务或购买云服务">4. 如果有能力就自己搭建服务或购买云服务</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/idealvin/hugo-book</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化-1"><a class="header" href="#初始化-1">初始化</a></h1>
<ol>
<li>
<p>下载hugo已发布版本</p>
</li>
<li>
<p>配置环境变量：<br />
2.1. 创建 <code>bin</code> 文件夹，将<code>hugo.exe</code> 放在<code>bin</code>文件夹下；<br />
2.2. 配置换进变量：将<code>hugo/bin/</code>目录添加到 <code>path</code> 中；</p>
</li>
<li>
<p>创建站点：</p>
<blockquote>
<p>hugo new site path/project_name</p>
</blockquote>
</li>
<li>
<p>运行站点：</p>
<blockquote>
<p>cd path/project_name  //定位到当前站点目录</p>
</blockquote>
<blockquote>
<p>hugo server //运行服务</p>
</blockquote>
</li>
<li>
<p>部署：</p>
<blockquote>
<p>hugo   //hugo 命令构建站点
build完后的站点文件夹下 <code>public</code> 目录</p>
</blockquote>
</li>
</ol>
<h1 id="设置主题-1"><a class="header" href="#设置主题-1">设置主题</a></h1>
<blockquote>
<p>cd themes
git clone git@github.com:setsevireon/photophobia.git
git submodule add https://github.com/alex-shpak/hugo-book themes/book</p>
</blockquote>
<h1 id="启动本地调试-1"><a class="header" href="#启动本地调试-1">启动本地调试</a></h1>
<blockquote>
<p>hugo server --theme=photophobia --buildDrafts --watch</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mdbook-book文档书写工具rust-lang-官方出品"><a class="header" href="#mdbook-book文档书写工具rust-lang-官方出品">mdbook: book文档书写工具：rust-lang 官方出品</a></h2>
<p>https://github.com/rust-lang/mdBook</p>
<h3 id="支持mermaid-插件-安装"><a class="header" href="#支持mermaid-插件-安装">支持mermaid 插件 安装</a></h3>
<blockquote>
<p>cargo install mdbook-mermaid</p>
</blockquote>
<h3 id="这一步会下载-mermaid相关js文件"><a class="header" href="#这一步会下载-mermaid相关js文件">这一步会下载 mermaid相关js文件</a></h3>
<blockquote>
<p>mdbook-mermaid install .</p>
</blockquote>
<h3 id="booktoml中添加如下"><a class="header" href="#booktoml中添加如下">book.toml中添加如下</a></h3>
<pre><code class="language-toml">[preprocessor.mermaid]
command = "mdbook-mermaid"

[output.html]
additional-js = ["mermaid.min.js", "mermaid-init.js"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><p>用户名：pi
密码：raspberry</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="docker-脚本安装"><a class="header" href="#docker-脚本安装">docker 脚本安装</a></h3>
<pre><code>sudo curl https://get.docker.com/ &gt; ./docker_install.sh
sudo sh docker_install.sh –mirror Aliyun
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="打开配置"><a class="header" href="#打开配置">打开配置</a></h3>
<pre><code>sudo raspi-config
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="下载镜像-1"><a class="header" href="#下载镜像-1">下载镜像</a></h3>
<p>将镜像写入sd卡 ，下载写入程序</p>
<pre><code>https://www.raspberrypi.org/downloads/
</code></pre>
<h3 id="修改配置"><a class="header" href="#修改配置">修改配置</a></h3>
<p>写入sd卡后，不要拔出，直接在sdcard中修改配置：</p>
<ol>
<li>开启ssh
在根目录下直接新建<code>ssh</code>文件夹，就成功了</li>
<li>开启<code>HDMI</code>显示输出
修改config.txt文件</li>
</ol>
<pre><code>hdmi_safe=1
config_hdmi_boost=4
hdmi_ignore_edid=0xa5000080
hdmi_group=2
hdmi_mode=82  
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>hdmi_safe=1</td><td>安全启动HDMI</td></tr>
<tr><td>config_hdmi_boost=4</td><td>开启热插拔</td></tr>
<tr><td>hdmi_group=1</td><td>CEA电视显示器</td></tr>
<tr><td>hdmi_group=2</td><td>DMT电脑显示器</td></tr>
<tr><td>hdmi_ignore_edid=0xa5000080</td><td>忽略自动探测的分辨率</td></tr>
<tr><td>hdmi_mode=4</td><td>640x480 60Hz</td></tr>
<tr><td>hdmi_mode=9</td><td>800x600 60Hz</td></tr>
<tr><td>hdmi_mode=16</td><td>1024x768 60Hz</td></tr>
<tr><td>hdmi_mode=82</td><td>1080p 60Hz</td></tr>
</tbody></table>
</div>
<h3 id="连接树莓派"><a class="header" href="#连接树莓派">连接树莓派</a></h3>
<p>树莓派启动后，<code>红灯</code>亮表示 接通电源；<code>绿灯</code>表示正在读写<code>sd</code>卡
3. 设置无线<code>wifi</code>
新建<code>wpa_supplicant.conf</code>文件</p>
<pre><code>  country=CN
  ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
  update_config=1

  network={
      ssid="wifiname"
      psk="password"
      priority=1
  }
</code></pre>
<p>说明：</p>
<ol>
<li><code>ssid</code>: wifi名字</li>
<li><code>psk</code>: wifi 密码</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="语法学习"><a class="header" href="#语法学习">语法学习</a></h3>
<pre><code class="language-solidity">//没有这一句会有警告
// SPDX-License-Identifier: GPL-3.0

//指明版本
pragma solidity &gt;=0.8.7 &lt;0.9.0;

//声明合约
contract trans{
    uint8 tt;

    function setTT(uint8 i) public {
        tt = i;
    }

    //view : 当前函数不会修改账本数据
    //int uint : 默认是uint256
    function getTT() public view  returns (uint8){
        return tt;
    }
}
</code></pre>
<h3 id="关键字"><a class="header" href="#关键字">关键字</a></h3>
<ul>
<li>contract</li>
<li>constructor</li>
<li>public</li>
<li>private</li>
<li>external</li>
<li>internal</li>
<li>view</li>
<li>pure</li>
<li>payable</li>
</ul>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<ol>
<li>uint8 -&gt; uint256: 地址长度  8位递增</li>
<li>string -&gt; 字符串，不可变，可强转</li>
<li>mapping(uint =&gt; uint) scoreList;   字典</li>
</ol>
<h3 id="数据存储位置"><a class="header" href="#数据存储位置">数据存储位置</a></h3>
<ol>
<li><code>memory</code>   内存变量，调用结束就消失</li>
<li><code>storage</code>  状态变量，随着合约进入分布式账本</li>
<li><code>calldata</code> 永久存储</li>
</ol>
<h3 id="修饰符"><a class="header" href="#修饰符">修饰符</a></h3>
<ol>
<li>变量修饰符: <code>public</code> or <code>private</code></li>
<li>函数修饰符
<ul>
<li>view 函数不会改变任何东西，被view修饰的函数可以读取外部变量，不能修改</li>
<li>pure 函数只能处理参数，不能读写函数以外的任何东西</li>
</ul>
</li>
</ol>
<p>合约调用者地址
address owner = msg.sender;
address payable // 可转账合约地址</p>
<h3 id="地址和地址相关操作"><a class="header" href="#地址和地址相关操作">地址和地址相关操作</a></h3>
<p><code>address</code> 合约地址&amp;外部账户地址</p>
<ul>
<li>balacne : 地址余额</li>
<li>transfer : 转账 ，将当前合约余额转给调用者 ex:</li>
</ul>
<pre><code class="language-js">contract TestTransfer{
    address addr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
    function trans() public {
        payable(addr).transfer(3*10**18);
    }   
}
</code></pre>
<h2 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h2>
<blockquote>
<p>Warning: Visibility for constructor is ignored. If you want the contract to be non-deployable, making it "abstract" is sufficient.</p>
</blockquote>
<p>合约构造方法添加了错误的可见性修饰符，比如 public</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="智能合约-编辑器--remix-ide"><a class="header" href="#智能合约-编辑器--remix-ide">智能合约 编辑器  remix-ide</a></h3>
<ol>
<li>
<p>在线编辑，对网络有要求，在线地址</p>
<blockquote>
<p>https://remix.ethereum.org/</p>
</blockquote>
</li>
<li>
<p>离线编辑,docker down镜像</p>
<pre><code class="language-shell">docker pull remixproject/remix-ide:latest
docker run -p 8080:80 remixproject/remix-ide:latest

or 
docker pull remixproject/remix-ide:remix_live
docker run -p 8080:80 remixproject/remix-ide:remix_live
</code></pre>
<p>浏览器运行 localhost:8080，就可以用 <code>solidity</code> 编写智能合约了</p>
</li>
<li>
<p>remix-project 连接本地文件夹：</p>
</li>
</ol>
<ul>
<li>安装remixd
<blockquote>
<p>npm install -g @remix-project/remixd</p>
</blockquote>
</li>
<li>连接
<blockquote>
<p>remixd -s d:/workspace -u http://localhost:8080</p>
</blockquote>
</li>
</ul>
<h3 id="没有编译插件点击下图中-打叉的地方"><a class="header" href="#没有编译插件点击下图中-打叉的地方">没有编译插件,点击下图中 打叉的地方</a></h3>
<p><img src="blockchain//res/blockchain/remix_plugin.png" alt="插件" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="智能合约-编辑器--remix-ide-1"><a class="header" href="#智能合约-编辑器--remix-ide-1">智能合约 编辑器  remix-ide</a></h3>
<ol>
<li>
<p>在线编辑，对网络有要求，在线地址</p>
<blockquote>
<p>https://remix.ethereum.org/</p>
</blockquote>
</li>
<li>
<p>离线编辑,docker down镜像</p>
<pre><code class="language-shell">docker pull remixproject/remix-ide:latest
docker run -p 8080:80 remixproject/remix-ide:latest
</code></pre>
<p>浏览器运行 localhost:8080，就可以用 <code>solidity</code> 编写智能合约了</p>
</li>
<li>
<p>remix-project 连接本地文件夹：</p>
</li>
</ol>
<ul>
<li>
<p>安装remixd</p>
<blockquote>
<p>npm install -g @remix-project/remixd</p>
</blockquote>
</li>
<li>
<p>连接</p>
<blockquote>
<p>remixd -s d:/workspace -u http://localhost:8080
address public owner;</p>
</blockquote>
<p>function getOwner() public {
owner = msg.sender;
}</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="启动geth客户端geth-创建账户转账"><a class="header" href="#启动geth客户端geth-创建账户转账">启动geth客户端，geth 创建账户，转账</a></h3>
<p>示例：</p>
<blockquote>
<p>geth --ropsten --syncmode snap --identity "smallc" --http --http.port 7545 --http.api "db,eth,net,web3,personal" --datadir "ropsten"</p>
</blockquote>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody>
<tr><td>removedb</td><td>asdf</td></tr>
<tr><td>account</td><td>Manage accounts</td></tr>
<tr><td>console</td><td>控制台命令行</td></tr>
</tbody></table>
</div>
<h3 id="启动参数说明"><a class="header" href="#启动参数说明">启动参数说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>--identity</td><td>节点身份标识</td></tr>
<tr><td>–networkid</td><td>我们创建的私有链的网络id</td></tr>
<tr><td>–datadir</td><td>节点的数据文件夹</td></tr>
<tr><td>–http</td><td>表示允许远程调用。这个参数以前叫rpc，后来在新版的Geth中改成http了，当然用rpc也可以，只不过这个参数很快就被丢弃了，还是早点改的好，这个可以在Geth的帮助中看到。</td></tr>
<tr><td>–http.port</td><td>表示允许远程调用的端口。默认是8545。这个参数以前是rpcport。</td></tr>
<tr><td>–http.addr</td><td>把这个值写成“0.0.0.0”表示允许远程访问，否则只能本地访问。这个参数以前是rpcaddr。</td></tr>
<tr><td>–port</td><td>表示网络监听端口，默认值是30303。</td></tr>
<tr><td>–http.corsdomain</td><td>允许跨域请求的域列表，这里指定为“*”。这个参数以前是rpccorsdomain</td></tr>
<tr><td>–http.api</td><td>允许远程调用的API，用逗号间隔，凡是列出来的，在远程调用时均可以使用。</td></tr>
<tr><td>–unlock</td><td>表示被解锁账户的编号，0表示node数据文件中第一个被创建的账户，这个账户被解锁才能使用该账户进行交易。</td></tr>
<tr><td>–password</td><td>表示解锁账户时的账户密码，就是在创建账户时输入的密码。</td></tr>
<tr><td>–allow-insecure-unlock</td><td>允许使用不安全的账户解锁</td></tr>
<tr><td>console</td><td>表示打开Geth JavaScript console</td></tr>
<tr><td>--syncmode</td><td>同步模式 <code>full</code>,<code>fast</code>,<code>light</code>,<code>snap</code>(新开发的功能，21年刚上线，快照同步模式，同步速度极快) <br/> # full geth --syncmode "full" <br/> # fast geth --syncmode "fast" <br/># light geth --syncmode "fast" <br/> snap  geth --syncmode "snap" (新开发的功能，21年刚上线，快照同步模式，同步速度极快)</td></tr>
</tbody></table>
</div>
<h2 id="api调用说明"><a class="header" href="#api调用说明">API调用说明</a></h2>
<h3 id="查看账户"><a class="header" href="#查看账户">查看账户</a></h3>
<blockquote>
<p>geth account list</p>
</blockquote>
<h3 id="创建账户"><a class="header" href="#创建账户">创建账户</a></h3>
<blockquote>
<p>geth account new</p>
</blockquote>
<h3 id="运行测试网络-ropsten"><a class="header" href="#运行测试网络-ropsten">运行测试网络 ropsten</a></h3>
<blockquote>
<p>geth --ropsten  --http --http.api net,web3,eth,personal --datadir ropsten_path</p>
</blockquote>
<h3 id=""><a class="header" href="#"></a></h3>
<h3 id="启动rpc接口"><a class="header" href="#启动rpc接口">启动rpc接口</a></h3>
<blockquote>
<p>geth --identity "smallc" --rpc --rpcport 7545 --rpcapi "db,eth,net,web3"</p>
</blockquote>
<p><code>--rpc</code> 已弃用</p>
<pre><code class="language-shell">geth --ropsten --syncmode snap --identity "smallc" --http --http.port 7545 --http.api "db,eth,net,web3,personal" --datadir "ropsten"
</code></pre>
<h3 id="导入账户"><a class="header" href="#导入账户">导入账户</a></h3>
<blockquote>
<p>geth --datadir .\ropsten\ account import .\ropsten\key.txt --password .\ropsten\password.txt</p>
</blockquote>
<ul>
<li><code>.\ropsten\key.txt</code>   其他钱包导出的私钥存放的文件</li>
<li><code>.\ropsten\password.txt</code> 密码存放文件</li>
</ul>
<h3 id="查看账户-1"><a class="header" href="#查看账户-1">查看账户</a></h3>
<blockquote>
<p>geth account list</p>
</blockquote>
<h3 id="创建账户-1"><a class="header" href="#创建账户-1">创建账户</a></h3>
<blockquote>
<p>geth account new</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="clef-以太坊账户管理"><a class="header" href="#clef-以太坊账户管理">clef 以太坊账户管理</a></h2>
<h3 id="创建账户-2"><a class="header" href="#创建账户-2">创建账户</a></h3>
<blockquote>
<p>clef newaccount --keystore geth-tutorial/keystore</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="创建私链"><a class="header" href="#创建私链">创建私链</a></h3>
<ol>
<li>创建账户</li>
</ol>
<blockquote>
<p>geth</p>
</blockquote>
<ol>
<li>初始化</li>
</ol>
<blockquote>
<p>geth --datadir smallc init genesis.json</p>
</blockquote>
<ol start="2">
<li>启动</li>
</ol>
<blockquote>
<p>geth --identity smallchain --http --http.api net,web3,eth,personal --datadir smallchain --mine --miner.threads 0 --http.corsdomain "*" --http.addr 0.0.0.0 console --networkid 666</p>
</blockquote>
<ul>
<li>miner.threads  线程数量,默认是0</li>
</ul>
<p>参数说明</p>
<blockquote>
<p>identity  //唯一标识，在众多节点中快速找到当前节点
networkid // 当前节点网络id</p>
</blockquote>
<h3 id="genesisjson"><a class="header" href="#genesisjson">genesis.json</a></h3>
<pre><code class="language-json">{   
    //64位随机数，用于挖矿，注意他和mixhash 的设置需要满足以太坊黄皮书的要求
    //直接用这个也可以
    "nonce":"0x0000000000000042",
     //与nonce 共同用于挖矿，注意他和mixhash 的设置需要满足以太坊黄皮书的要求
    "mixhash":"0x0000000000000000000000000000000000000000000000000000000000000000",
    //挖矿难度，你可以随意控制，这里设置的难度比较小
    "difficulty": "0x4000",
    //用来提前设置帐号的以太币数量，例：
    //"alloc": {
    //“0x0000000000000000000000000000000000000001”:{"balance":"10000000"},
    //"0x0000000000000000000000000000000000000002":{"balance":"20000000"}
    //},
    "alloc": {},
    //挖矿的账户，默认钱包地址，这里因为没有地址，所有全是0
    //后面运行geth 后创建新账户时，如果geth 发现没有地址，会默认将第一个账户地址设置为矿工帐号
    "coinbase":"0x0000000000000000000000000000000000000000",
    //创世块的时间戳
    "timestamp": "0x00",
    //上一个区块的Hash值，因为是创世块，前面没有，所以是0
    "parentHash":"0x0000000000000000000000000000000000000000000000000000000000000000",
    //附加信息，随便填文本或不填也行
    "extraData": "0x00000000",
    //gas 最高限制，以太坊运行交易，合约等消耗的gas最高限制，这里设置为最高
    "gaslimit":"0xffffffff",
    "config": {
        "chainId": 666, //链ID 随便起 和主链、测试连不同就OK，公链ID为1
        "homesteadBlock": 0,
        "eip150Block": 0,
        "eip155Block": 0,
        "eip158Block": 0,
        "byzantiumBlock": 0,
        "constantinopleBlock": 0,
        "petersburgBlock": 0,
        "istanbulBlock": 0
    },
}
</code></pre>
<h3 id="完整例子"><a class="header" href="#完整例子">完整例子</a></h3>
<pre><code class="language-json">{
    "config": {
        "chainId": 666,
        "homesteadBlock": 0,
        "eip150Block": 0,
        "eip155Block": 0,
        "eip158Block": 0,
        "byzantiumBlock": 0,
        "constantinopleBlock": 0,
        "petersburgBlock": 0,
        "istanbulBlock": 0
    },
    "alloc": {
        "aee29ddd94a36f6d3415310046863929a59e30be": { "balance": "100" }
    },
    "coinbase": "0x0000000000000000000000000000000000000000",
    "difficulty": "0x2000",
    "extraData": "",
    "gasLimit": "0x2fefd8",
    "nonce": "0x0000000000000042",
    "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "timestamp": "0x00"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="创建私链-1"><a class="header" href="#创建私链-1">创建私链</a></h3>
<ol>
<li>定位到数据目录</li>
</ol>
<blockquote>
<p>cd D:\workproject\blockchain\geth_data</p>
</blockquote>
<ol start="2">
<li>初始化</li>
</ol>
<blockquote>
<p>geth --datadir smallchain init genesis.json</p>
</blockquote>
<ol start="3">
<li></li>
</ol>
<blockquote>
<p>geth --datadir smallchain --http --http.api net,web3,db,personal --identity smallc --networkid 666 --corsdomain *</p>
</blockquote>
<pre><code class="language-json">//genesis.json
{
    "config": {
        "chainId": 77 //链ID 随便起 和主链、测试连不同就OK
    },
    "alloc": {
        "0xc7c4f9a0Cd0a3e45348c5ed8c3909C69aA9FA8fC": { "balance": "10000000000000000000000" } //创世块分配的账户及余额
    },
    "difficulty": "9000", //挖矿难度
    "gasLimit": "2100000" //汽油费
}


{
    "config": {
        "chainId": 123,
        "homesteadBlock": 0,
        "eip150Block": 0,
        "eip155Block": 0,
        "eip158Block": 0,
        "byzantiumBlock": 0,
        "constantinopleBlock": 0,
        "petersburgBlock": 0,
        "istanbulBlock": 0
    },
    "alloc": {},
    "coinbase": "0x0000000000000000000000000000000000000000",
    "difficulty": "0x2000",
    "extraData": "",
    "gasLimit": "0x2fefd8",
    "nonce": "0x0000000000000042",
    "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "timestamp": "0x00"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="以太坊转账"><a class="header" href="#以太坊转账">以太坊转账，</a></h3>
<blockquote>
<p>账户 --&gt; 账户 x
账户 --&gt; 合约 √
合约 --&gt; 账户 √</p>
</blockquote>
<p>1、打开控制台</p>
<p>F:\Geth&gt;geth --datadir "data" console</p>
<p>2、查看目前所拥有的账户列表</p>
<blockquote>
<p>eth.accounts</p>
</blockquote>
<p>["0xf4fb90bd8713491d62778d0a46f8f6b83b98ed91"]</p>
<p>3、新建账户</p>
<blockquote>
<p>personal.newAccount('123456')</p>
</blockquote>
<p>"0x1dfa2d1d645e45f5d77025f63b73c8efed9a8240"</p>
<p>4、查看目前所拥有的账户列表</p>
<blockquote>
<p>eth.accounts</p>
</blockquote>
<p>["0xf4fb90bd8713491d62778d0a46f8f6b83b98ed91", "0x1dfa2d1d645e45f5d77025f63b73c8</p>
<p>efed9a8240"]</p>
<p>5、查看账户余额</p>
<blockquote>
<p>eth.getBalance(eth.accounts[0])</p>
</blockquote>
<p>665000000000000000000</p>
<blockquote>
<p>eth.getBalance(eth.accounts[1])</p>
</blockquote>
<p>0</p>
<p>6、定义变量</p>
<blockquote>
<p>var acc1=eth.accounts[0]</p>
</blockquote>
<p>undefined</p>
<blockquote>
<p>acc1</p>
</blockquote>
<p>"0xf4fb90bd8713491d62778d0a46f8f6b83b98ed91"</p>
<blockquote>
<p>var acc2=eth.accounts[1]</p>
</blockquote>
<p>undefined</p>
<blockquote>
<p>acc2</p>
</blockquote>
<p>"0x1dfa2d1d645e45f5d77025f63b73c8efed9a8240"</p>
<p>7、转账</p>
<blockquote>
<p>eth.sendTransaction({from: acc1 , to: acc2, value: web3.toWei(10,"ether")})</p>
</blockquote>
<p>Error: authentication needed: password or unlock</p>
<p>    at web3.js:3143:20</p>
<p>    at web3.js:6347:15</p>
<p>    at web3.js:5081:36</p>
<p>    at <anonymous>:1:1</p>
<p>（账户被锁报错）</p>
<p>8、解锁账户</p>
<blockquote>
<p>personal.unlockAccount(acc1,"123456")</p>
</blockquote>
<p>true</p>
<p>9、转账</p>
<blockquote>
<p>eth.sendTransaction({from: acc1 , to: acc2, value: web3.toWei(10,"ether")})</p>
</blockquote>
<p>INFO [11-14|14:34:24.526] Setting new local account                address=0xF4f</p>
<p>b90bd8713491d62778D0a46f8F6B83b98Ed91</p>
<p>INFO [11-14|14:34:24.551] Submitted transaction                    fullhash=0x98</p>
<p>f8b9bfb5fbaf374c2d18b5c5691b2cfd1250a1cb76337a47146a2afbde8329 recipient=0x1DfA2</p>
<p>d1d645e45f5d77025f63b73C8eFeD9a8240</p>
<p>"0x98f8b9bfb5fbaf374c2d18b5c5691b2cfd1250a1cb76337a47146a2afbde8329"</p>
<p>10、查看账户余额</p>
<blockquote>
<p>eth.getBalance(acc1)</p>
</blockquote>
<p>665000000000000000000</p>
<blockquote>
<p>eth.getBalance(acc2)</p>
</blockquote>
<p>0</p>
<p>11、挖矿</p>
<blockquote>
<p>miner.start(1);admin.sleepBlocks(20);miner.stop();</p>
</blockquote>
<p>12、挖矿结束查看账户余额</p>
<blockquote>
<p>eth.getBalance(acc2)</p>
</blockquote>
<p>10000000000000000000</p>
<p>作者：赫灵
链接：https://www.jianshu.com/p/ceb31937ec00
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="智能合约转go代码"><a class="header" href="#智能合约转go代码">智能合约转go代码</a></h3>
<p>abigen --abi xx.abi --pkg packageName --type structName --out xx.go</p>
<ul>
<li>.abi 文件在remix 部署后就能拿到</li>
<li>.pkg 指定文件输出包名</li>
<li>type 指定合约结构体名称</li>
<li>out 指定输出go文件名称</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="智能合约的运行流程"><a class="header" href="#智能合约的运行流程">智能合约的运行流程</a></h3>
<ol>
<li>编写智能合约代码，并编译成字节码。</li>
<li>部署智能合约。过程是向“0”地址发送一笔带有智能合约字节码数据的交易，这个交易会生成该智能合约的地址，并将字节码存储在该地址下的状态树中。</li>
<li>执行智能合约（调用智能合约函数）。向智能合约地址发送一个交易，该交易携带被调用的智能合约函数信息及调用参数，携带的信息遵循ABI编码协议。</li>
<li>智能合约地址收到这样的调用合约函数的交易，首先会解码数据，根据结果查找到对应函数的入口，再传入参数执行该函数。</li>
<li>执行函数的过程是状态转换的过程，执行完成后会扣除调用者相应的Gas花费。</li>
<li>状态转换的过程会全网同步并被再次执行验证，确保执行结果一致，这样通过验证后的交易会记录到区块中，同时更新状态数据。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>运行geth 容器</li>
<li>运行remix容器</li>
<li>运行remixd，npm install remixd 连接本地solidity workspace</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="官网下载geth-客户端"><a class="header" href="#官网下载geth-客户端">官网下载geth 客户端</a></h3>
<p>geth 是由以太坊官方提供的 <code>go</code> 语言版本的客户端程序</p>
<h3 id="安装gcc--windows下安装-mingw-w64"><a class="header" href="#安装gcc--windows下安装-mingw-w64">安装gcc  windows下安装 mingw-w64</a></h3>
<h3 id="安装golang开发环境"><a class="header" href="#安装golang开发环境">安装golang开发环境</a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="最近在做一个-flutter-20-for-web-的项目在项目打开第一次运行的时候总是要等很久才能看到效果"><a class="header" href="#最近在做一个-flutter-20-for-web-的项目在项目打开第一次运行的时候总是要等很久才能看到效果">最近在做一个 Flutter 2.0 for Web 的项目，在项目打开第一次运行的时候，总是要等很久才能看到效果.</a></h2>
<h2 id="经过一番研究发现是-flutter-使用的一个渲染引擎-canvaskit-下载太慢导致的"><a class="header" href="#经过一番研究发现是-flutter-使用的一个渲染引擎-canvaskit-下载太慢导致的">经过一番研究发现是 Flutter 使用的一个渲染引擎 Canvaskit 下载太慢导致的.</a></h2>
<h3 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h3>
<h4 id="canvaskit-是一个-js-框架flutter-定义默认是从-httpsunpkgcom-去加载的在国内最好是改变这个地址让它通过镜像地址去加载"><a class="header" href="#canvaskit-是一个-js-框架flutter-定义默认是从-httpsunpkgcom-去加载的在国内最好是改变这个地址让它通过镜像地址去加载">Canvaskit 是一个 js 框架，Flutter 定义默认是从 https://unpkg.com 去加载的，在国内最好是改变这个地址，让它通过镜像地址去加载.</a></h4>
<h3 id="编译发布修改"><a class="header" href="#编译发布修改">编译发布修改</a></h3>
<p>在 {SDK_PATH}/bin/cache/flutter_web_sdk/lib/_engine/engine/canvaskit/initialization.dart 文件中有定义:</p>
<pre><code class="language-shell">/// The URL to use when downloading the CanvasKit script and associated wasm.
///
/// The expected directory structure nested under this URL is as follows:
///
///     /canvaskit.js              - the release build of CanvasKit JS API bindings
///     /canvaskit.wasm            - the release build of CanvasKit WASM module
///     /profiling/canvaskit.js    - the profile build of CanvasKit JS API bindings
///     /profiling/canvaskit.wasm  - the profile build of CanvasKit WASM module
///
/// The base URL can be overridden using the `FLUTTER_WEB_CANVASKIT_URL`
/// environment variable, which can be set in the Flutter tool using the
/// `--dart-define` option. The value must end with a `/`.
///
/// Example:
///
/// ```
/// flutter run \
///   -d chrome \
///   --web-renderer=canvaskit \
///   --dart-define=FLUTTER_WEB_CANVASKIT_URL=https://example.com/custom-canvaskit-build/
/// ```
///
/// When CanvasKit pushes a new release to NPM, update this URL to reflect the
/// most recent version. For example, if CanvasKit releases version 0.34.0 to
/// NPM, update this URL to `https://unpkg.com/canvaskit-wasm@0.34.0/bin/`.
const String canvasKitBaseUrl = String.fromEnvironment(
  'FLUTTER_WEB_CANVASKIT_URL',
  defaultValue: 'https://unpkg.com/canvaskit-wasm@0.24.0/bin/',
);
</code></pre>
<h3 id="意思是可以通过-flutter_web_canvaskit_url-这个环境变量改变默认的下载地址"><a class="header" href="#意思是可以通过-flutter_web_canvaskit_url-这个环境变量改变默认的下载地址">意思是可以通过 FLUTTER_WEB_CANVASKIT_URL 这个环境变量改变默认的下载地址.</a></h3>
<p>所以我们只要在 flutter 命令后面加上 --dart-define=FLUTTER_WEB_CANVASKIT_URL=https://cdn.jsdelivr.net/npm/canvaskit-wasm@0.24.0/bin/ 就可以了.</p>
<pre><code class="language-shell">flutter run -d chrome --dart-define=FLUTTER_WEB_CANVASKIT_URL=https://cdn.jsdelivr.net/npm/canvaskit-wasm@0.24.0/bin/ --release
</code></pre>
<h3 id="又经过一番折腾之后发现在本地运行或调试的时候使用的其实是-sdk_pathbincacheflutter_web_sdkkernelmodedart_sdkjs-里面的值"><a class="header" href="#又经过一番折腾之后发现在本地运行或调试的时候使用的其实是-sdk_pathbincacheflutter_web_sdkkernelmodedart_sdkjs-里面的值">又经过一番折腾之后，发现在本地运行或调试的时候使用的其实是 {SDK_PATH}/bin/cache/flutter_web_sdk/kernel/{MODE}/dart_sdk.js 里面的值:</a></h3>
<pre><code class="language-js">/*_engine.canvasKitBaseUrl*/
get canvasKitBaseUrl() {
  return "https://unpkg.com/canvaskit-wasm@0.24.0/bin/";
},
</code></pre>
<h3 id="这些值被固定成-httpsunpkgcomcanvaskit-wasm0240bin-经过验证只要改掉里面的地址运行模式也能走我们改掉后的镜像地址了但是呢这些文件为了匹配不同的环境所以有很多个并且每个文件都很长很巨大我用-idea-编辑一度内存溢出报警于是写了个-shell-脚本来帮助修改"><a class="header" href="#这些值被固定成-httpsunpkgcomcanvaskit-wasm0240bin-经过验证只要改掉里面的地址运行模式也能走我们改掉后的镜像地址了但是呢这些文件为了匹配不同的环境所以有很多个并且每个文件都很长很巨大我用-idea-编辑一度内存溢出报警于是写了个-shell-脚本来帮助修改">这些值被固定成 https://unpkg.com/canvaskit-wasm@0.24.0/bin/, 经过验证只要改掉里面的地址，运行模式也能走我们改掉后的镜像地址了.但是呢，这些文件为了匹配不同的环境所以有很多个，并且每个文件都很长很巨大，我用 IDEA 编辑一度内存溢出报警，于是写了个 Shell 脚本来帮助修改:</a></h3>
<pre><code class="language-shell">#!/bin/bash
 
export flutter_path=$(which flutter)
export flutter_web_sdk_folder=${flutter_path%flutter}cache/flutter_web_sdk
 
if [ ! -d $flutter_web_sdk_folder ]; then
  echo Flutter web sdk folder not found!
  read -n1 -p "Press any key to exit..."
  exit
fi
 
echo Find flutter web sdk folder: 
echo $flutter_web_sdk_folder
echo
read -n1 -p "Press any key to continue..."
 
echo "Start performing the replacement..."
find $flutter_web_sdk_folder/kernel -name dart_sdk.js | xargs sed -i 's?//unpkg.com/?//cdn.jsdelivr.net/npm/?g'
echo "Complete replacement!"
read -n1 -p "Press any key to exit..."
</code></pre>
<h3 id="将上面的内容保存为-sh-脚本文件unix-系统可以使用终端直接运行windows-系统可以使用-git-的-bash-运行-正常情况下这段脚本会自动找到-flutter-sdk-中-flutter-web-sdk-目录下的-kernel-子目录下所有的-dart_sdkjs-并将原本的-unpkgcom-替换为-cdnjsdelivrnetnpm-实现依赖加速的目的"><a class="header" href="#将上面的内容保存为-sh-脚本文件unix-系统可以使用终端直接运行windows-系统可以使用-git-的-bash-运行-正常情况下这段脚本会自动找到-flutter-sdk-中-flutter-web-sdk-目录下的-kernel-子目录下所有的-dart_sdkjs-并将原本的-unpkgcom-替换为-cdnjsdelivrnetnpm-实现依赖加速的目的">将上面的内容保存为 sh 脚本文件，Unix 系统可以使用终端直接运行，Windows 系统可以使用 Git 的 bash 运行. 正常情况下这段脚本会自动找到 Flutter SDK 中 Flutter Web SDK 目录下的 kernel 子目录下所有的 dart_sdk.js, 并将原本的 //unpkg.com/ 替换为 //cdn.jsdelivr.net/npm/, 实现依赖加速的目的.</a></h3>
<h2 id="其他的镜像源"><a class="header" href="#其他的镜像源">其他的镜像源</a></h2>
<h3 id="知乎"><a class="header" href="#知乎">知乎</a></h3>
<pre><code>--dart-define=FLUTTER_WEB_CANVASKIT_URL=https://unpkg.zhimg.com/canvaskit-wasm@0.24.0/bin/
</code></pre>
<h3 id="饿了么"><a class="header" href="#饿了么">饿了么</a></h3>
<pre><code>--dart-define=FLUTTER_WEB_CANVASKIT_URL=https://npm.elemecdn.com/canvaskit-wasm@0.24.0/bin/
</code></pre>
<h3 id="jsdelivr"><a class="header" href="#jsdelivr">jsDelivr</a></h3>
<pre><code>--dart-define=FLUTTER_WEB_CANVASKIT_URL=https://cdn.jsdelivr.net/npm/canvaskit-wasm@0.24.0/bin/
</code></pre>
<p>————————————————
版权声明：本文为CSDN博主「Amoour」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35867494/article/details/118516893</p>
<p>flutter run -d chrome --dart-define=FLUTTER_WEB_CANVASKIT_URL=https://npm.elemecdn.com/canvaskit-wasm@0.24.0/bin/ --release --web-port=8080 --web-hostname=127.0.0.1</p>
<p>flutter build web --release --dart-define=FLUTTER_WEB_CANVASKIT_URL=https://npm.elemecdn.com/canvaskit-wasm@0.24.0/bin/</p>
<div style="break-before: page; page-break-before: always;"></div><p>自定义画板,canvas</p>
<blockquote>
<p>drawImageRect函数使用<br />
drawImageRect(Image image, Rect src, Rect dst, Paint paint)</p>
</blockquote>
<p>image: 传入图片<br />
src: 这里相当于画布的前景，这里是将给定大小的src，绘制到指定的dst矩形上面去<br />
dst: 这里相当于画布，用来绘制src</p>
<pre><code class="language-dart">  @override
  void paint(Canvas canvas, Size size) {
    if (image != null) {
      canvas.clipPath(Path()
        ..moveTo(0 + dx, 0 + dy)
        ..lineTo(scan + dx, 0 + dy)
        ..lineTo(scan + dx, scan + dy)
        ..lineTo(0 + dx, scan + dy));
      var imgh = size.width / (image.width / image.height);

      print('最终取值：$image,$imgh');
      print("size : $size");
      //绘制矩形，4个参数：
      canvas.drawImageRect(
          image,
          Rect.fromLTRB(0.0, 0.0, image.width.toDouble(), image.height.toDouble()),
          Rect.fromLTRB(0, 0, size.width, imgh),
          _paint);
    }
  }
</code></pre>
<p>最终效果就是下面这样了，具体需要自己体会一下：
<img src="flutter//res/flutter/drawimage.jpg" alt="x" /></p>
<p>参考文章：https://www.jianshu.com/p/84bf680106be</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="flutter-webview-访问url"><a class="header" href="#flutter-webview-访问url">flutter webview 访问url</a></h3>
<pre><code class="language-dart"> Future&lt;void&gt; launcherURL() async {
    // Uri uri = Uri(scheme: 'http',host: 'www.baidu.com');
    Uri url = Uri.parse('https://www.baidu.com');
    if (!await launchUrl(
      url,
      mode: LaunchMode.inAppWebView,
      webViewConfiguration: const WebViewConfiguration(enableJavaScript: true),
    )) {
      throw 'Could not launch $url';
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用库展示"><a class="header" href="#常用库展示">常用库展示</a></h1>
<ol>
<li>http</li>
</ol>
<pre><code class="language-dart">  _get() async {
    var url = 'www.zouni.vip';
    // Await the http get response, then decode the json-formatted response.
    var response = await get(url);
    if (response.statusCode == 200) {
      var res = response.body.toString();
      print('Number of books about http: $res');
    } else {
      print('Request failed with status: $ {response.statusCode}.');
    }
  }
</code></pre>
<ol start="2">
<li>url_launcher;</li>
</ol>
<pre><code class="language-dart"> _launchURL() async {
    const url = 'https://flutter.dev';
    if (await canLaunch(url)) {
      await launch(url);
    } else {
      throw 'Could not launch $url';
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>参考文章：
https://blog.csdn.net/tianhai110/article/details/2203572
https://www.jianshu.com/p/8f82db9556d2</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="常用快捷键"><a class="header" href="#常用快捷键">常用快捷键</a></h3>
<ol>
<li>创建项目：<code>ctrl</code>+<code>shift</code>+<code>P</code></li>
<li>代码提示：<code>ctrl</code>+<code>I</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新建flutter-module"><a class="header" href="#新建flutter-module">新建flutter module</a></h1>
<h2 id="1-module-的-settingsgradle-"><a class="header" href="#1-module-的-settingsgradle-">1. module 的 <code>settings.gradle</code> ：</a></h2>
<pre><code>// Generated file. Do not edit.
include ':app'
//复制下面内容到主项目的 settings.gradle 中
rootProject.name = 'android_generated'
setBinding(new Binding([gradle: this]))
//这里模块名称修改成自己的，参考下图
evaluate(new File(settingsDir, 'include_flutter.groovy'))
</code></pre>
<p>效果：
<img src="flutter/1.setup//res/flutter/flutter_2.png" alt="settings" /></p>
<h2 id="2-引入依赖-在工程appbuildgradle-中"><a class="header" href="#2-引入依赖-在工程appbuildgradle-中">2. 引入依赖 在工程app/build.gradle 中：</a></h2>
<pre><code>dependencies {
  implementation project(':flutter')
}
</code></pre>
<h2 id="3-编译运行失败"><a class="header" href="#3-编译运行失败">3. 编译运行：失败</a></h2>
<h3 id="caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin"><a class="header" href="#caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin">Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin class 'FlutterPlugin'.</a></h3>
<p>这是一个非常不明所以的问题：android 集成flutter module时，按照官网说明完毕必会出现</p>
<p>病根：参照下面<code>settings.gradle</code>文件</p>
<pre><code class="language-groovy">pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}
dependencyResolutionManagement {
    // 1. 这里改动 替换成了下面一行
//    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)
    repositories {
        google()
        mavenCentral()
//        jcenter() // Warning: this repository is going to shut down soon
    // 2. 增加下面4行
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
    }
}
rootProject.name = "Flutter_Android"
include ':app'


setBinding(new Binding([gradle: this]))
evaluate(new File(settingsDir.parentFile, 'flutter_module2/.android/include_flutter.groovy'))

</code></pre>
<h2 id="4-重新编译运行成功"><a class="header" href="#4-重新编译运行成功">4. 重新编译运行，成功</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flutter-20-已经正式支持了web不需要用下面方式单独启用web开发支持"><a class="header" href="#flutter-20-已经正式支持了web不需要用下面方式单独启用web开发支持">flutter 2.0 已经正式支持了web，不需要用下面方式单独启用web开发支持</a></h2>
<h3 id="flutter-web-开发"><a class="header" href="#flutter-web-开发">flutter web 开发</a></h3>
<ol>
<li>
<p>开启<code>web</code>支持 (正式版默认启用)</p>
<blockquote>
<p>flutter config --enable-web</p>
</blockquote>
</li>
<li>
<p>再次 执行环境检查</p>
<blockquote>
<p>flutter doctor</p>
</blockquote>
</li>
<li>
<p>一切正常之后,正常创建项目，会多出一个<code>web</code>文件夹</p>
<p>以前旧的项目可以执行以下命令：</p>
<blockquote>
<p>flutter create .</p>
</blockquote>
</li>
<li>
<p>运行在浏览器看下效果：</p>
<blockquote>
<p>flutter run -d edge</p>
</blockquote>
<p>我这里用的 microsoft edge 浏览器</p>
</li>
<li>
<p>打包</p>
<blockquote>
<p>flutter build web</p>
</blockquote>
<blockquote>
<p>flutter build web --release  //生产环境打包</p>
</blockquote>
<p>可以看到 <code>build</code> 目录下多出一个<strong>web</strong> 文件夹</p>
</li>
</ol>
<h1 id="flutter-web-常见问题"><a class="header" href="#flutter-web-常见问题">flutter web 常见问题</a></h1>
<p><strong>Finished with error: Failed to bind web development server:SocketException: Failed to create server socket (OS Error: Failed to start accept), address = localhost, port = 53041</strong></p>
<p>浏览器运行失败</p>
<p>解决方法：配置启动参数或者关闭ipv6网络属性</p>
<pre><code class="language-shell">flutter run -d chrome --web-port=8080 --web-hostname=127.0.0.1
</code></pre>
<p>或者在android studio运行环境中配置:</p>
<pre><code class="language-shell">--web-port=8080 --web-hostname=127.0.0.1
</code></pre>
<p>vscode 配置启动参数：</p>
<pre><code class="language-json">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "flutter_app",
            "request": "launch",
            "type": "dart",
            "args": [
                "--web-port=8080",
                "--web-hostname=127.0.0.1"
            ]
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-for-windows-环境配置"><a class="header" href="#flutter-for-windows-环境配置">flutter for windows 环境配置</a></h1>
<ol>
<li>开启 flutter for windows</li>
</ol>
<pre><code>flutter config --enable-windows-desktop
</code></pre>
<ol start="2">
<li>下载 visual studio 社区版本  安装过程如下所示：</li>
</ol>
<p><img src="flutter/1.setup//res/flutter/visual_studio.png" alt="安装过程" />
3. 运行flutter doctor，没有问题的话，就完成了环境配置
4. 运行，打完收工</p>
<p><img src="flutter/1.setup//res/flutter/login.png" alt="登录" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-初体验"><a class="header" href="#flutter-初体验">flutter 初体验</a></h1>
<h2 id="1-下载flutter-sdk"><a class="header" href="#1-下载flutter-sdk">1. 下载flutter sdk</a></h2>
<h2 id="2-配置环境变量"><a class="header" href="#2-配置环境变量">2. 配置环境变量</a></h2>
<pre><code>E:\WorkRoom\android\flutter\flutter\bin
添加到path中
</code></pre>
<p>运行命令：</p>
<pre><code>flutter doctor
</code></pre>
<p><img src="flutter/1.setup//res/flutter/flutter_1.png" alt="doctor" /></p>
<h3 id="这一步有可能卡在-running-pub-upgrade-解决办法"><a class="header" href="#这一步有可能卡在-running-pub-upgrade-解决办法">这一步有可能卡在 <code>Running pub upgrade...</code> <strong>解决办法：</strong></a></h3>
<pre><code class="language-shell"># 配置环境变量，国内镜像
PUB_HOSTED_URL=https://pub.flutter-io.cn
FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
</code></pre>
<p>许可证的问题，not accepted,那就让他ok，根据提示输入命令：</p>
<pre><code>flutter doctor --android-licenses

</code></pre>
<p>一路yes到底，最后再检查一次就 ok 了
<img src="flutter/1.setup//res/flutter/flutter_ok.png" alt="doctor" /></p>
<h2 id="3-配置ide"><a class="header" href="#3-配置ide">3. 配置IDE</a></h2>
<p>vscode 配置 ：搜索 安装<code>flutter</code>插件<br />
android studio : 安装flutter插件</p>
<blockquote>
<p>接着运行 flutter doctor</p>
</blockquote>
<p>手动更新依赖包：</p>
<ul>
<li>flutter packages get</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-running-gradle-task-assembledebug"><a class="header" href="#1-running-gradle-task-assembledebug">1. Running Gradle task 'assembleDebug'...</a></h2>
<p>===============================================</p>
<p>卡在 Running Gradle task 'assembleDebug'... 不动</p>
<p>解决方案：</p>
<ol>
<li>检查 ./gradle 是否下载成功</li>
<li>检查 <code>gradle</code> 默认代理是否正常<br />
<code>gradle</code> 配置文件默认在 <code>~/.gradle/gradle.properties</code>
注释掉下面几行代码即可：</li>
</ol>
<pre><code class="language-yaml"># Sun Jul 05 10:38:23 CST 2020
# systemProp.http.proxyHost=127.0.0.1
# systemProp.http.proxyPort=50030
# systemProp.https.proxyHost=127.0.0.1
# systemProp.https.proxyPort=50030
</code></pre>
<h2 id="2-flutter-doctor-异常"><a class="header" href="#2-flutter-doctor-异常">2. flutter doctor 异常</a></h2>
<p>====================================
android sdk platforms 下载失败
检查网络代理，是否能正常访问 https://dl.google.com</p>
<h2 id="3-caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin"><a class="header" href="#3-caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin">3. Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin class 'FlutterPlugin'.</a></h2>
<p>这是一个非常不明所以的问题：android 集成flutter module时，按照官网说明完毕必会出现</p>
<h2 id="4-非空检查相关异常error-cannot-run-with-sound-null-safety-because-the-following-dependencies"><a class="header" href="#4-非空检查相关异常error-cannot-run-with-sound-null-safety-because-the-following-dependencies">4. 非空检查相关异常：Error: Cannot run with sound null safety, because the following dependencies</a></h2>
<blockquote>
<p>flutter run --no-sound-null-safety</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>dart异步：
dart是单线程模型，任何耗时操作都会阻塞；通过返回一个Future来接收耗时任务返回结果：future.then();</p>
<pre><code class="language-dart">import 'dart:io';

void main(List&lt;String&gt; args) {
  print("main方法开始执行");
  Future fu = testAsync("");
  fu.then(
    (value) =&gt; print("执行结果：${value}"),
  );
  //sleep(Duration(seconds: 2));
  print('main方法结束');
}

Future testAsync(args) async {
  print("开始执行异步方法");
  return Future(requestHttp);
  // print("异步任务结束");
}

String requestHttp() {
  sleep(Duration(seconds: 2));
  print("请求http结束");
  return "success";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="final和const区别"><a class="header" href="#final和const区别">final和const区别</a></h2>
<p><code>final</code>：修饰变量，初始化之后不可改变值</p>
<blockquote>
<p>final name = 'zhangsan';</p>
</blockquote>
<p><code>const</code>：修饰常量</p>
<blockquote>
<p>const name = 'zhangsan';</p>
</blockquote>
<p>const常量值必须在编译期确定</p>
<pre><code class="language-dart">  var zhangsan = 12;
  var lisi = 13;
  const sum = zhangsan + lisi; //error
  final sum = zhangsan + lisi; //ok

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>dart异步：
dart是单线程模型，任何耗时操作都会阻塞；通过返回一个Future来接收耗时任务返回结果：future.then();</p>
<pre><code class="language-dart">import 'dart:io';

void main(List&lt;String&gt; args) {
  print("main方法开始执行");
  Future fu = testAsync("");
  fu.then(
    (value) =&gt; print("执行结果：${value}"),
  );
  //sleep(Duration(seconds: 2));
  print('main方法结束');
}

Future testAsync(args) async {
  print("开始执行异步方法");
  return Future(requestHttp);
  // print("异步任务结束");
}

String requestHttp() {
  sleep(Duration(seconds: 2));
  print("请求http结束");
  return "success";
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="final和const区别-1"><a class="header" href="#final和const区别-1">final和const区别</a></h2>
<p><code>final</code>：修饰变量，初始化之后不可改变值</p>
<blockquote>
<p>final name = 'zhangsan';</p>
</blockquote>
<p><code>const</code>：修饰常量</p>
<blockquote>
<p>const name = 'zhangsan';</p>
</blockquote>
<p>const常量值必须在编译期确定</p>
<pre><code class="language-dart">  var zhangsan = 12;
  var lisi = 13;
  const sum = zhangsan + lisi; //error
  final sum = zhangsan + lisi; //ok

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新建flutter-module-1"><a class="header" href="#新建flutter-module-1">新建flutter module</a></h1>
<h2 id="1-module-的-settingsgradle--1"><a class="header" href="#1-module-的-settingsgradle--1">1. module 的 <code>settings.gradle</code> ：</a></h2>
<pre><code>// Generated file. Do not edit.
include ':app'
//复制下面内容到主项目的 settings.gradle 中
rootProject.name = 'android_generated'
setBinding(new Binding([gradle: this]))
//这里模块名称修改成自己的，参考下图
evaluate(new File(settingsDir, 'include_flutter.groovy'))
</code></pre>
<p>效果：
<img src="flutter/setup//res/flutter/flutter_2.png" alt="settings" /></p>
<h2 id="2-引入依赖-在工程appbuildgradle-中-1"><a class="header" href="#2-引入依赖-在工程appbuildgradle-中-1">2. 引入依赖 在工程app/build.gradle 中：</a></h2>
<pre><code>dependencies {
  implementation project(':flutter')
}
</code></pre>
<h2 id="3-编译运行失败-1"><a class="header" href="#3-编译运行失败-1">3. 编译运行：失败</a></h2>
<h3 id="caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin-1"><a class="header" href="#caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin-1">Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin class 'FlutterPlugin'.</a></h3>
<p>这是一个非常不明所以的问题：android 集成flutter module时，按照官网说明完毕必会出现</p>
<p>病根：参照下面<code>settings.gradle</code>文件</p>
<pre><code class="language-groovy">pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}
dependencyResolutionManagement {
    // 1. 这里改动 替换成了下面一行
//    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)
    repositories {
        google()
        mavenCentral()
//        jcenter() // Warning: this repository is going to shut down soon
    // 2. 增加下面4行
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
    }
}
rootProject.name = "Flutter_Android"
include ':app'


setBinding(new Binding([gradle: this]))
evaluate(new File(settingsDir.parentFile, 'flutter_module2/.android/include_flutter.groovy'))

</code></pre>
<h2 id="4-重新编译运行成功-1"><a class="header" href="#4-重新编译运行成功-1">4. 重新编译运行，成功</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flutter-20-已经正式支持了web不需要用下面方式单独启用web开发支持-1"><a class="header" href="#flutter-20-已经正式支持了web不需要用下面方式单独启用web开发支持-1">flutter 2.0 已经正式支持了web，不需要用下面方式单独启用web开发支持</a></h2>
<h3 id="flutter-web-开发-1"><a class="header" href="#flutter-web-开发-1">flutter web 开发</a></h3>
<ol>
<li>
<p>开启<code>web</code>支持 (正式版默认启用)</p>
<blockquote>
<p>flutter config --enable-web</p>
</blockquote>
</li>
<li>
<p>再次 执行环境检查</p>
<blockquote>
<p>flutter doctor</p>
</blockquote>
</li>
<li>
<p>一切正常之后,正常创建项目，会多出一个<code>web</code>文件夹</p>
<p>以前旧的项目可以执行以下命令：</p>
<blockquote>
<p>flutter create .</p>
</blockquote>
</li>
<li>
<p>运行在浏览器看下效果：</p>
<blockquote>
<p>flutter run -d edge</p>
</blockquote>
<p>我这里用的 microsoft edge 浏览器</p>
</li>
<li>
<p>打包</p>
<blockquote>
<p>flutter build web</p>
</blockquote>
<blockquote>
<p>flutter build web --release  //生产环境打包</p>
</blockquote>
<p>可以看到 <code>build</code> 目录下多出一个<strong>web</strong> 文件夹</p>
</li>
</ol>
<h1 id="flutter-web-常见问题-1"><a class="header" href="#flutter-web-常见问题-1">flutter web 常见问题</a></h1>
<p><strong>Finished with error: Failed to bind web development server:SocketException: Failed to create server socket (OS Error: Failed to start accept), address = localhost, port = 53041</strong></p>
<p>浏览器运行失败</p>
<p>解决方法：配置启动参数或者关闭ipv6网络属性</p>
<pre><code class="language-shell">flutter run -d chrome --web-port=8080 --web-hostname=127.0.0.1
</code></pre>
<p>或者在android studio运行环境中配置:</p>
<pre><code class="language-shell">--web-port=8080 --web-hostname=127.0.0.1
</code></pre>
<p>vscode 配置启动参数：</p>
<pre><code class="language-json">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "flutter_app",
            "request": "launch",
            "type": "dart",
            "args": [
                "--web-port=8080",
                "--web-hostname=127.0.0.1"
            ]
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-for-windows-环境配置-1"><a class="header" href="#flutter-for-windows-环境配置-1">flutter for windows 环境配置</a></h1>
<ol>
<li>开启 flutter for windows</li>
</ol>
<pre><code>flutter config --enable-windows-desktop
</code></pre>
<ol start="2">
<li>下载 visual studio 社区版本  安装过程如下所示：</li>
</ol>
<p><img src="flutter/setup//res/flutter/visual_studio.png" alt="安装过程" />
3. 运行flutter doctor，没有问题的话，就完成了环境配置
4. 运行，打完收工</p>
<p><img src="flutter/setup//res/flutter/login.png" alt="登录" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-初体验-1"><a class="header" href="#flutter-初体验-1">flutter 初体验</a></h1>
<h2 id="1-下载flutter-sdk-1"><a class="header" href="#1-下载flutter-sdk-1">1. 下载flutter sdk</a></h2>
<h2 id="2-配置环境变量-1"><a class="header" href="#2-配置环境变量-1">2. 配置环境变量</a></h2>
<pre><code>E:\WorkRoom\android\flutter\flutter\bin
添加到path中
</code></pre>
<p>运行命令：</p>
<pre><code>flutter doctor
</code></pre>
<p><img src="flutter/setup//res/flutter/flutter_1.png" alt="doctor" /></p>
<h3 id="这一步有可能卡在-running-pub-upgrade-解决办法-1"><a class="header" href="#这一步有可能卡在-running-pub-upgrade-解决办法-1">这一步有可能卡在 <code>Running pub upgrade...</code> <strong>解决办法：</strong></a></h3>
<pre><code class="language-shell"># 配置环境变量，国内镜像
PUB_HOSTED_URL=https://pub.flutter-io.cn
FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
</code></pre>
<p>许可证的问题，not accepted,那就让他ok，根据提示输入命令：</p>
<pre><code>flutter doctor --android-licenses

</code></pre>
<p>一路yes到底，最后再检查一次就 ok 了
<img src="flutter/setup//res/flutter/flutter_ok.png" alt="doctor" /></p>
<h2 id="3-配置ide-1"><a class="header" href="#3-配置ide-1">3. 配置IDE</a></h2>
<p>vscode 配置 ：搜索 安装<code>flutter</code>插件<br />
android studio : 安装flutter插件</p>
<blockquote>
<p>接着运行 flutter doctor</p>
</blockquote>
<p>手动更新依赖包：</p>
<ul>
<li>flutter packages get</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-gradle-task-assembledebug-1"><a class="header" href="#running-gradle-task-assembledebug-1">Running Gradle task 'assembleDebug'...</a></h1>
<p>卡在 Running Gradle task 'assembleDebug'... 不动</p>
<p>解决方案：</p>
<ol>
<li>检查 ./gradle 是否下载成功</li>
<li>检查 <code>gradle</code> 默认代理是否正常<br />
<code>gradle</code> 配置文件默认在 <code>~/.gradle/gradle.properties</code>
注释掉下面几行代码即可：</li>
</ol>
<pre><code class="language-yaml"># Sun Jul 05 10:38:23 CST 2020
# systemProp.http.proxyHost=127.0.0.1
# systemProp.http.proxyPort=50030
# systemProp.https.proxyHost=127.0.0.1
# systemProp.https.proxyPort=50030
</code></pre>
<h1 id="flutter-doctor-异常"><a class="header" href="#flutter-doctor-异常">flutter doctor 异常</a></h1>
<p>android sdk platforms 下载失败
检查网络代理，是否能正常访问 https://dl.google.com</p>
<h1 id="caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin-2"><a class="header" href="#caused-by-orggradleapiinternalpluginspluginapplicationexception-failed-to-apply-plugin-class-flutterplugin-2">Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin class 'FlutterPlugin'.</a></h1>
<p>这是一个非常不明所以的问题：android 集成flutter module时，按照官网说明完毕必会出现</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><p>CGO需要安装<code>gcc</code><br />
windows安装mingw-w64<br />
<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/">下载</a><br />
https://sourceforge.net/projects/mingw-w64/files/mingw-w64/<br />
两种方式：</p>
<ol>
<li>下载exe可执行文件，交给程序下载安装，网络不好很大概率会一直失败</li>
<li>直接下载压缩包解压，然后配置环境变量即可。(推荐)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><pre><code>mkdir /lib64
ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="golang-配置环境"><a class="header" href="#golang-配置环境">golang 配置环境</a></h3>
<p>不通架构运行可能出现  不能运行的问题</p>
<pre><code>-ash: ./alidns: cannot execute binary file: Exec format error
</code></pre>
<p>这种情况要根据当前运行环境决定修改 go env参数</p>
<p><code>GOARCH</code>&amp; <code>GOOS</code></p>
<pre><code class="language-shell">go env -w GOOS= linux 
# 这里GOARCH 分为  amd64  arm64  根据个人环境决定
go env -w GOARCH=amd64
go env -w GOARCh=arm64
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Help-&gt;Edit Custom VM Options...在开打文件中添加参数-Dfile.encoding=UTF-8</p>
<p><img src="golang//res/go/goland_set.png" alt="" /></p>
<p><img src="golang//res/go/goland_set_config.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>socket.io 配置到外网 服务器后，就会出现如下问题</p>
<pre><code>Error during WebSocket handshake: Unexpected response code: 400
</code></pre>
<p>，根据github的讨论，得到如下答案</p>
<pre><code>proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection "upgrade";
proxy_set_header Host $host;
</code></pre>
<p>其中第一行是告诉nginx使用HTTP/1.1通信协议，这是websoket必须要使用的协议。
第二行和第三行告诉nginx，当它想要使用WebSocket时，响应http升级请求。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<h3 id="1-配置好环境变量gopath-goroot"><a class="header" href="#1-配置好环境变量gopath-goroot">1. 配置好环境变量：GOPATH GOROOT</a></h3>
<p>GOROOT: GO安装目录<br />
GOPATH: 项目目录 src pkg bin目录</p>
<h3 id="2-安装go-开发工具集"><a class="header" href="#2-安装go-开发工具集">2. 安装go 开发工具集</a></h3>
<p><code>ctrl</code> + <code>shift</code> + <code>P</code> 打开命令面板，选择 <code>GO:Install/Update Tools</code></p>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<h3 id="go-run-test-不打印-详情"><a class="header" href="#go-run-test-不打印-详情">go run test 不打印 详情</a></h3>
<blockquote>
<p>go test -v # 正常命令应该是这样的，vscode 默认运行 不带-v
修改工作空间设置</p>
</blockquote>
<pre><code class="language-json">{
    "go.inferGopath": false,
    "go.testFlags": ["-v"],  //增加这一行
}
</code></pre>
<p>再运行就正常了。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="golang内网环境配置"><a class="header" href="#golang内网环境配置">golang内网环境配置</a></h3>
<p><code>goroot</code>: 就是golang的安装地址<br />
<code>gopath</code>: 一般存放项目的目录 exp: d:/workproject/go</p>
<p><code>pkg</code>: 第三方依赖<br />
<code>src</code>: 源代码，旧的项目管理必须源码放这里，modules没这个要求了<br />
<code>bin</code>: 编译好的二进制可执行文件</p>
<p>配置好gopath之后
GOPROXY=file:///D:/WorkProject/pkg/mod/cache/download;GOSUMDB=off</p>
<p>内网电脑必须关闭<code>GOSUMDB</code>,否则会联网校验包</p>
<pre><code class="language-shell">go env -w GOSUMDB=off
</code></pre>
<p>都设置好之后，<code>go get</code>命令就会从本地获取配置的<code>proxy仓库</code>项目依赖包</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="函数计算需要设置时区"><a class="header" href="#函数计算需要设置时区">函数计算需要设置时区</a></h3>
<p>添加环境变量即可：</p>
<blockquote>
<p>TZ = Asia/Shanghai</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th>名</th><th>地址</th><th>说明</th></tr></thead><tbody>
<tr><td>gogs</td><td>https://gogs.io/docs/</td><td>git代码管理，轻量，部署方便</td></tr>
<tr><td>memos</td><td>https://github.com/usememos/memos</td><td>备忘录</td></tr>
<tr><td>cobra</td><td>https://github.com/spf13/cobra</td><td>用于创建CLI命令行应用程序的工具</td></tr>
<tr><td>viper</td><td>https://github.com/spf13/viper</td><td></td></tr>
<tr><td>bubbletea</td><td>https://github.com/charmbracelet/bubbletea</td><td>一个go来构建TUI应用程序的工具,类似工具还有tview,termui</td></tr>
<tr><td>tview</td><td>https://github.com/rivo/tview</td><td>一个go来构建TUI应用程序的工具</td></tr>
<tr><td>termui</td><td>https://github.com/gizak/termui</td><td>一个go来构建TUI应用程序的工具</td></tr>
<tr><td>cron</td><td>https://github.com/robfig/cron</td><td>go定时器实现,支持cron表达式</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="安装环境配置环境变量"><a class="header" href="#安装环境配置环境变量">安装环境，配置环境变量</a></h3>
<pre><code>GOROOT:go安装路径
GOPATH: 项目目录
PATH ：%GOROOT%\bin;%GOPATH%\bin
</code></pre>
<h3 id="goland-配置环境"><a class="header" href="#goland-配置环境">GOland 配置环境</a></h3>
<p>https://github.com/goproxyio/goproxy
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct</p>
<pre><code># 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）
go env -w GOPRIVATE=*.corp.example.com

# 设置不走 proxy 的私有组织（可选）
go env -w GOPRIVATE=example.com/org_name
</code></pre>
<h3 id="go-moudle-初始化"><a class="header" href="#go-moudle-初始化">go moudle 初始化</a></h3>
<pre><code>go mod project_name
go build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-main-放哪里"><a class="header" href="#1-main-放哪里">1. main 放哪里？</a></h3>
<p>除了library库以外，main.go放在项目根目录下；
既有库又有二进制，可以把main放进cmd目录，非必须；</p>
<p>建议：主程序（CLI / server）放在仓库根目录的 main（或直接 main.go）是最简单也最常用的。</p>
<p>优势之一是安装/运行最短路径。</p>
<p>便于 go install：</p>
<h3 id="最短最干净的安装方式root-有-main"><a class="header" href="#最短最干净的安装方式root-有-main">最短最干净的安装方式（root 有 main）</a></h3>
<blockquote>
<p>go install github.com/eddycjy/project@latest</p>
</blockquote>
<p>示例（根目录有 main）：</p>
<pre><code class="language-go">/project
  go.mod
  main.go      // 程序入口
  lib/         // 如果你还有对外库
  internal/    // 可选
  README.md
</code></pre>
<p>或者把可复用代码放到一个清晰命名的包，而不是把 main 挪得过远。</p>
<h3 id="2-internal-是特性不是仪式"><a class="header" href="#2-internal-是特性不是仪式">2. internal/ 是特性不是仪式</a></h3>
<p>internal/ 的机制是 Go 工具链强制的：internal 下的代码只能被父目录（和子级树）里的包导入。</p>
<p>好处是可以阻止外部依赖，但不是每个项目都需要它。</p>
<p>这时候就涉及到什么时候用？</p>
<p>当你真的有很多对外不暴露但跨包复用的代码，并且项目会被大量第三方使用时才考虑 internal/。</p>
<p>对绝大多数小中型项目来说，不用 internal/ 更简单、更灵活。</p>
<p>示例（使用场景）：</p>
<pre><code class="language-go">/project
internal/
    secrets/   // 只有 project 内部可以 import
pkg/         // 对外可用库（慎用 pkg_/）
main.go
</code></pre>
<h3 id="3-别盲目使用-pkg"><a class="header" href="#3-别盲目使用-pkg">3. 别盲目使用 pkg/</a></h3>
<p>pkg/ 是历史遗留的惯例，在现代 Go 里没必要把所有对外包都塞进 pkg/。</p>
<p>包名与路径应以可读性与语义为核心。把包放到顶层（/auth、/db、/storage）通常更直观，且导入路径更短。</p>
<p>示例对比：</p>
<p>不推荐（多一层 pkg）：</p>
<pre><code>import "github.com/you/project/pkg/storage"
更推荐（语义清晰）：

import "github.com/you/project/storage"
</code></pre>
<h3 id="4-不要乱建-utilcommon-等"><a class="header" href="#4-不要乱建-utilcommon-等">4. 不要乱建 util、common 等</a></h3>
<p>“工具类” 包看起来方便，但会变成随手塞东西的垃圾仓库。把函数/类型放到语义化更强的包里，或放在最常用的使用位置邻近代码，而不是一个笼统的 util。</p>
<p>反面示例：</p>
<pre><code>// util/strings.go
package util
func Reverse(s string) string { ... }
更好写法（语义化）：

// text/reverse.go
package text
func Reverse(s string) string { ... }
</code></pre>
<p>// 或者直接放在使用它的包里，例如 handler/text_helpers.go</p>
<h3 id="5-包不要太多也别千行一包"><a class="header" href="#5-包不要太多也别千行一包">5. 包不要太多（也别千行一包）</a></h3>
<p>Go 可以在一个包里有多个文件，这一点要善用。每新增一个包，就可能增加依赖、回环风险和迁移成本。相反，也不要把完全不相关的代码塞成一个冗长的包——保持“以用途/语义分包”。</p>
<p>经验规则：</p>
<p>如果一组代码有同一语义与同一生命周期，放到同一个包。
每个包最好能在 200–1000 行范围内（这不是硬性规则，只是可读性提醒）。
切包优先按“用途”而不是“文件大小”。</p>
<h3 id="6-文件别太细碎"><a class="header" href="#6-文件别太细碎">6. 文件别太细碎</a></h3>
<p>许多人喜欢把每个小函数放不同文件，结果翻代码像翻书页。合理把相关函数聚合到同一文件，便于阅读。</p>
<p>避免把每个 tiny helper 分成独立文件。</p>
<h3 id="7-语义化命名优先于目录深度"><a class="header" href="#7-语义化命名优先于目录深度">7. 语义化命名优先于目录深度</a></h3>
<p>库名、包名与目录名应体现用途。例如 applog 比 util/log 更有意义。</p>
<p>这样看代码的同学通过 import 一眼能看出大致的用途。</p>
<h3 id="8-版本管理和-semver-建议"><a class="header" href="#8-版本管理和-semver-建议">8. 版本管理和 semver 建议</a></h3>
<p>建议尽量使用 0.x 阶段语义化版本（保守上 v0.x），在你要打破 API 时给出明确变更说明，而不是过早把版本固定为 v2/v3，导致用户为小改动分叉仓库。</p>
<p>换句话说：先发布、后演进，记录变更而不是封闭。</p>
<p>推荐的最小仓库模板（实战）
下面给出一个适合多数小中型项目的极简布局，能覆盖 CLI / library 混合场景：</p>
<pre><code>/project
go.mod
main.go             // 如果是二进制，把入口放这里
README.md
config/              // 配置相关包
storage/             // 存储逻辑
api/                 // HTTP handler / grpc / rpc
tools/               // 非构建、非导出的脚本 &amp; 工具（可忽略 go build）
docs/
</code></pre>
<p>如果你确实需要多个可发布包，再考虑增加清晰命名的子包，而不是 pkg/ 通用层。</p>
<p>Go 官方建议，要关注细节
Go 官方确实给了一份指南：go.dev/doc/modules/layout[1]。</p>
<p>里面有句话经常被曲解：</p>
<pre><code>Larger packages or commands may benefit from splitting… Initially, put them in internal/.
</code></pre>
<p>这里的重点其实是 larger 和 may。</p>
<p>结果很多人一上来就机械套用：不管项目大小，先建个 internal/；</p>
<p>现实是要知道目录不是 “一步到位” 的事，需要阶段性调整和设计。</p>
<p>总结
我们要回归 Go 的哲学：简单优先，先能跑，再优雅。多数团队在项目初期做的过度工程（把 internal/、pkg/、cmd/ 都直接套上）更多是为了 “看起来成熟”，但长期结果往往是维护负担增加。</p>
<p>把注意力放在清晰的包命名、合理的功能边界、良好的 README 上，必要时再重构目录结构和演进会比较好。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="私有仓库配置"><a class="header" href="#私有仓库配置">私有仓库配置</a></h3>
<p>将gitee.com 设置为私有仓库</p>
<ol>
<li>首先配置https请求转换为ssh:</li>
</ol>
<pre><code class="language-shell">git config --global url."git@gitee.com:".insteadOf "https://gitee.com/"

 git config --global http.extraheader "PRIVATE-TOKEN: B9TWLqsLdh1-513os1Pm"

git config --global url."git@192.168.200.47".insteadOf "http://192.168.200.47:8083/"
git config --global url."git@192.168.200.47".insteadOf "http://git.zhongzhuoxin.com:9000/"
</code></pre>
<ol start="2">
<li>
<p>配置环境变量
go env -w GOPRIVATE=gitee.com</p>
</li>
<li>
<p>新建的仓库名字一定要改成和<code>仓库地址一致</code></p>
</li>
</ol>
<ul>
<li>新建仓库 <code>gitee.com/zouni88/util</code></li>
<li>项目目录下 <code>go.mod</code> 修改<code>module</code>为<code>gitee.com/zouni88/util</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装环境配置环境变量-1"><a class="header" href="#安装环境配置环境变量-1">安装环境，配置环境变量</a></h3>
<pre><code>GOROOT:go安装路径
GOPATH: 项目目录
PATH ：%GOROOT%\bin;%GOPATH%\bin
</code></pre>
<h3 id="goland-配置环境-1"><a class="header" href="#goland-配置环境-1">GOland 配置环境</a></h3>
<p>https://github.com/goproxyio/goproxy
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct</p>
<pre><code># 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）
go env -w GOPRIVATE=*.corp.example.com

# 设置不走 proxy 的私有组织（可选）
go env -w GOPRIVATE=example.com/org_name
</code></pre>
<h3 id="go-moudle-初始化-1"><a class="header" href="#go-moudle-初始化-1">go moudle 初始化</a></h3>
<pre><code>go mod project_name
go build
</code></pre>
<h3 id="go-mod-引用本地项目"><a class="header" href="#go-mod-引用本地项目">go mod 引用本地项目</a></h3>
<ul>
<li>go mod edit -replace 项目名称=项目路径</li>
</ul>
<pre><code>go mod edit -replace testttt=/home/small/gopath/src/testttt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-int"><a class="header" href="#1-int">1. int</a></h3>
<h3 id="2-string"><a class="header" href="#2-string">2. string</a></h3>
<h3 id="3-float"><a class="header" href="#3-float">3. float</a></h3>
<h3 id="4-map"><a class="header" href="#4-map">4. map</a></h3>
<h3 id="5arrayslice"><a class="header" href="#5arrayslice">5.array,slice</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>进制转换：</p>
<pre><code class="language-golang">//十进制转二进制 八进制 十六进制
func TestBase2(t *testing.T) {
	a := strconv.FormatInt(15, 2)
	b := strconv.FormatInt(15, 8)
	c := strconv.FormatInt(15, 10)
	d := strconv.FormatInt(15, 16)
	log.Printf("base2 = %s,base8 = %s,base10 = %s,base16 = %s", a, b, c, d)
}
</code></pre>
<p>output:</p>
<pre><code class="language-golang">2022/03/23 15:05:26 base2 = 1111,base8 = 17,base10 = 15,base16 = f
--- PASS: TestBase2 (0.01s)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="fmtprintf"><a class="header" href="#fmtprintf">fmt.printf</a></h3>
<h4 id="常规格式化"><a class="header" href="#常规格式化">常规格式化</a></h4>
<ul>
<li>%v : 打印变量值</li>
<li>%T : 类型</li>
</ul>
<h4 id="整型"><a class="header" href="#整型">整型</a></h4>
<ul>
<li>%+d 带符号的整型，fmt.Printf("%+d", 255)输出+255</li>
<li>%q 打印单引号</li>
<li>%o 不带零的八进制</li>
<li>%#o 带零的八进制</li>
<li>%x 小写的十六进制</li>
<li>%X 大写的十六进制</li>
<li>%#x 带0x的十六进制</li>
<li>%U 打印Unicode字符</li>
<li>%#U 打印带字符的Unicode</li>
<li>%b 打印整型的二进制</li>
</ul>
<h4 id="float-浮点型"><a class="header" href="#float-浮点型">float 浮点型</a></h4>
<h4 id="string-字符串"><a class="header" href="#string-字符串">string 字符串</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h3 id="go中的异常处理机制"><a class="header" href="#go中的异常处理机制">go中的异常处理机制</a></h3>
<p>为了保证程序不会因为一个异常而导致停摆，同时又不像其它语言那么啰嗦，对go语言的异常机制的简单理解实践一下吧</p>
<pre><code class="language-go">package main

import "fmt"

func divide(a int,b int,isPanic bool) int  {
	//,类似于 java try catch ，，通过panic抛出异常 recover 捕获，
	if isPanic{
		defer func() {
			if err := recover(); err != nil{
				fmt.Println(err)
			}
		}()
	}
  //可以自行捕获异常,自定义异常信息
	/*if b==0{
		panic("除数不能等于0")
	}*/
	c := a/b
	return c
}

func main() {
	divide(3,0,true)
	fmt.Println("我的天，一切运转正常")
}

</code></pre>
<p>Out1:</p>
<pre><code>runtime error: integer divide by zero
我的天，一切运转正常
</code></pre>
<p>Out2:</p>
<pre><code>自定义异常信息
除数不能等于0
我的天，一切运转正常
</code></pre>
<p>如果没有recover,程序不能正常往下执行，就此打住了；</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="json编码"><a class="header" href="#json编码">json编码</a></h3>
<pre><code class="language-go">type Person struct {
	Name string `json:"name"`
	Age int `json:"age,omitempty"`
}

type Toys struct {
	Person
	Toys []string `json:"toys"`
}

func main(){
    p := Person{Name:"cao",Age:12}
    toys := []string{"a","b"}
    toy := Toys{Person:p,Toys: toys}
    resbyte,err := json.Marshal(toy)
    if err != nil{
      log.Fatal(err)
    }
    // 返回byte切片，转成string类型
    resstring := string(resbyte)
    fmt.Println(resstring)
}

</code></pre>
<p>Out:</p>
<pre><code>{"name":"cao","toys":["a","b"]}
</code></pre>
<p><code>json:"age"</code> : 可以理解成别名，</p>
<p><code>oemiempty</code> ： 值为空，就忽略此字段</p>
<h3 id="解码json--unmarshal"><a class="header" href="#解码json--unmarshal">解码json  Unmarshal()</a></h3>
<p>将json字符串转成结构体变量，json.Unmarshal()必须传入byte切片</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unsafepointer"><a class="header" href="#unsafepointer">unsafe.pointer</a></h3>
<ol>
<li>可支持操作内存；</li>
<li>可以转换到任意类型指针</li>
<li>非安全的，不建议使用</li>
<li>unsafe.Pointer() 任意转换指针类型，并可进行指针运算</li>
<li>其他类型的指针只能转化为unsafe.Pointer，也只有unsafe.Pointer才能转化成任意类型的指针</li>
<li>只有uintptr才支持加减操作，而uintptr是一个非负整数，表示地址值，没有类型信息，以字节为单位</li>
</ol>
<p>实际操作：获取一个字符串第二个字符的地址和值</p>
<pre><code class="language-golang">    var s = "abc"
	var strHeader = (*reflect.StringHeader)(unsafe.Pointer(&amp;s))
	var res = (*byte)(unsafe.Pointer(strHeader.Data)) //获取字符串第一个字符的地址
	log.Printf("strHeader.Data = %c", *res)
	var ress = (*byte)(unsafe.Pointer(strHeader.Data + uintptr(1))) //获取字符串第一个字符的地址
	log.Printf("strHeader.Data = %c", *ress)
	//var ssss uintptr = 0xc000088fc0
	//log.Println(*(*byte)(unsafe.Pointer(ssss)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>golang 1.18 正式版本，支持泛型</p>
<pre><code class="language-golang">
func TestGeneric(t *testing.T) {
	x := map[string]int{"tom": 12, "jelly": 7}
	res := Sums[string, int](x)
	log.Println(res)

    stuC := StuCross[string]{
		score: "成绩",
	}
	log.Println(stuC)
}

//指定函数参数类型约束
func Sums[K string, V int | float32](m map[K]V) V {
	var x V
	for _, v := range m {
		x += v
	}
	return x
}

type StuCross[K string] struct {
	score K
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="map"><a class="header" href="#map">map</a></h3>
<p>map中元素为结构体，不能直接修改，因为map元素无法取地址；</p>
<pre><code class="language-go">type Student struct {
	name string
}
</code></pre>
<p>修改map中struct元素的值，错误示例：</p>
<pre><code class="language-go">func TestMap(t *testing.T)  {
	m := map[string]Student11{"people": {"zhoujielun"}}
  //编译错误 Cannot assign to m["people"].name
	m["people"].name = "wuyanzu"
}
</code></pre>
<p>解决办法：</p>
<pre><code class="language-go">func TestMap(t *testing.T)  {
  //Student =&gt; *Student
	m := map[string]*Student{"people": {"zhoujielun"}}
  //编译错误 Cannot assign to m["people"].name
	m["people"].name = "wuyanzu"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="闭包"><a class="header" href="#闭包">闭包</a></h3>
<pre><code class="language-golang">func TestCloser(t *testing.T) {
	x := func() func() {
		var i = 1
		return func() {
			i++
			log.Println("i = ", i)
		}
	}()
	x()
	x()
}
</code></pre>
<p>输出结果：</p>
<pre><code>=== RUN   TestCloser
2022/04/10 21:42:09 2
2022/04/10 21:42:09 3
--- PASS: TestCloser (0.01s)
</code></pre>
<p>闭包持有外部变量<code>i</code>，</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-golang">//GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥
	//Reader是一个全局、共享的密码用强随机数生成器
	var bits = 2048
	priKey, err := rsa.GenerateKey(rand.Reader, bits)
	if err != nil {
		panic(err)
	}
	x509Key := x509.MarshalPKCS1PrivateKey(priKey)
	priKeyFile, err := os.Create("pk.pem")
	if err != nil {
		panic(err)
	}
	defer priKeyFile.Close()
	priKeyBlock := pem.Block{Type: "RSA Private Key", Bytes: x509Key}

	pem.Encode(priKeyFile, &amp;priKeyBlock)

	x509PubKey := x509.MarshalPKCS1PublicKey(&amp;priKey.PublicKey)

	pubKeyFile, err := os.Create("pubKey.pem")
	if err != nil {
		panic(err)
	}
	defer pubKeyFile.Close()
	pubKeyBlock := pem.Block{Type: "RSA Public Key", Bytes: x509PubKey}
	// block 输出到文件
	pem.Encode(pubKeyFile, &amp;pubKeyBlock)
	x := pem.EncodeToMemory(&amp;pubKeyBlock)
	log.Println(string(x))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="context-基本使用"><a class="header" href="#context-基本使用">context 基本使用</a></h3>
<pre><code class="language-golang">func TestTimeout(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	//1. 传递上下文
	go RequestA(ctx)

	time.Sleep(time.Second * 4)
	//#cancel 1.取消
	cancel()
	time.Sleep(time.Second * 10)
}

func RequestA(ctx context.Context) {
	// Do Something ...
	ctx = context.WithValue(ctx, "A", "RequestA")
	tic := time.NewTicker(time.Second * 2)
	// 2. 传递上下文
	go RequestB(ctx)
	for {
		select {
		case &lt;-tic.C:
			//3. 开始转圈圈
			log.Println("A转圈圈")
		case &lt;-ctx.Done():
			//#cancel. A结束
			log.Println("请求A ctx.Done")
			return
		}
	}
}

func RequestB(ctx context.Context) {
	// Do Something ...
	val := ctx.Value("A")
	log.Println("from A : ", val)
	ctx = context.WithValue(ctx, "B", "RequestB")
	tic := time.NewTicker(time.Second * 1)
	for {
		select {
		case &lt;-tic.C:
			//4. 开始转圈圈 1秒1次
			log.Println("B转圈圈")
		case &lt;-ctx.Done():
			//#cancel. B 结束
			log.Println("请求B ctx.Done")
			return
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-go">app.conf
runmode = dev //有4中
// dev 开发
//test 测试
//sprod 准生产环境
//prod 生产环境
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>go get github.com/astaxie/beego/orm</p>
<p>go get github.com/go-sql-driver/mysql</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装beego管理工具bee"><a class="header" href="#安装beego管理工具bee">安装beego管理工具bee</a></h3>
<pre><code class="language-shell">go get github.com/beego/bee
</code></pre>
<pre><code class="language-shell">go get github.com/astaxie/beego
</code></pre>
<h3 id="装好了bee管理工具之后运用bee创建项目"><a class="header" href="#装好了bee管理工具之后运用bee创建项目">装好了bee管理工具之后，运用bee创建项目</a></h3>
<h4 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h4>
<p><code>bee new</code>会自动在<code>GOPATH</code>路径<code>src</code>目录下创建项目</p>
<pre><code>bee new project_name
</code></pre>
<h4 id="运行项目"><a class="header" href="#运行项目">运行项目</a></h4>
<p>定位到项目目录 GOPATH/src/project_name</p>
<pre><code>
go build project_name
go run
或者
bee run

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="部署"><a class="header" href="#部署">部署</a></h1>
<h2 id="编译打包"><a class="header" href="#编译打包">编译打包</a></h2>
<p><code>windows</code>平台打包<code>linux</code>可执行文件</p>
<pre><code class="language-golang">package main

import (
	"fmt"
	"os"
	"os/exec"
)

//filepath: 要编译的文件的路径
func build(filepath string){
	_ = os.Setenv("CGO_ENABLED", "0")
	_ = os.Setenv("GOARCH", "amd64")
	_ = os.Setenv("GOOS", "linux")

	arg := []string{"build", filepath}
	if err := exec.Command("go", arg...).Run(); err!=nil {
		fmt.Println("编译失败:", err)
	} else{
		fmt.Println("编译成功")
	}
}

func main() {
	build(`D:\WorkProject\go\src\beego_first\main.go`)
}
</code></pre>
<p><code>go</code> 编译之后是二进制文件，<code>beego</code>:打包需要自行<code>copy</code> &gt; (views,static,conf) 几个文件夹到部署应用目录下</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="gorm使用"><a class="header" href="#gorm使用">gorm使用</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>跨域请求在网上找了很多文章都是下面这种做法：</p>
<pre><code class="language-go">func cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		method := c.Request.Method
		fmt.Println("啥玩意儿的")
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Headers", "Content-Type,AccessToken,X-CSRF-Token, Authorization, Token")
		c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
		c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type")
		c.Header("Access-Control-Allow-Credentials", "true")
		if method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
		}
		c.Next()
	}
}
</code></pre>
<p>但是并不好使用，所以又找到下面这种方法，总算是搞明白了啥意思了！</p>
<pre><code class="language-go">func cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := c.Request.Header.Get("origin")
		if len(origin) == 0 {
			origin = c.Request.Header.Get("Origin")
		}
		c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "OPTIONS, GET, POST")
		c.Writer.Header().Set("Content-Type", "application/json; charset=utf-8")
		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}
		c.Next()
	}
}
</code></pre>
<p>跨域请求字段说明<br />
<strong>Access-Control-Allow-Origin</strong></p>
<p>首先，客户端请求时要带上一个Origin，用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。然后服务端在返回时需要带上这个字段，并把对方传过来的值返回去。告知客户端，允许这次请求。 这个字段也可以设置为*，即允许所有客户端访问。但是这样做会和Access-Control-Allow-Credentials 起冲突。可能导致跨域请求失败。</p>
<p><strong>Access-Control-Allow-Credentials</strong></p>
<p>这个字段是一个BOOL值，可以允许客户端携带一些校验信息，比如cookie等。如果设置为Access-Control-Allow-Origin：<code>*</code>，而该字段是true，并且客户端开启了withCredentials, 仍然不能正确访问。需要把Access-Control-Allow-Origin的值设置为客户端传过来的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="main"><a class="header" href="#main">main</a></h3>
<p>程序入口</p>
<h3 id="routers"><a class="header" href="#routers">routers</a></h3>
<p>路由配置</p>
<h3 id="controllers"><a class="header" href="#controllers">controllers</a></h3>
<p>控制器</p>
<h3 id="dao"><a class="header" href="#dao">dao</a></h3>
<p>数据库操作</p>
<h3 id="static"><a class="header" href="#static">static</a></h3>
<p>静态文件</p>
<h3 id="models"><a class="header" href="#models">models</a></h3>
<p>数据模型</p>
<h3 id="services"><a class="header" href="#services">services</a></h3>
<p>逻辑业务操作</p>
<h3 id="config"><a class="header" href="#config">config</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4go-kit"><a class="header" href="#4go-kit">4.go-kit</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>go-kit 代码生成工具
https://github.com/metaverse/truss</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>transport : 协议传输层</li>
<li>service : 业务层</li>
<li>endpoint : 中间结点<br />
newServer 调用流程：transport dec --&gt;  endpoint --&gt; service --&gt; transport enc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-定义proto文件"><a class="header" href="#1-定义proto文件">1. 定义proto文件</a></h3>
<pre><code>//声明protobuf版本
syntax = "proto3";
</code></pre>
<p><strong>自动生成pb的时候，会提示要有go_package</strong></p>
<pre><code>option go_package='.;grpc';
</code></pre>
<ul>
<li><code>.</code>:     表示生成pb文件在哪个位置</li>
<li><code>;grpc</code>: 表示生成的pb文件所属包名</li>
</ul>
<pre><code>package grpc;

service Greeter{
  rpc SayHello (HelloRequest) returns(HelloReply){}
}

message HelloRequest{
  string name = 1;
}

message HelloReply{
  string message = 1;
}

</code></pre>
<h3 id="2-生成pb文件"><a class="header" href="#2-生成pb文件">2. 生成pb文件</a></h3>
<pre><code>//go:generate protoc -I . --go_out=plugins=grpc:./ ./helloworld.proto

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="配置基本信息"><a class="header" href="#配置基本信息">配置基本信息</a></h3>
<ol>
<li>获取grpc</li>
</ol>
<pre><code>go get -u google.golang.org/grpc

go get -u github.com/golang/protobuf/{proto,protoc-gen-go}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="创建运行容器"><a class="header" href="#创建运行容器">创建运行容器</a></h3>
<pre><code class="language-shell">docker run -itd --name small-mq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 5672:5672 -p 15672:15672 rabbitmq

</code></pre>
<h2 id="我是分割线"><a class="header" href="#我是分割线">我是分割线</a></h2>
<p>docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:managemen</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="consul-实例1"><a class="header" href="#consul-实例1">consul 实例1</a></h3>
<pre><code>docker run -itd --name=consule1 -p 8500:8500 --restart=always -e consul_bind_interface='eth0' --privileged=true --name=consul1 consul agent -server -bootstrap-expect=2  -ui -node=consul1 -client='0.0.0.0' -data-dir /consul/data -config-dir /consul/config -datacenter=consul_dc
</code></pre>
<p>参数说明：</p>
<pre><code>docker run -itd --name=consul -p 8500:8500 consul agent -server -bootstrap -ui  -client 0.0.0.0
</code></pre>
<p><code>-server</code> : 以服务端方式启动
<code>-bootstrap</code> : 指定自己为leader ,而不需要选举
<code>-ui</code> : 启动一个内置管理web界面
<code>-client</code> : 指定客户端可以访问的IP. 设置为0.0.0.0 则任意访问，否则默认本机可以访问</p>
<p>实例1 ip : 172.17.0.2</p>
<h3 id="consul-实例2"><a class="header" href="#consul-实例2">consul 实例2</a></h3>
<pre><code>docker run -itd --name=consule1 -p 8200:8500 --restart=always -e consul_bind_interface='eth0' --privileged=true --name=consul2 consul agent -server -bootstrap-expect=2  -ui -node=consul2 -client='0.0.0.0' -data-dir /consul/data -config-dir /consul/config -datacenter=consul_dc -join=172.17.0.2</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>go 关键字 就定义了一个协程</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code>dlv debug main.go
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h2>
<h3 id="1-测试指定文件名-name_testgo"><a class="header" href="#1-测试指定文件名-name_testgo">1. 测试指定文件名 name_test.go</a></h3>
<pre><code class="language-golang">package nsqm

import (
    "testing"
)

func TestNsq(t *testing.T){

}

</code></pre>
<h3 id="2-运行"><a class="header" href="#2-运行">2. 运行</a></h3>
<pre><code class="language-shell"># -test.run funName   指定执行测试方法名
go test -v nsqm -test.run TestNsq

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chromedp"><a class="header" href="#chromedp">chromedp</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h3 id="chromedp-常用方法"><a class="header" href="#chromedp-常用方法">chromedp 常用方法</a></h3>
<blockquote>
<p>chromedp.NewContext() 初始化chromedp的上下文，后续这个页面都使用这个上下文进行操作</p>
</blockquote>
<blockquote>
<p>chromedp.Run() 运行一个chrome的一系列操作</p>
</blockquote>
<blockquote>
<p>chromedp.Navigate() 将浏览器导航到某个页面</p>
</blockquote>
<blockquote>
<p>chromedp.WaitVisible() 等候某个元素可见，再继续执行。</p>
</blockquote>
<blockquote>
<p>chromedp.Click() 模拟鼠标点击某个元素</p>
</blockquote>
<blockquote>
<p>chromedp.Value() 获取某个元素的value值</p>
</blockquote>
<blockquote>
<p>chromedp.ActionFunc() 再当前页面执行某些自定义函数</p>
</blockquote>
<blockquote>
<p>chromedp.Text() 读取某个元素的text值</p>
</blockquote>
<blockquote>
<p>chromedp.Evaluate() 执行某个js，相当于控制台输入js</p>
</blockquote>
<blockquote>
<p>network.SetExtraHTTPHeaders() 截取请求，额外增加header头</p>
</blockquote>
<blockquote>
<p>chromedp.SendKeys() 模拟键盘操作，输入字符</p>
</blockquote>
<blockquote>
<p>chromedp.Nodes() 根据xpath获取某些元素，并存储进入数组</p>
</blockquote>
<blockquote>
<p>chromedp.NewRemoteAllocator</p>
</blockquote>
<blockquote>
<p>chromedp.OuterHTML() 获取元素的outer html</p>
</blockquote>
<blockquote>
<p>chromedp.Screenshot() 根据某个元素截图</p>
</blockquote>
<blockquote>
<p>page.CaptureScreenshot() 截取整个页面的元素</p>
</blockquote>
<blockquote>
<p>chromedp.Submit() 提交某个表单</p>
</blockquote>
<blockquote>
<p>chromedp.WaitNotPresent() 等候某个元素不存在，比如“正在搜索。。。”</p>
</blockquote>
<blockquote>
<p>chromedp.Tasks{} 一系列Action组成的任务</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装docker-镜像"><a class="header" href="#安装docker-镜像">安装docker 镜像</a></h3>
<ol>
<li>
<p>下载docker image : docker pull chromedp/headless-shell</p>
</li>
<li>
<p>运行docker : docker run -d -p 9222:9222 --rm --name headless-shell chromedp/headless-shell</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="爬虫"><a class="header" href="#爬虫">爬虫</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="当涉及到网页抓取和解析htmlxml文档时xpath是一种强大的定位和提取数据的工具xpathxml-path-language是一种在xml文档中定位节点的语言下面是一些关于xpath的详细解释和案例"><a class="header" href="#当涉及到网页抓取和解析htmlxml文档时xpath是一种强大的定位和提取数据的工具xpathxml-path-language是一种在xml文档中定位节点的语言下面是一些关于xpath的详细解释和案例">当涉及到网页抓取和解析HTML/XML文档时，XPath是一种强大的定位和提取数据的工具。XPath（XML Path Language）是一种在XML文档中定位节点的语言。下面是一些关于XPath的详细解释和案例：</a></h2>
<h3 id="基本介绍"><a class="header" href="#基本介绍">基本介绍</a></h3>
<ol>
<li>XPath基础
XPath的基本语法如下：</li>
</ol>
<pre><code>/         # 从根节点开始
//        # 选择匹配的任何位置
.         # 当前节点
..        # 父节点
@         # 选择属性
[node]    # 选取所有node子元素
[@attr]   # 选取带有attr属性的所有元素
</code></pre>
<ol start="2">
<li>选取节点
使用XPath选取节点，例如：</li>
</ol>
<pre><code>//div          # 选择所有div元素
//div[@class]  # 选择带有class属性的div元素
//div[@id='myId']  # 选择id属性为'myId'的div元素
</code></pre>
<ol start="3">
<li>路径表达式
XPath使用路径表达式来选取节点。例如：</li>
</ol>
<pre><code>//div/p   # 选择所有div下的p元素
//div//p  # 选择所有div下的所有p元素
</code></pre>
<ol start="4">
<li>谓词
XPath中的谓词用于过滤节点。例如：</li>
</ol>
<pre><code>//div[@class='highlight']  # 选择class属性为'highlight'的div元素
//ul/li[position()&lt;3]      # 选择ul下的前两个li元素
</code></pre>
<ol start="5">
<li>通配符
使用通配符匹配元素，例如：</li>
</ol>
<pre><code>    //*        # 选择所有元素
    //div/*    # 选择所有div下的所有子元素
</code></pre>
<ol start="6">
<li>文本提取
使用XPath提取文本内容，例如：</li>
</ol>
<pre><code>//p/text()   # 提取p元素的文本内容
</code></pre>
<h2 id="xpath-简介"><a class="header" href="#xpath-简介">XPath 简介</a></h2>
<h3 id="什么是-xpath"><a class="header" href="#什么是-xpath">什么是 XPath</a></h3>
<h3 id="xpathxml-path-language即-xml-路径语言是一种用于在-xml-和-html-文档中查找信息的语言-它基于-xml-文档的树状结构提供了在数据结构树中找寻节点的能力通过-xpath你可以使用路径表达式来定位和选择文档中的节点或节点集这些节点可以是元素属性文本命名空间处理指令注释以及文档根节点等比如在一个图书管理系统的-xml-文档中你可以利用-xpath-快速定位到所有价格高于-50-元的图书节点获取它们的书名作者等信息"><a class="header" href="#xpathxml-path-language即-xml-路径语言是一种用于在-xml-和-html-文档中查找信息的语言-它基于-xml-文档的树状结构提供了在数据结构树中找寻节点的能力通过-xpath你可以使用路径表达式来定位和选择文档中的节点或节点集这些节点可以是元素属性文本命名空间处理指令注释以及文档根节点等比如在一个图书管理系统的-xml-文档中你可以利用-xpath-快速定位到所有价格高于-50-元的图书节点获取它们的书名作者等信息">XPath（XML Path Language）即 XML 路径语言，是一种用于在 XML 和 HTML 文档中查找信息的语言 。它基于 XML 文档的树状结构，提供了在数据结构树中找寻节点的能力。通过 XPath，你可以使用路径表达式来定位和选择文档中的节点或节点集，这些节点可以是元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点等。比如，在一个图书管理系统的 XML 文档中，你可以利用 XPath 快速定位到所有价格高于 50 元的图书节点，获取它们的书名、作者等信息。</a></h3>
<h3 id="xpath-的重要性"><a class="header" href="#xpath-的重要性">XPath 的重要性</a></h3>
<h4 id="xpath-在多个领域都有着举足轻重的地位"><a class="header" href="#xpath-在多个领域都有着举足轻重的地位">XPath 在多个领域都有着举足轻重的地位：</a></h4>
<ul>
<li>数据提取：在从 XML 或 HTML 文档中提取数据时，XPath 提供了一种简洁且强大的方式。比如从一个电商网站的产品列表页面提取商品名称、价格、评论数等信息，XPath 可以帮助我们精准定位到包含这些数据的 HTML 节点。
网页爬虫：在爬虫开发中，XPath 是常用的解析工具之一。通过编写 XPath 表达式，爬虫可以高效地从网页中提取所需的数据，为后续的数据分析、信息挖掘等提供数据支持 。以爬取新闻网站的文章为例，使用 XPath 可以轻松定位到文章的标题、正文、发布时间等关键信息。
XML 处理：在处理 XML 文档时，无论是验证文档结构、修改节点内容还是进行数据转换，XPath 都能发挥重要作用。例如，在一个企业的订单管理系统中，使用 XML 来存储订单信息，XPath 可以用于查询特定订单、更新订单状态等操作。</li>
</ul>
<p>准备工作<br />
工具推荐<br />
在学习和使用 XPath 的过程中，选择合适的工具可以事半功倍。以下为大家推荐几款常用工具 ：</p>
<p>Chrome 开发者工具：作为 Chrome 浏览器自带的强大工具，按下 F12 键即可呼出。在 “Elements” 面板中，通过鼠标悬停和点击，可以快速定位到网页的 HTML 元素，右键点击元素还能直接复制 XPath 表达式，方便验证和测试。比如在分析一个电商产品页面时，利用 Chrome 开发者工具能迅速获取商品名称、价格等元素的  XPath。<br />
Firefox 开发者工具：同样是浏览器自带工具，功能与 Chrome 开发者工具类似。它也能让你在页面中轻松定位元素，并查看和测试 XPath 表达式。对于习惯使用 Firefox 浏览器的开发者来说，这是一个不错的选择。<br />
在线 XPath 测试工具：如 “XPath Tester” 等在线工具，无需安装，打开网页即可使用。你只需将 XML 或 HTML 文档内容粘贴进去，输入 XPath 表达式，就能实时查看匹配结果。这种工具特别适合初学者快速上手，进行简单的 XPath 练习。<br />
XPath Helper 插件：以 Chrome 浏览器为例，安装 XPath Helper 插件后，在浏览网页时，它会在浏览器界面中添加一个浮动窗口，显示当前鼠标悬停元素的 XPath 路径，并且可以直接在窗口中编辑和测试 XPath 表达式，大大提高了开发效率。<br />
示例 HTML 文档<br />
为了更直观地讲解 XPath 语法，我们先准备一个简单的 HTML 文档示例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
 
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;XPath示例页面&lt;/title&gt;
&lt;/head&gt;
 
&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;h1&gt;欢迎来到XPath学习页面&lt;/h1&gt;
        &lt;p class="intro"&gt;这是一个用于学习XPath的示例页面。&lt;/p&gt;
        &lt;ul id="book-list"&gt;
            &lt;li class="book-item"&gt;
                &lt;a href="book1.html"&gt;《Python编程从入门到实践》&lt;/a&gt;
                &lt;p class="author"&gt;Eric Matthes&lt;/p&gt;
                &lt;p class="price"&gt;79.00元&lt;/p&gt;
            &lt;/li&gt;
            &lt;li class="book-item"&gt;
                &lt;a href="book2.html"&gt;《Effective Java》&lt;/a&gt;
                &lt;p class="author"&gt;Joshua Bloch&lt;/p&gt;
                &lt;p class="price"&gt;99.00元&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;a href="about.html"&gt;关于我们&lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
 
&lt;/html&gt;
</code></pre>
<p>在后续的 XPath 语法讲解中，我们将基于这个示例文档进行演示，通过实际操作来深入理解 XPath 的各种用法。</p>
<p>XPath 基础知识
基本路径表达式
XPath 使用路径表达式来选取 XML 或 HTML 文档中的节点或节点集。以下是一些常用的路径表达式符号及其含义 ：</p>
<p>nodename：选取此节点的所有子节点。例如，在我们的示例 HTML 文档中，ul 会选取所有的 <ul> 元素节点及其子节点。
/：从根节点选取。/html 表示从 HTML 文档的根节点 <html> 开始选取，它是一个绝对路径表达式 。
//：从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。//li 可以选取文档中所有的 <li> 元素节点，无论它们在文档的哪个层级 。
.：选取当前节点。假设我们已经定位到了某个 <div> 元素节点，使用 . 就表示当前这个 <div> 节点本身。
..：选取当前节点的父节点。如果当前节点是 <p> 元素节点，且它是某个 <div> 元素节点的子节点，那么 .. 就可以选取到这个 <div> 父节点。
@：选取属性。//a[@href] 会选取所有带有 href 属性的 <a> 元素节点；//@class 则会选取文档中所有的 class 属性 。
下面通过具体的示例来进一步理解这些路径表达式的用法：</p>
<p>选取所有的 <h1 id="元素节点h1在示例文档中这个表达式会找到-欢迎来到xpath学习页面"><a class="header" href="#元素节点h1在示例文档中这个表达式会找到-欢迎来到xpath学习页面"> 元素节点：//h1。在示例文档中，这个表达式会找到 <h1>欢迎来到XPath学习页面</a></h1> 这一节点。
选取根节点下的 <body> 元素节点的直接子节点 <div>：/html/body/div。这是一个绝对路径，从根节点 <html> 开始，依次经过 <body> 节点，找到其直接子节点 <div>。
选取所有带有 id 属性的 <li> 元素节点：//li[@id]。在示例文档中，虽然没有这样的 <li> 节点，但如果有，就可以通过这个表达式找到。
节点选择
在 XPath 中，可以根据节点的类型和属性来选择节点 ：</p>
<p>元素节点：直接使用元素名称即可选取。如 //book 选取所有的 <book> 元素节点；/html/body/div/ul/li 可以选取到示例文档中 <ul> 下的所有 <li> 元素节点，这是从根节点开始的相对路径选择。
属性节点：使用 @ 符号加上属性名称。//a[@href] 选取所有带有 href 属性的 <a> 元素节点；//li[@class='book-item'] 选取所有 class 属性值为 book-item 的 <li> 元素节点 。
文本节点：使用 text() 函数。//p[@class='intro']/text() 可以选取到 <p class="intro">这是一个用于学习XPath的示例页面。</p> 中的文本内容 “这是一个用于学习 XPath 的示例页面。”；//a/text() 则会选取所有 <a> 元素节点的文本内容 ，如 “《Python 编程从入门到实践》”“《Effective Java》” 等。
通过灵活运用这些节点选择方法，结合路径表达式，我们能够在复杂的 XML 或 HTML 文档中准确地定位到所需的节点，为数据提取和处理打下坚实的基础。</p>
<p>基本选择器
选择特定元素
在 XPath 中，通过标签名可以直接选择文档中的特定元素。例如，在我们的示例 HTML 文档中，要选择所有的<li>元素，可以使用以下 XPath 表达式：</p>
<p>//li</p>
<p>这个表达式会选取文档中所有的<li>元素节点，因为//表示从当前节点开始，无论在文档的哪个层级，都查找所有匹配的节点 ，而li就是我们要选择的标签名。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容"><a class="header" href="#假设html为读取的示例html文档内容">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面"><a class="header" href="#欢迎来到xpath学习页面">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择所有的<li>元素
lis = root.xpath('//li')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
上述代码中，首先使用etree.HTML()方法将 HTML 字符串转换为Element对象，然后通过xpath('//li')选择所有的<li>元素，并将其打印输出。
<p>选择特定路径上的元素
XPath 中可以使用绝对路径和相对路径来选择特定路径上的元素 。</p>
<p>绝对路径：从根节点开始，通过指定每个节点的层级关系来定位目标元素，以正斜杠（/）开头 。例如，在示例 HTML 文档中，要选择<body>元素下的<div>元素下的<h1>元素，可以使用绝对路径：
/html/body/div/h1</p>
<p>相对路径：相对于当前节点的路径，通常使用./表示从当前节点开始查找子节点，../表示查找父节点，//表示跨越多层级查找节点 。假设当前节点是<div>元素，要选择其下的<ul>元素，可以使用相对路径：
./ul</p>
<p>或者使用//跨层级查找：</p>
<p>//ul</p>
<p>绝对路径和相对路径的主要区别在于：绝对路径的定位非常精确，从根节点开始，路径表达明确，能够准确地定位到目标节点 ，但当文档结构发生变化时，路径可能会失效；相对路径更为灵活、简洁，并且具有良好的可维护性，当文档结构发生变化时，相对路径的调整相对简单，但可能无法像绝对路径那样精确定位某些节点，尤其是当文档结构比较复杂或存在多个相同节点名称时 。</p>
<p>通配符选择
XPath 中的通配符可以用于匹配未知的元素节点或属性节点，为我们在选择节点时提供了更大的灵活性 。</p>
<p><em>通配符：匹配任何元素节点。例如，要选择<div>元素下的所有子元素，无论它们是什么标签，可以使用：
//div/</em></p>
<p>在示例 HTML 文档中，这个表达式会选取<div id="content">下的<h1>、<p class="intro">、<ul id="book-list">和<a href="golang/爬虫/about.html">等所有子元素 。</p>
<p>@<em>通配符：匹配任何属性节点。如果要选择文档中所有元素的所有属性，可以使用：
//@</em></p>
<p>这将返回所有元素的属性，如<div>的id属性、<a>的href属性、<li>的class属性等 。通配符在实际应用中非常有用，特别是当我们不确定文档中某些节点的具体标签名或属性名时，可以借助通配符来进行更宽泛的选择 。</p>
<p>属性选择器
选择具有特定属性的元素
在 XPath 中，通过@符号选择具有特定属性的元素。例如，在我们的示例 HTML 文档中，要选择所有带有href属性的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[@href]</p>
<p>这个表达式中，//a表示选择所有的<a>元素，[@href]则表示筛选出带有href属性的元素。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-1"><a class="header" href="#假设html为读取的示例html文档内容-1">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-1"><a class="header" href="#欢迎来到xpath学习页面-1">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择所有带有href属性的<a>元素
as_with_href = root.xpath('//a[@href]')
for a in as_with_href:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[@href]')选择所有带有href属性的<a>元素，并将其打印输出。</p>
<p>选择特定属性值的元素
使用方括号筛选具有特定属性值的元素。在示例 HTML 文档中，若要选择class属性值为book-item的<li>元素，XPath 表达式为：</p>
<p>//li[@class='book-item']</p>
<p>在这个表达式里，//li表示选择所有的<li>元素，[@class='book-item']用于筛选出class属性值为book-item的元素 。Python 代码实现如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-2"><a class="header" href="#假设html为读取的示例html文档内容-2">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-2"><a class="header" href="#欢迎来到xpath学习页面-2">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值为book-item的<li>元素
lis = root.xpath('//li[@class="book-item"]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>运行这段代码，会输出所有class属性值为book-item的<li>元素内容。</p>
<p>选择具有特定属性的元素（无论值是什么）
使用@*选择具有任意属性的元素。比如，要选择示例 HTML 文档中所有具有属性的元素，可以使用：</p>
<p>//<em>[@</em>]</p>
<p>这个表达式中，//<em>表示选择所有元素，[@</em>]表示筛选出具有任意属性的元素 。在 Python 中，实现代码如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-3"><a class="header" href="#假设html为读取的示例html文档内容-3">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-3"><a class="header" href="#欢迎来到xpath学习页面-3">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择具有任意属性的元素
elements_with_attr = root.xpath('//*[@*]')
for element in elements_with_attr:
    print(etree.tostring(element, encoding='utf-8').decode('utf-8'))
<p>执行代码后，会打印出文档中所有具有属性的元素内容。</p>
<p>条件表达式
使用条件选择元素
在 XPath 中，方括号（[]）用于包含条件表达式，以此筛选出符合特定条件的元素。例如，在我们的示例 HTML 文档中，要选择<ul>下的第一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[1]</p>
<p>这里的[1]表示选择列表中的第一个元素。需要注意的是，在 XPath 中，索引从 1 开始，而不是 0。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-4"><a class="header" href="#假设html为读取的示例html文档内容-4">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-4"><a class="header" href="#欢迎来到xpath学习页面-4">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第一个<li>元素
first_li = root.xpath('//ul/li[1]')
for li in first_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[1]')选择<ul>下的第一个<li>元素，并将其打印输出。</p>
<p>使用 or 条件
在 XPath 中，or运算符用于实现多条件选择，只要满足其中一个条件的元素就会被选中。例如，在示例 HTML 文档中，若要选择class属性值为book-item或者href属性值为about.html的元素，可以使用以下 XPath 表达式：</p>
<p>//*[@class='book-item' or @href='about.html']</p>
<p>在这个表达式中，//*表示选择所有元素，[@class='book-item' or @href='about.html']表示筛选出class属性值为book-item或者href属性值为about.html的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-5"><a class="header" href="#假设html为读取的示例html文档内容-5">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-5"><a class="header" href="#欢迎来到xpath学习页面-5">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值为book-item或者href属性值为about.html的元素
elements = root.xpath('//*[@class="book-item" or @href="about.html"]')
for element in elements:
    print(etree.tostring(element, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//*[@class="book-item" or @href="about.html"]')选择符合条件的元素，并将其打印输出。</p>
<p>使用 not 函数
not()函数用于排除特定条件的元素。例如，在示例 HTML 文档中，要选择所有class属性值不为book-item的<li>元素，可以使用以下 XPath 表达式：</p>
<p>//li[not(@class='book-item')]</p>
<p>在这个表达式中，//li表示选择所有的<li>元素，not(@class='book-item')表示排除class属性值为book-item的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-6"><a class="header" href="#假设html为读取的示例html文档内容-6">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-6"><a class="header" href="#欢迎来到xpath学习页面-6">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值不为book-item的<li>元素
lis = root.xpath('//li[not(@class="book-item")]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//li[not(@class="book-item")]')选择符合条件的元素，并将其打印输出。</p>
<p>位置选择器
选择第一个元素
在 XPath 中，使用[1]可以选择列表中的第一个元素 。例如，在我们的示例 HTML 文档中，要选择<ul>下的第一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[1]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[1]表示在<ul>元素下选择第一个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-7"><a class="header" href="#假设html为读取的示例html文档内容-7">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-7"><a class="header" href="#欢迎来到xpath学习页面-7">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第一个<li>元素
first_li = root.xpath('//ul/li[1]')
for li in first_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[1]')选择<ul>下的第一个<li>元素，并将其打印输出 。</p>
<p>选择最后一个元素
使用last()函数选择列表中的最后一个元素 。例如，在示例 HTML 文档中，要选择<ul>下的最后一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[last()]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[last()]表示在<ul>元素下选择最后一个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-8"><a class="header" href="#假设html为读取的示例html文档内容-8">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-8"><a class="header" href="#欢迎来到xpath学习页面-8">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的最后一个<li>元素
last_li = root.xpath('//ul/li[last()]')
for li in last_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[last()]')选择<ul>下的最后一个<li>元素，并将其打印输出 。</p>
<p>选择特定位置范围的元素
使用position()函数结合条件表达式来选择特定位置范围的元素 。例如，在示例 HTML 文档中，要选择<ul>下的第二个和第三个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[position() &gt; 1 and position() &lt; 4]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[position() &gt; 1 and position() &lt; 4]表示在<ul>元素下选择位置大于 1 且小于 4 的<li>元素，即第二个和第三个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-9"><a class="header" href="#假设html为读取的示例html文档内容-9">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-9"><a class="header" href="#欢迎来到xpath学习页面-9">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第二个和第三个<li>元素
lis = root.xpath('//ul/li[position() > 1 and position() < 4]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[position() &gt; 1 and position() &lt; 4]')选择<ul>下的第二个和第三个<li>元素，并将其打印输出 。</p>
<p>文本内容选择
选择包含特定文本的元素
在 XPath 中，使用contains()函数可以选择包含特定文本的元素 。例如，在我们的示例 HTML 文档中，要选择包含 “Python” 文本的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[contains(text(), 'Python')]</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，contains(text(), 'Python')表示筛选出文本内容中包含 “Python” 的元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-10"><a class="header" href="#假设html为读取的示例html文档内容-10">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-10"><a class="header" href="#欢迎来到xpath学习页面-10">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择包含“Python”文本的<a>元素
as_with_python = root.xpath('//a[contains(text(), "Python")]')
for a in as_with_python:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[contains(text(), "Python")]')选择包含 “Python” 文本的<a>元素，并将其打印输出 。</p>
<p>选择完全匹配文本的元素
使用text()函数结合条件表达式选择完全匹配文本的元素 。例如，在示例 HTML 文档中，要选择文本内容为 “关于我们” 的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[text()='关于我们']</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，text()='关于我们'表示筛选出文本内容完全为 “关于我们” 的元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-11"><a class="header" href="#假设html为读取的示例html文档内容-11">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-11"><a class="header" href="#欢迎来到xpath学习页面-11">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择文本内容为“关于我们”的<a>元素
a_with_text = root.xpath('//a[text()="关于我们"]')
for a in a_with_text:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[text()="关于我们"]')选择文本内容为 “关于我们” 的<a>元素，并将其打印输出 。</p>
<p>XPath 轴
子节点轴
使用child::轴选择当前节点的子节点，它用于定位某个节点的直接子元素。例如，在我们的示例 HTML 文档中，要选择<div id="content">下的所有直接子节点<h1>，可以使用以下 XPath 表达式：</p>
<p>//div[@id='content']/child::h1</p>
<p>在这个表达式中，//div[@id='content']用于定位id为content的<div>元素，child::h1则表示选择该<div>元素的直接子节点<h1>。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-12"><a class="header" href="#假设html为读取的示例html文档内容-12">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-12"><a class="header" href="#欢迎来到xpath学习页面-12">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<div id="content">下的所有直接子节点<h1>
h1s = root.xpath('//div[@id="content"]/child::h1')
for h1 in h1s:
    print(etree.tostring(h1, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@id="content"]/child::h1')选择<div id="content">下的所有直接子节点<h1>，并将其打印输出 。实际上，在 XPath 中，child::轴是默认轴，所以上述表达式也可以简写为：</p>
<p>//div[@id='content']/h1</p>
<p>父节点轴
使用parent::轴选择当前节点的父节点 。例如，在示例 HTML 文档中，要选择<p class="author">元素的父节点<li>，可以使用以下 XPath 表达式：</p>
<p>//p[@class='author']/parent::li</p>
<p>在这个表达式中，//p[@class='author']用于定位class为author的<p>元素，parent::li表示选择该<p>元素的父节点<li> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-13"><a class="header" href="#假设html为读取的示例html文档内容-13">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-13"><a class="header" href="#欢迎来到xpath学习页面-13">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<p class="author">元素的父节点<li>
lis = root.xpath('//p[@class="author"]/parent::li')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//p[@class="author"]/parent::li')选择<p class="author">元素的父节点<li>，并将其打印输出 。</p>
<p>兄弟节点轴
使用following-sibling::轴选择当前节点之后的兄弟节点，使用preceding-sibling::轴选择当前节点之前的兄弟节点 。例如，在示例 HTML 文档中，要选择<ul id="book-list">之后的兄弟节点<a href="golang/爬虫/about.html">，可以使用以下 XPath 表达式：</p>
<p>//ul[@id='book-list']/following-sibling::a</p>
<p>在这个表达式中，//ul[@id='book-list']用于定位id为book-list的<ul>元素，following-sibling::a表示选择该<ul>元素之后的兄弟节点<a> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-14"><a class="header" href="#假设html为读取的示例html文档内容-14">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-14"><a class="header" href="#欢迎来到xpath学习页面-14">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul id="book-list">之后的兄弟节点<a href="golang/爬虫/about.html">
as_after_ul = root.xpath('//ul[@id="book-list"]/following-sibling::a')
for a in as_after_ul:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul[@id="book-list"]/following-sibling::a')选择<ul id="book-list">之后的兄弟节点<a href="golang/爬虫/about.html">，并将其打印输出 。</p>
<p>若要选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>，可以使用以下 XPath 表达式：</p>
<p>//li[@class='book-item']/p[1]/preceding-sibling::a</p>
<p>在这个表达式中，//li[@class='book-item']/p[1]用于定位class为book-item的<li>元素中的第一个<p>元素，preceding-sibling::a表示选择该<p>元素之前的兄弟节点<a> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-15"><a class="header" href="#假设html为读取的示例html文档内容-15">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-15"><a class="header" href="#欢迎来到xpath学习页面-15">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>
as_before_p = root.xpath('//li[@class="book-item"]/p[1]/preceding-sibling::a')
for a in as_before_p:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//li[@class="book-item"]/p[1]/preceding-sibling::a')选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>，并将其打印输出 。</p>
<p>祖先节点轴
使用ancestor::轴选择当前节点的祖先节点，它包括当前节点的父节点以及父节点的父节点等 。例如，在示例 HTML 文档中，要选择<a href="golang/爬虫/book1.html">元素的所有祖先节点<div>，可以使用以下 XPath 表达式：</p>
<p>//a[@href='book1.html']/ancestor::div</p>
<p>在这个表达式中，//a[@href='book1.html']用于定位href为book1.html的<a>元素，ancestor::div表示选择该<a>元素的所有祖先节点<div> 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-16"><a class="header" href="#假设html为读取的示例html文档内容-16">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-16"><a class="header" href="#欢迎来到xpath学习页面-16">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<a href="golang/爬虫/book1.html">元素的所有祖先节点<div>
divs = root.xpath('//a[@href="book1.html"]/ancestor::div')
for div in divs:
    print(etree.tostring(div, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[@href="book1.html"]/ancestor::div')选择<a href="golang/爬虫/book1.html">元素的所有祖先节点<div>，并将其打印输出 。</p>
<p>后代节点轴
使用descendant::轴选择当前节点的后代节点，它包括当前节点的子节点以及子节点的子节点等 。例如，在示例 HTML 文档中，要选择<div id="content">的所有后代节点<p>，可以使用以下 XPath 表达式：</p>
<p>//div[@id='content']/descendant::p</p>
<p>在这个表达式中，//div[@id='content']用于定位id为content的<div>元素，descendant::p表示选择该<div>元素的所有后代节点<p> 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-17"><a class="header" href="#假设html为读取的示例html文档内容-17">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-17"><a class="header" href="#欢迎来到xpath学习页面-17">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<div id="content">的所有后代节点<p>
ps = root.xpath('//div[@id="content"]/descendant::p')
for p in ps:
    print(etree.tostring(p, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@id="content"]/descendant::p')选择<div id="content">的所有后代节点<p>，并将其打印输出 。</p>
<p>XPath 函数
字符串函数
XPath 提供了一系列字符串函数，用于处理和操作字符串。例如，contains()函数用于判断一个字符串是否包含另一个子字符串 ，starts-with()函数用于判断一个字符串是否以另一个子字符串开头 。在我们的示例 HTML 文档中，若要选择href属性值以 “book” 开头的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[starts-with(@href, 'book')]</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，starts-with(@href, 'book')表示筛选出href属性值以 “book” 开头的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-18"><a class="header" href="#假设html为读取的示例html文档内容-18">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-18"><a class="header" href="#欢迎来到xpath学习页面-18">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="golang/爬虫/book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="golang/爬虫/book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="golang/爬虫/about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择href属性值以“book”开头的<a>元素
as_start_with_book = root.xpath('//a[starts-with(@href, "book")]')
for a in as_start_with_book:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[starts-with(@href, "book")]')选择href属性值以 “book” 开头的<a>元素，并将其打印输出 。</p>
<p>数值函数
数值函数在 XPath 中用于处理数值类型的数据，比如sum()函数可以计算节点集合中数值的总和 ，floor()函数返回小于或等于给定数值的最大整数 。假设在一个电商订单的 XML 文档中，每个<item>元素都有一个<price>子元素表示商品价格，我们要计算所有商品的总价格，可以使用以下 XPath 表达式：</p>
<p>sum(//item/price)</p>
<p>在 Python 中，使用lxml库结合 XPath 来计算这个总价格的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设xml为读取的电商订单xml文档内容"><a class="header" href="#假设xml为读取的电商订单xml文档内容">假设xml为读取的电商订单XML文档内容</a></h1>
<p>xml = """
<order>
<item>
<price>29.9</price>
</item>
<item>
<price>49.5</price>
</item>
<item>
<price>19.8</price>
</item>
</order>
"""</p>
<h1 id="将xml字符串解析为element对象"><a class="header" href="#将xml字符串解析为element对象">将XML字符串解析为Element对象</a></h1>
<p>root = etree.XML(xml)</p>
<h1 id="使用xpath计算所有商品的总价格"><a class="header" href="#使用xpath计算所有商品的总价格">使用XPath计算所有商品的总价格</a></h1>
<p>total_price = root.xpath('sum(//item/price)')
print(f"所有商品的总价格为: {total_price}")</p>
<p>上述代码中，首先将 XML 字符串解析为Element对象，然后通过xpath('sum(//item/price)')计算所有<item>元素下<price>元素数值的总和，并将结果打印输出 。</p>
<p>组合函数
在实际应用中，常常需要组合使用多个函数来实现复杂的筛选逻辑 。例如，在一个新闻网站的 HTML 页面中，每个新闻<div>元素包含一个<h2>标题元素和一个<p>摘要元素，摘要元素的class属性值可能不同。如果我们要选择标题中包含 “人工智能” 且摘要长度大于 100 个字符的新闻<div>元素，可以使用以下 XPath 表达式：</p>
<p>//div[contains(.//h2/text(), '人工智能') and string-length(.//p/text()) &gt; 100]</p>
<p>在这个表达式中，//div表示选择所有的<div>元素，contains(.//h2/text(), '人工智能')用于筛选出<h2>标题元素文本中包含 “人工智能” 的<div>元素，string-length(.//p/text()) &gt; 100用于筛选出<p>摘要元素文本长度大于 100 个字符的<div>元素 ，通过and连接两个条件，实现了复杂的筛选逻辑 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的新闻网站html页面内容"><a class="header" href="#假设html为读取的新闻网站html页面内容">假设html为读取的新闻网站HTML页面内容</a></h1>
<p>html = """</p>
<html>
<body>
    <div>
        <h2 id="人工智能在医疗领域的新突破"><a class="header" href="#人工智能在医疗领域的新突破">人工智能在医疗领域的新突破</a></h2>
        <p>人工智能技术近年来在医疗领域取得了显著进展，它正逐渐改变着疾病诊断、治疗方案制定等多个方面。随着大数据和机器学习算法的不断发展，人工智能能够处理海量的医疗数据，为医生提供更准确的诊断建议……</p>
    </div>
    <div>
        <h2 id="体育赛事精彩回顾"><a class="header" href="#体育赛事精彩回顾">体育赛事精彩回顾</a></h2>
        <p>昨天的体育赛事精彩纷呈，各支队伍展开了激烈的角逐……</p>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择标题中包含“人工智能”且摘要长度大于100个字符的新闻<div>元素
divs = root.xpath('//div[contains(.//h2/text(), "人工智能") and string-length(.//p/text()) > 100]')
for div in divs:
    print(etree.tostring(div, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[contains(.//h2/text(), "人工智能") and string-length(.//p/text()) &gt; 100]')选择符合条件的<div>元素，并将其打印输出 。</p>
<p>实际应用场景
为了更直观地展示 XPath 在实际中的应用，我们以一个电商网站的 HTML 页面为例，展示如何使用 XPath 提取各种信息。假设我们有如下 HTML 代码：</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1" class="product-name"><a class="header" href="#商品1">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2" class="product-name"><a class="header" href="#商品2">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3" class="product-name"><a class="header" href="#商品3">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="golang/爬虫/xpath语法.html#">首页</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">商品分类</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">购物车</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
<p>提取所有商品名称
使用 XPath 表达式提取所有商品名称：</p>
<p>//div[@class='product']/h3[@class='product-name']/text()</p>
<p>这个表达式首先通过//div[@class='product']定位到所有的商品<div>元素，然后在这些元素内部，通过h3[@class='product-name']定位到商品名称的<h3>元素，最后使用text()获取其文本内容 。在 Python 中，使用lxml库结合 XPath 来提取这些商品名称的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容"><a class="header" href="#假设html为读取的电商网站html页面内容">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-1" class="product-name"><a class="header" href="#商品1-1">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-1" class="product-name"><a class="header" href="#商品2-1">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-1" class="product-name"><a class="header" href="#商品3-1">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="golang/爬虫/xpath语法.html#">首页</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">商品分类</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">购物车</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取所有商品名称
product_names = root.xpath('//div[@class="product"]/h3[@class="product-name"]/text()')
for name in product_names:
    print(name)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"]/h3[@class="product-name"]/text()')提取所有商品名称，并将其打印输出 。</p>
<p>提取所有有货商品的价格
提取所有有货商品的价格：</p>
<p>//div[@class='product'][.//p[@class='stock' and text()='有货']]/p[@class='price']/text()</p>
<p>这个表达式中，//div[@class='product']先定位到所有商品<div>元素，然后通过[.//p[@class='stock' and text()='有货']]筛选出其中库存<p>元素文本为 “有货” 的商品<div>元素，最后通过p[@class='price']/text()获取这些有货商品的价格文本 。在 Python 中，使用lxml库结合 XPath 来提取这些有货商品价格的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-1"><a class="header" href="#假设html为读取的电商网站html页面内容-1">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-2" class="product-name"><a class="header" href="#商品1-2">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-2" class="product-name"><a class="header" href="#商品2-2">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-2" class="product-name"><a class="header" href="#商品3-2">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="golang/爬虫/xpath语法.html#">首页</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">商品分类</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">购物车</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取所有有货商品的价格
prices = root.xpath('//div[@class="product"][.//p[@class="stock" and text()="有货"]]/p[@class="price"]/text()')
for price in prices:
    print(price)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"][.//p[@class="stock" and text()="有货"]]/p[@class="price"]/text()')提取所有有货商品的价格，并将其打印输出 。</p>
<p>找出所有缺货商品
找出所有缺货商品：</p>
<p>//div[@class='product'][.//p[@class='stock' and text()='缺货']]</p>
<p>这个表达式通过//div[@class='product']定位到所有商品<div>元素，再通过[.//p[@class='stock' and text()='缺货']]筛选出其中库存<p>元素文本为 “缺货” 的商品<div>元素 。在 Python 中，使用lxml库结合 XPath 来找出这些缺货商品的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-2"><a class="header" href="#假设html为读取的电商网站html页面内容-2">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-3" class="product-name"><a class="header" href="#商品1-3">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-3" class="product-name"><a class="header" href="#商品2-3">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-3" class="product-name"><a class="header" href="#商品3-3">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="golang/爬虫/xpath语法.html#">首页</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">商品分类</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">购物车</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath找出所有缺货商品
out_of_stock_products = root.xpath('//div[@class="product"][.//p[@class="stock" and text()="缺货"]]')
for product in out_of_stock_products:
    print(etree.tostring(product, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"][.//p[@class="stock" and text()="缺货"]]')找出所有缺货商品，并将其打印输出 。</p>
<p>获取导航菜单项
获取导航菜单项：</p>
<p>//nav[@class='main-nav']//a/text()</p>
<p>这个表达式通过//nav[@class='main-nav']定位到导航栏的<nav>元素，然后通过//a/text()获取该<nav>元素下所有<a>元素的文本内容，即导航菜单项 。在 Python 中，使用lxml库结合 XPath 来获取这些导航菜单项的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-3"><a class="header" href="#假设html为读取的电商网站html页面内容-3">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-4" class="product-name"><a class="header" href="#商品1-4">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-4" class="product-name"><a class="header" href="#商品2-4">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-4" class="product-name"><a class="header" href="#商品3-4">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="golang/爬虫/xpath语法.html#">首页</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">商品分类</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">购物车</a></li>
            <li><a href="golang/爬虫/xpath语法.html#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath获取导航菜单项
nav_items = root.xpath('//nav[@class="main-nav"]//a/text()')
for item in nav_items:
    print(item)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//nav[@class="main-nav"]//a/text()')获取导航菜单项，并将其打印输出 。</p>
<p>XPath 调试技巧
在使用 XPath 的过程中，调试是非常重要的环节，它能帮助我们快速找出表达式中的问题，确保准确地提取到所需的数据。以下介绍几种实用的 XPath 调试技巧 。</p>
<p>分步构建复杂表达式
当面对复杂的 XPath 表达式时，建议逐步构建。例如，在提取电商网站中商品信息时，如果要选择价格大于 50 元且库存大于 10 的商品，可以先分别构建选择所有商品的表达式//div[@class='product']，然后在此基础上添加选择价格的条件//div[@class='product']/p[@class='price']，接着添加价格大于 50 元的条件//div[@class='product'][number(substring-after(p[@class='price']/text(), '元')) &gt; 50]，最后添加库存大于 10 的条件//div[@class='product'][number(substring-after(p[@class='price']/text(), '元')) &gt; 50 and number(.//p[@class='stock']/text()) &gt; 10]。这样分步构建，每一步都可以验证表达式的正确性，便于及时发现和解决问题 。</p>
<p>使用 Chrome 开发者工具的 Elements 面板
Chrome 开发者工具的 Elements 面板是调试 XPath 的有力工具。打开 Chrome 浏览器，按下 F12 键打开开发者工具，切换到 Elements 面板 。在页面中右键点击要调试的元素，选择 “Copy” -&gt; “Copy XPath”，即可获取该元素的 XPath 表达式。然后在 Elements 面板左上角的搜索框中输入 XPath 表达式，按回车键，被选中的元素会在页面中高亮显示，同时在 Elements 面板中也会定位到该元素 。如果表达式有误，不会有元素被选中，此时可以检查表达式的语法、路径是否正确，以及条件是否符合预期 。例如，在调试提取商品名称的 XPath 表达式//div[@class='product']/h3[@class='product-name']/text()时，若没有正确提取到商品名称，可以检查div和h3的class属性是否正确，路径分隔符是否有误等 。</p>
<p>使用 XPath Helper 插件
XPath Helper 是一款 Chrome 浏览器插件，能大大提高 XPath 调试的效率。安装 XPath Helper 插件后，在浏览网页时，按下 Ctrl + Shift + X（Mac 系统为 Command + Shift + X）组合键，即可打开 XPath Helper 面板 。将鼠标悬停在页面元素上，XPath Helper 会自动显示该元素的 XPath 路径 。在 XPath Helper 面板中，可以直接编辑 XPath 表达式，并实时查看匹配结果，匹配到的元素会在页面中高亮显示 。比如，在调试一个复杂的 XPath 表达式时，在 XPath Helper 面板中修改表达式的条件，如将//div[@class='product'][.//p[@class='stock' and text()='有货']]/p[@class='price']/text()中的 “有货” 改为 “缺货”，面板会立即显示修改后的匹配结果，方便我们快速验证不同条件下的表达式正确性 。</p>
<p>XPath 常见问题与解决方案
处理动态生成的内容
在实际网页抓取中，很多内容是通过 JavaScript 动态生成的，这给 XPath 直接提取带来了困难 。例如，在一些电商网站中，商品的评论数据是在页面加载后通过 AJAX 请求获取并动态添加到 DOM 中的。此时，单纯使用 XPath 无法直接获取这些动态生成的内容 。解决办法是结合 Selenium 等自动化测试工具，Selenium 可以模拟浏览器行为，等待页面动态内容加载完成后，再使用 XPath 进行数据提取 。以 Python 为例，使用 Selenium 和 XPath 提取动态生成的商品评论数据的代码示例如下：</p>
<p>from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC</p>
<h1 id="初始化浏览器驱动"><a class="header" href="#初始化浏览器驱动">初始化浏览器驱动</a></h1>
<p>driver = webdriver.Chrome()</p>
<h1 id="打开目标网页"><a class="header" href="#打开目标网页">打开目标网页</a></h1>
<p>driver.get('https://example.com/product/123')</p>
<h1 id="等待评论区域加载完成"><a class="header" href="#等待评论区域加载完成">等待评论区域加载完成</a></h1>
<p>wait = WebDriverWait(driver, 10)
wait.until(EC.presence_of_element_located((By.XPATH, '//div[@class="comments"]')))</p>
<h1 id="使用xpath提取评论内容"><a class="header" href="#使用xpath提取评论内容">使用XPath提取评论内容</a></h1>
<p>comments = driver.find_elements(By.XPATH, '//div[@class="comment-item"]/p[@class="comment-text"]')
for comment in comments:
print(comment.text)</p>
<h1 id="关闭浏览器"><a class="header" href="#关闭浏览器">关闭浏览器</a></h1>
<p>driver.quit()</p>
<p>在上述代码中，首先使用webdriver.Chrome()初始化 Chrome 浏览器驱动，然后打开目标商品页面 。通过WebDriverWait和EC.presence_of_element_located方法，等待评论区域的元素加载完成，确保动态内容已经添加到 DOM 中 。最后使用 XPath 表达式//div[@class="comment-item"]/p[@class="comment-text"]提取评论内容，并打印输出 。</p>
<p>处理 iframe 中的内容
当网页中包含 iframe 时，XPath 无法直接在主文档中定位 iframe 内的元素 。例如，在一个新闻网站中，文章内容可能嵌套在 iframe 中。要提取 iframe 中的内容，需要先切换到 iframe 中，然后再使用 XPath 。以 Python 和 Selenium 为例，切换到 iframe 并提取内容的代码示例如下：</p>
<p>from selenium import webdriver
from selenium.webdriver.common.by import By</p>
<h1 id="初始化浏览器驱动-1"><a class="header" href="#初始化浏览器驱动-1">初始化浏览器驱动</a></h1>
<p>driver = webdriver.Chrome()</p>
<h1 id="打开目标网页-1"><a class="header" href="#打开目标网页-1">打开目标网页</a></h1>
<p>driver.get('https://example.com/article')</p>
<h1 id="定位到iframe元素"><a class="header" href="#定位到iframe元素">定位到iframe元素</a></h1>
<p>iframe = driver.find_element(By.XPATH, '//iframe[@id="article-iframe"]')</p>
<h1 id="切换到iframe"><a class="header" href="#切换到iframe">切换到iframe</a></h1>
<p>driver.switch_to.frame(iframe)</p>
<h1 id="使用xpath提取iframe中的文章标题"><a class="header" href="#使用xpath提取iframe中的文章标题">使用XPath提取iframe中的文章标题</a></h1>
<p>title = driver.find_element(By.XPATH, '//h1[@class="article-title"]').text
print(title)</p>
<h1 id="切换回主文档"><a class="header" href="#切换回主文档">切换回主文档</a></h1>
<p>driver.switch_to.default_content()</p>
<h1 id="关闭浏览器-1"><a class="header" href="#关闭浏览器-1">关闭浏览器</a></h1>
<p>driver.quit()</p>
<p>在上述代码中，首先初始化浏览器驱动并打开目标网页 。然后通过 XPath 定位到 id 为article-iframe的 iframe 元素，使用driver.switch_to.frame(iframe)方法切换到该 iframe 中 。接着在 iframe 内使用 XPath 表达式//h1[@class="article-title"]提取文章标题并打印 。最后使用driver.switch_to.default_content()方法切换回主文档，关闭浏览器 。</p>
<p>XPath 性能优化
在处理大型 XML 或 HTML 文档时，优化 XPath 表达式的性能非常重要，以下是一些建议和方法：</p>
<p>使用绝对路径与相对路径：尽量使用相对路径，因为绝对路径从根节点开始遍历整个文档，相对路径则从当前节点开始，能减少不必要的节点遍历 。例如，./div[@class='product']比/html/body/div[@class='product']更高效 。
减少通配符使用：通配符*和@<em>会匹配所有元素或属性，增加了匹配的范围和时间。在明确知道标签名或属性名时，尽量使用具体的标签名和属性名 。例如，//a[@href]比//</em>[@href]更高效 。
避免复杂的条件表达式：复杂的条件表达式会增加计算量，降低性能。可以将复杂条件拆分成多个简单条件，分步筛选 。例如，//div[@class='product' and contains(.//p[@class='description']/text(), '关键词')]，如果可能，先筛选出class为product的<div>元素，再在这些元素中筛选包含关键词的元素 。
利用索引：如果 XML 文档中有索引机制，可以利用索引来加速 XPath 查询 。不过，并非所有 XML 解析器都支持索引，具体情况需根据使用的解析器来定 。
高级 XPath 技巧
使用索引动态选择元素
在实际的网页结构中，元素的位置可能会随着页面内容的更新或用户交互而发生变化，使用固定索引选择元素可能会导致提取失败。此时，我们可以结合其他条件来动态确定索引 。例如，在一个商品列表页面中，商品的排列顺序可能会根据用户的筛选条件而改变，但每个商品都有一个唯一的data-id属性。假设我们要选择data-id为123的商品的价格元素，该价格元素是商品<div>下的第三个<p>元素，我们可以使用以下 XPath 表达式：</p>
<p>//div[@data-id='123']/p[3]</p>
<p>这样，无论该商品在列表中的位置如何变化，只要其data-id不变，就能准确选择到对应的价格元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的商品列表页面html内容"><a class="header" href="#假设html为读取的商品列表页面html内容">假设html为读取的商品列表页面HTML内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>商品列表</title>
</head>
<body>
    <div class="product" data-id="123">
        <h3 id="商品名称"><a class="header" href="#商品名称">商品名称</a></h3>
        <p>描述信息</p>
        <p>库存信息</p>
        <p class="price">99.99元</p>
    </div>
    <div class="product" data-id="456">
        <h3 id="另一个商品名称"><a class="header" href="#另一个商品名称">另一个商品名称</a></h3>
        <p>描述信息</p>
        <p>库存信息</p>
        <p class="price">129.99元</p>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择data-id为123的商品的价格元素
price = root.xpath('//div[@data-id="123"]/p[3]')
for p in price:
    print(etree.tostring(p, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@data-id="123"]/p[3]')选择data-id为123的商品的价格元素，并将其打印输出 。</p>
<p>使用多重条件
在复杂的网页结构中，单一条件往往无法准确筛选出我们需要的元素，这时就需要使用多重条件 。例如，在一个电商网站的商品评论页面，每个评论<div>元素可能包含评论者的姓名<span class="username">、评论内容<p class="comment-content">和评论时间<span class="comment-time">等信息 。如果我们要选择评论者为 “张三” 且评论时间在 “2024-01-01” 之后的评论内容，可以使用以下 XPath 表达式：</p>
<p>//div[.//span[@class='username' and text()='张三'] and.//span[@class='comment-time' and text() &gt; '2024-01-01']]/p[@class='comment-content']/text()
在这个表达式中，//div表示选择所有的<div>元素，.//span[@class='username' and text()='张三']用于筛选出评论者为 “张三” 的<div>元素，.//span[@class='comment-time' and text() &gt; '2024-01-01']用于筛选出评论时间在 “2024-01-01” 之后的<div>元素 ，通过and连接两个条件，确保同时满足这两个条件的<div>元素被选中，最后通过p[@class='comment-content']/text()获取这些<div>元素下的评论内容 。在 Python 中，使用lxml库结合 XPath 来选择这些评论内容的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站商品评论页面html内容"><a class="header" href="#假设html为读取的电商网站商品评论页面html内容">假设html为读取的电商网站商品评论页面HTML内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>商品评论</title>
</head>
<body>
    <div class="comment">
        <span class="username">李四</span>
        <p class="comment-content">这个商品很不错。</p>
        <span class="comment-time">2023-12-31</span>
    </div>
    <div class="comment">
        <span class="username">张三</span>
        <p class="comment-content">商品质量有待提高。</p>
        <span class="comment-time">2024-01-05</span>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择评论者为“张三”且评论时间在“2024-01-01”之后的评论内容
comments = root.xpath('//div[.//span[@class="username" and text()="张三"] and.//span[@class="comment-time" and text() > "2024-01-01"]]/p[@class="comment-content"]/text()')
for comment in comments:
    print(comment)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[.//span[@class="username" and text()="张三"] and.//span[@class="comment-time" and text() &gt; "2024-01-01"]]/p[@class="comment-content"]/text()')选择符合条件的评论内容，并将其打印输出 。</p>
<p>使用 normalize-space () 处理空白
在从 HTML 文档中提取文本时，常常会遇到文本前后或中间包含空白字符的情况，这会影响数据的准确性和后续处理 。XPath 提供的normalize-space()函数可以去除文本中的前导和尾随空白字符，并将中间的多个连续空白字符替换为单个空格 。例如，在一个包含用户简介的 HTML 页面中，<p class="bio">元素的文本内容可能包含多余的空白字符：</p>
<p class="bio"> 张三， 资深软件工程师， 擅长Python和Java开发。 </p>
使用normalize-space()函数提取该文本时，可以得到整洁的内容 。XPath 表达式如下：
<p>normalize-space(//p[@class='bio']/text())
在 Python 中，使用lxml库结合 XPath 来提取并处理这个文本的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的包含用户简介的html页面内容"><a class="header" href="#假设html为读取的包含用户简介的html页面内容">假设html为读取的包含用户简介的HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户简介</title>
</head>
<body>
    <p class="bio">   张三，  资深软件工程师，  擅长Python和Java开发。   </p>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取并处理文本
bio = root.xpath('normalize-space(//p[@class="bio"]/text())')
print(bio)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('normalize-space(//p[@class="bio"]/text())')提取并处理文本，去除空白字符后，将结果打印输出 。</p>
<p>组合使用轴和函数
轴和函数的组合使用能实现非常复杂的节点定位 。例如，在一个博客网站的 HTML 页面中，每个博客文章<article>元素包含标题<h2>、正文<div class="content">和评论区域<div class="comments">，评论区域内每个评论<div class="comment-item">包含评论者<span class="commenter">和评论内容<p class="comment-text"> 。如果我们要选择所有评论者为 “李四” 的评论内容，并且这些评论所在的文章标题包含 “XPath”，可以使用以下 XPath 表达式：</p>
<p>//article[contains(h2/text(), 'XPath')]//div[@class='comment-item'][.//span[@class='commenter' and text()='李四']]/p[@class='comment-text']/text()
在这个表达式中，//article[contains(h2/text(), 'XPath')]用于选择标题包含 “XPath” 的文章<article>元素，//div[@class='comment-item'][.//span[@class='commenter' and text()='李四']]用于在这些文章中选择评论者为 “李四” 的评论<div>元素，最后通过p[@class='comment-text']/text()获取这些评论的内容 。这里既使用了contains()函数筛选文章标题，又使用了轴来定位评论元素，实现了复杂的节点定位 。在 Python 中，使用lxml库结合 XPath 来选择这些评论内容的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的博客网站html页面内容"><a class="header" href="#假设html为读取的博客网站html页面内容">假设html为读取的博客网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客页面</title>
</head>
<body>
    <article>
        <h2 id="xpath-高级技巧解析"><a class="header" href="#xpath-高级技巧解析">XPath 高级技巧解析</a></h2>
        <div class="content">文章正文内容……</div>
        <div class="comments">
            <div class="comment-item">
                <span class="commenter">张三</span>
                <p class="comment-text">很有帮助的文章。</p>
            </div>
            <div class="comment-item">
                <span class="commenter">李四</span>
                <p class="comment-text">希望能有更多实例。</p>
            </div>
        </div>
    </article>
    <article>
        <h2 id="其他技术文章"><a class="header" href="#其他技术文章">其他技术文章</a></h2>
        <div class="content">……</div>
        <div class="comments">
            <div class="comment-item">
                <span class="commenter">王五</span>
                <p class="comment-text">……</p>
            </div>
        </div>
    </article>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择符合条件的评论内容
comments = root.xpath('//article[contains(h2/text(), "XPath")]//div[@class="comment-item"][.//span[@class="commenter" and text()="李四"]]/p[@class="comment-text"]/text()')
for comment in comments:
    print(comment)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//article[contains(h2/text(), "XPath")]//div[@class="comment-item"][.//span[@class="commenter" and text()="李四"]]/p[@class="comment-text"]/text()')选择符合条件的评论内容，并将其打印输出 。</p>
<p>总结
回顾 XPath 语法要点
在本文中，我们全面深入地学习了 XPath 语法。从基本的路径表达式，如/表示从根节点选取，//用于在文档中任意位置选取节点，到各种选择器，包括通过标签名选择特定元素、使用通配符选择未知元素等，它们是 XPath 定位节点的基础 。属性选择器可以根据元素的属性及属性值来筛选元素，条件表达式则能结合逻辑运算符进行复杂条件的筛选 。位置选择器让我们能够精准地定位到特定位置的元素，文本内容选择器帮助我们根据元素的文本内容进行选择 。XPath 轴定义了节点之间的关系，如子节点轴、父节点轴、兄弟节点轴等，通过这些轴，我们可以在文档的节点树中灵活地导航 。此外，XPath 还提供了丰富的函数，包括字符串函数、数值函数等，这些函数与轴和其他语法的组合使用，使得我们能够实现非常复杂的节点定位和数据提取 。</p>
<p>强调实践的重要性
XPath 语法的学习不仅在于理论知识的掌握，更重要的是通过大量的实践来巩固和提升。建议读者在实际项目中，如网页爬虫开发、XML 数据处理等，积极运用 XPath。可以从简单的网页数据提取开始，逐步尝试处理复杂的网页结构和动态生成的内容 。在实践过程中，不断总结经验，遇到问题时，善于利用调试技巧和工具，如 Chrome 开发者工具、XPath Helper 插件等，快速定位和解决问题 。通过持续的实践，相信大家能够熟练掌握 XPath 语法，将其灵活运用到各种实际场景中，提高数据处理和开发的效率 。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><p><img src="java-sb/image-3.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><code>@JsonProperty("game_name")</code>: 给字段起别名；
<code>@JsonInclude(JsonInclude.Include.NON_NULL)</code>: 字段如果空值，json中不返回</p>
<pre><code class="language-java">data class Game(val id:Int,
                @JsonProperty("wowo")
                @JsonInclude(JsonInclude.Include.NON_NULL)
                val name: String?){

</code></pre>
<pre><code class="language-json">[
  {
    "id": 1,
    "wowo": "csgo"
  },
  {
    "id": 2
  }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>常用注解：</p>
<ul>
<li>
<p>@Controller</p>
<p>标注控制器，如果要包装<code>json</code>数据，需要 配合<code>@ResponseBody</code></p>
</li>
<li>
<p>@RestController</p>
<p>标注控制器，返回 <code>json</code> 数据</p>
</li>
<li>
<p>@RequestMapping</p>
<p>路由映射</p>
</li>
<li>
<p>@SpringBootApplication</p>
<p>应用住程序入口标注</p>
</li>
<li>
<p>@ComponentScan</p>
<p>扫描指定包，给定一个范围，不指定默认扫描全部包</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>启动类位置： 一般放在根目录下</p>
</li>
<li>
<p>Failed to configure a DataSource: 'url' attribute is not specified and no em</p>
<p>缺少配置信息</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="纯内网环境配置maven依赖"><a class="header" href="#纯内网环境配置maven依赖">纯内网环境配置<code>maven</code>依赖</a></h2>
<h3 id="1-将本地下载好的依赖和maven导入到内网电脑"><a class="header" href="#1-将本地下载好的依赖和maven导入到内网电脑">1. 将本地下载好的依赖和maven导入到内网电脑</a></h3>
<p>仓库默认地址：</p>
<blockquote>
<p>C:/user/.m2/repository</p>
</blockquote>
<p>maven默认地址：</p>
<blockquote>
<p>C:/user/.m2/wrapper/....</p>
</blockquote>
<p>比如：</p>
<pre><code class="language-shell">C:\Users\small\.m2\wrapper\dists\apache-maven-3.9.10-bin\53h08a94dg6djh6umvruv7q564\apache-maven-3.9.10
</code></pre>
<h3 id="2-拷贝到内网之后在idea设置中设置离线模式"><a class="header" href="#2-拷贝到内网之后在idea设置中设置离线模式">2. 拷贝到内网之后，在idea设置中设置离线模式</a></h3>
<p><img src="java-sb/image-1.png" alt="alt text" /></p>
<h3 id="3-修改settingsxml两个节点localrepositroy和mirror"><a class="header" href="#3-修改settingsxml两个节点localrepositroy和mirror">3. 修改settings.xml两个节点：<code>localRepositroy</code>和<code>mirror</code></a></h3>
<p>文件路径： apache-maven-3.9.10\conf\settings.xml</p>
<p>localRepository</p>
<pre><code class="language-xml">&lt;localRepository&gt;这里就是maven本地仓库地址&lt;/localRepository&gt;
</code></pre>
<p>mirror</p>
<pre><code class="language-xml">&lt;mirror&gt;
    &lt;id&gt;central&lt;/id&gt;
    &lt;name&gt;central&lt;/name&gt;
    &lt;url&gt;file://仓库地址&lt;/url&gt;
    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
&lt;/mirror&gt;
</code></pre>
<h3 id="4-以上都改完之后要删除每个依赖文件夹下面的_remoterepository文件不删除还是会从源地址拉取"><a class="header" href="#4-以上都改完之后要删除每个依赖文件夹下面的_remoterepository文件不删除还是会从源地址拉取">4. 以上都改完之后，要删除每个依赖文件夹下面的<code>_remote.repository</code>文件，不删除还是会从源地址拉取</a></h3>
<p><img src="java-sb/image-2.png" alt="remote-repository" /></p>
<p>进入到仓库根目录<code>/repository</code>，windows系统cmd执行命令：</p>
<pre><code class="language-shell">for /r %i in (_remote.repository) do del %i
</code></pre>
<h3 id="5-最后项目同步如果还是爆红要根据自己下载的依赖版本具体到版本号"><a class="header" href="#5-最后项目同步如果还是爆红要根据自己下载的依赖版本具体到版本号">5. 最后项目同步，如果还是爆红，要根据自己下载的依赖版本具体到版本号</a></h3>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><p><code>@JsonProperty("game_name")</code>: 给字段起别名；
<code>@JsonInclude(JsonInclude.Include.NON_NULL)</code>: 字段如果空值，json中不返回</p>
<pre><code class="language-java">data class Game(val id:Int,
                @JsonProperty("wowo")
                @JsonInclude(JsonInclude.Include.NON_NULL)
                val name: String?){

</code></pre>
<pre><code class="language-json">[
  {
    "id": 1,
    "wowo": "csgo"
  },
  {
    "id": 2
  }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>常用注解：</p>
<ul>
<li>
<p>@Controller</p>
<p>标注控制器，如果要包装<code>json</code>数据，需要 配合<code>@ResponseBody</code></p>
</li>
<li>
<p>@RestController</p>
<p>标注控制器，返回 <code>json</code> 数据</p>
</li>
<li>
<p>@RequestMapping</p>
<p>路由映射</p>
</li>
<li>
<p>@SpringBootApplication</p>
<p>应用住程序入口标注</p>
</li>
<li>
<p>@ComponentScan</p>
<p>扫描指定包，给定一个范围，不指定默认扫描全部包</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>启动类位置： 一般放在根目录下</p>
</li>
<li>
<p>Failed to configure a DataSource: 'url' attribute is not specified and no em</p>
<p>缺少配置信息</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><p>brew异常</p>
<pre><code class="language-shell">yunhai@bogon Downloads % brew
Traceback (most recent call last):
        11: from /usr/local/Homebrew/Library/Homebrew/brew.rb:13:in `&lt;main&gt;'
        10: from /usr/local/Homebrew/Library/Homebrew/brew.rb:13:in `require_relative'
         9: from /usr/local/Homebrew/Library/Homebrew/global.rb:26:in `&lt;top (required)&gt;'
         8: from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems/core_ext/kernel_require.rb:54:in `require'
         7: from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems/core_ext/kernel_require.rb:54:in `require'
         6: from /usr/local/Homebrew/Library/Homebrew/os.rb:1:in `&lt;top (required)&gt;'
         5: from /usr/local/Homebrew/Library/Homebrew/os.rb:19:in `&lt;module:OS&gt;'
         4: from /usr/local/Homebrew/Library/Homebrew/os/mac.rb:52:in `prerelease?'
         3: from /usr/local/Homebrew/Library/Homebrew/os/mac.rb:18:in `version'
         2: from /usr/local/Homebrew/Library/Homebrew/os/mac.rb:18:in `new'
         1: from /usr/local/Homebrew/Library/Homebrew/os/mac/version.rb:29:in `initialize'
/usr/local/Homebrew/Library/Homebrew/version.rb:369:in `initialize': Version value must be a string; got a NilClass () (TypeError)
</code></pre>
<p>重置试试：</p>
<blockquote>
<p>yunhai@bogon Downloads % brew update-reset</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mermaid"><a class="header" href="#mermaid">mermaid</a></h1>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid">gantt
    title A ads
    dateFormat  MM-DD
    section A
        A :a1, 08-22,2d
        B :after a4, 3d
    
</pre>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid"> graph LR
      A[&quot;$$x^2$$&quot;] --&gt;|&quot;$$\sqrt{x+3}$$&quot;| B(&quot;$$\frac{1}{2}$$&quot;)
      A --&gt;|&quot;$$\overbrace{a+b+c}^{\text{note}}$$&quot;| C(&quot;$$\pi r^2$$&quot;)
      B --&gt; D(&quot;$$x = \begin{cases} a &amp;\text{if } b \\ c &amp;\text{if } d \end{cases}$$&quot;)
      C --&gt; E(&quot;$$x(t)=c_1\begin{bmatrix}-\cos{t}+\sin{t}\\ 2\cos{t} \end{bmatrix}e^{2t}$$&quot;)

</pre>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant 1 as $$\alpha$$
    participant 2 as $$\beta$$
    1-&gt;&gt;2: Solve: $$\sqrt{2+2}$$
    2--&gt;&gt;1: Answer: $$2$$
    Note right of 2: $$\sqrt{2+2}=\sqrt{4}=2$$

</pre>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid">pie
    &quot;A&quot;:12
    &quot;B&quot;:33
    &quot;C&quot;:52
    
</pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="mermaid-一个强大的文本转图表的工具"><a class="header" href="#mermaid-一个强大的文本转图表的工具"><a href="https://mermaid.js.org/syntax/gantt.html">mermaid</a> 一个强大的文本转图表的工具。</a></h3>
<p>https://mermaid.js.org/syntax/gantt.html</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid">stateDiagram-v2
    State1: The state with a note
    note right of State1
        Important information! You can write
        notes.
    end note
    State1 --&gt; State2
    note left of State2 : This is the note to the left.
</pre>
<pre class="mermaid">mindmap
Root
    A
      B
      C

</pre>
<pre class="mermaid">mindmap
    a
        A--B(这是一个)
        B--C(asdf)

</pre>
<pre class="mermaid">flowchart
    A &amp; B--&gt; C 
    C &lt;--&gt; D(a) --&gt; E
    A --&gt; E
</pre>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid">zenuml
    title Demo
    @CloudSQL John
    @CloudSQL Alice
    
     Alice-&gt;John: Hello John, how are you?
     John-&gt;Alice: Great!
    Alice-&gt;John: See you later!

</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nas"><a class="header" href="#nas">nas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>群晖nas配置 ssh连接，root用户登录</p>
<p>群晖默认不支持root权限登录，需要修改权限</p>
<ol>
<li>
<p>普通管理员用户登录之后，找到 <code>/etc/ssh/sshd_config</code>文件</p>
</li>
<li>
<p>修改sshd_config 权限</p>
<pre><code>chmod 755 sshd_config 
</code></pre>
</li>
<li>
<p>编辑<code>sshd_config</code>文件，找到</p>
<pre><code>#PermitRootLogin prohibit-password  
# 修改成 yes
PermitRootLogin yes
</code></pre>
<p>退出编辑</p>
</li>
<li>
<p>修改root密码</p>
<pre><code>synouser --setpw root 这里是新密码
</code></pre>
</li>
<li>
<p>退出重新用root登录 . OK!</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="一个端口配置多个服务"><a class="header" href="#一个端口配置多个服务">一个端口配置多个服务</a></h3>
<p>实验阶段-------</p>
<pre><code>server {         
    listen       80;  
    server_name  apitest.aa.com;  
    location / {
      proxy_pass http://10.26.31.176:8081; #微服务地址测试环境
      root   html;  
      index  index.html index.htm;  

    }   
 }

 

server {         
    listen       80;  
    server_name  api.aa.com;  
    location / {  
        proxy_pass http://10.26.31.176:8080;   #微服务地址线上环境
        root   html;  
        index  index.html index.htm;  
    }   
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="构建nginx容器"><a class="header" href="#构建nginx容器">构建nginx容器</a></h3>
<pre><code class="language-shell">docker run -itd --name=nginx -p 8088:80 -p 443:443 -v /home/zouni/nginx/conf.d:/etc/nginx/conf.d -v /home/zouni/web/static:/home/zouni/web/static –restart=always –user=root nginx 
 --privileged=true
docker run -itd --name=nginx -p 8088:80 -p 443:443 -v /home/zouni/nginx/conf.d:/etc/nginx/conf.d -v /home/zouni/web/static:/home/zouni/web/static -user=root nginx:latest
</code></pre>
<p>docker run -itd --name=nginx -p 8088:80 -p 443:443 -v /home/zouni88/nginx/conf.d:/etc/nginx/conf.d -v /home/zouni/web/static:/home/zouni88/web/static --restart=always -user=root -privileged=true nginx:latest</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="启动"><a class="header" href="#启动">启动</a></h4>
<pre><code>nginx
</code></pre>
<h4 id="查看帮助"><a class="header" href="#查看帮助">查看帮助</a></h4>
<pre><code>nginx -h  
</code></pre>
<h4 id="查看版本-1"><a class="header" href="#查看版本-1">查看版本</a></h4>
<pre><code>nginx -v
</code></pre>
<h4 id="查看配置参数"><a class="header" href="#查看配置参数">查看配置参数</a></h4>
<pre><code>nginx -V
</code></pre>
<h4 id="指定参数"><a class="header" href="#指定参数">指定参数</a></h4>
<pre><code>nginx -s
</code></pre>
<h4 id="测试配置参数是否正确"><a class="header" href="#测试配置参数是否正确">测试配置参数是否正确</a></h4>
<pre><code>nginx -t -C filename
</code></pre>
<h4 id="测试配置是否正确"><a class="header" href="#测试配置是否正确">测试配置是否正确</a></h4>
<pre><code>nginx -t   
</code></pre>
<h4 id="重载每次修改配置信息都需要重载nginx"><a class="header" href="#重载每次修改配置信息都需要重载nginx">重载，每次修改配置信息都需要重载nginx</a></h4>
<pre><code>nginx -s reload
</code></pre>
<h4 id="停止运行"><a class="header" href="#停止运行">停止运行</a></h4>
<pre><code>nginx -s stop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="下载官方nginx-包"><a class="header" href="#下载官方nginx-包">下载官方nginx 包</a></h3>
<blockquote>
<p>wget http://nginx.org/download/nginx-1.10.1.tar.gz</p>
</blockquote>
<h3 id="配置nginx"><a class="header" href="#配置nginx">配置nginx</a></h3>
<p>#--prefix 指定安装的目录
#/usr/local/nginx 是安装目录，不能和自己下载的文件目录重了
#./configure --prefix=/usr/local/nginx</p>
<p>#带ssl  stub_status模块 添加strem模块 –with-stream，这样就能传输tcp协议了
#http_stub_status_module  状态监控
#http_ssl_module    配置https
#stream  配置tcp得转发
#http_gzip_static_module 压缩
#http_sub_module  替换请求</p>
<p>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-stream</p>
<p>#带用户得方式
./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-stream --with-http_gzip_static_module --with-http_sub_module</p>
<hr />
<h3 id="编译-安装"><a class="header" href="#编译-安装">编译 安装</a></h3>
<blockquote>
<p>make &amp;&amp; make install</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="403异常"><a class="header" href="#403异常">403异常</a></h3>
<p>第一次配置一般是权限问题
/etc/nginx/nginx.conf</p>
<p>use nginx;
改为：
use root;</p>
<div style="break-before: page; page-break-before: always;"></div><p>配置静态站点，有些时候需要返回固定页面，访问url: /site/pageA /site/pageB 都返回index.html页面，这时候需要用到下面配置</p>
<pre><code>location / {
    try_files $uri /index.html;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-shell">server {
    # 监听的端口号
    listen      80;
    # 域名
    server_name your_domain;
    charset     utf-8;

    # 最大的文件上传尺寸
    client_max_body_size 75M;

    # 静态文件访问的url
    location / {
        # 静态文件地址
       root /root/web/static/admin;
        # 过期时间
       #expires 30d;
    }
    # vue 配置 单页面 访问，统统指向index
error_page 400 304 404 500 502 503 504  /;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公司里接口编写规范"><a class="header" href="#公司里接口编写规范">公司里接口编写规范：</a></h1>
<h2 id="返回值的规范"><a class="header" href="#返回值的规范">返回值的规范：</a></h2>
<pre><code class="language-json">{
    "code":200,
    "msg": "",
    "data":{
        "name":'xxx',
        "age":'xxx'
    }
}
</code></pre>
<h2 id="状态码的规范"><a class="header" href="#状态码的规范">状态码的规范：</a></h2>
<ol>
<li>200：成功。</li>
<li>401：没有授权。</li>
<li>400：参数错误。</li>
<li>500：服务器错误。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="性能测试工具使用"><a class="header" href="#性能测试工具使用">性能测试工具使用</a></h2>
<p>1.安装</p>
<pre><code>git clone https://github.com/wg/wrk
cd wrk
make # 编译

cp wrk /usr/local/sbin # 二进制文件 放入非管理员目录，可直接运行命令
</code></pre>
<blockquote>
<p>wrk http://163.com</p>
</blockquote>
<pre><code>  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    32.49ms   56.14ms 230.86ms   84.38%
    Req/Sec   637.05    222.35     1.09k    63.00%
  12710 requests in 10.03s, 6.71MB read
Requests/sec:   1267.57
Transfer/sec:    685.72KB
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody>
<tr><td>trigger</td><td>触发</td></tr>
<tr><td>necessary</td><td>必要的</td></tr>
<tr><td>depending</td><td>依赖</td></tr>
<tr><td>logic</td><td>逻辑</td></tr>
<tr><td>acquire</td><td>获取</td></tr>
<tr><td>heavy</td><td>重；大；沉重</td></tr>
<tr><td>separate</td><td>单独的，分离的</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ipython是一个增强的shell工具"><a class="header" href="#ipython是一个增强的shell工具">IPython是一个增强的shell工具,</a></h3>
<p>%cd —更改当前工作目录<br />
%edit —打开编辑器并在关闭编辑器后执行键入的代码<br />
%env —显示当前环境变量<br />
%pip install [pkgs] —在不离开交互式shell的情况下安装软件包<br />
%time和%timeit—定时执行Python代码</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="windows"><a class="header" href="#windows">windows</a></h2>
<pre><code>-b 绑定ip地址
 python -m http.server -b 192.168.1.145 8888

</code></pre>
<h2 id="mac-系统"><a class="header" href="#mac-系统">Mac 系统</a></h2>
<pre><code class="language-shell">python -m SimpleHTTPServer 8888
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="python-小图片合成大图片"><a class="header" href="#python-小图片合成大图片">python 小图片合成大图片</a></h3>
<p>主要代码放在<code>ConcatImg/concat_img/concat.py</code>这个文件
https://github.com/SmallCao/ConcatImg</p>
<p>最终效果
<img src="python//res/python/aaa.jpg" alt="原图" /><br />
<img src="python//res/python/bbb.png" alt="局部细节" /><br />
<img src="python//res/python/ccc.png" alt="效果图" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="请求网页内容"><a class="header" href="#请求网页内容">请求网页内容</a></h3>
<pre><code class="language-python"># features : 解析器类型
result = BeautifulSoup(pagecontent,features = 'html.parser')
# 获取所有ul标签
result.find_all('ul',id='list')



</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="pip-安装软件"><a class="header" href="#pip-安装软件">pip 安装软件</a></h3>
<p><code>-U</code> : 升级到最新版本<br />
<code>-i</code> : 指定下载库源</p>
<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U funcat
</code></pre>
<h3 id="pip-更新失败"><a class="header" href="#pip-更新失败">pip 更新失败</a></h3>
<pre><code>pip install --upgrade pip
</code></pre>
<p>更新失败
<img src="python/enviroment//res/python/pip_update.png" alt="pip更新" /></p>
<p>解决办法：
重新下载安装</p>
<pre><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

</code></pre>
<p>强制安装：</p>
<pre><code>python get-pip.py --force-reinstall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="修改源的两种方式"><a class="header" href="#修改源的两种方式">修改源的两种方式</a></h3>
<ol>
<li>临时修改 <code>-i</code> 指定源 安装指定的 model<br />
<code>-U</code> : 升级到最新版本<br />
<code>-i</code> : 指定下载库源</li>
</ol>
<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U funcat
</code></pre>
<ol start="2">
<li>永久修改</li>
</ol>
<pre><code>pip install pip -U
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/

</code></pre>
<h3 id="源"><a class="header" href="#源">源</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>source</th></tr></thead><tbody>
<tr><td>清华</td><td>https://pypi.tuna.tsinghua.edu.cn/simple</td></tr>
<tr><td>阿里</td><td>https://mirrors.aliyun.com/pypi/simple/</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="生成配置文件"><a class="header" href="#生成配置文件">生成配置文件</a></h3>
<pre><code class="language-Shell">jupyter notebook --generate-config
</code></pre>
<h3 id="生成密钥"><a class="header" href="#生成密钥">生成密钥</a></h3>
<pre><code class="language-Shell">jupyter notebook password
# 设置密码：123456

</code></pre>
<h3 id="如下地址"><a class="header" href="#如下地址">如下地址</a></h3>
<pre><code class="language-Shell">/root/.jupyter/jupyter_notebook_config.json
# 生成密钥如下：
sha1:23524a335a85:461a1f37e8e32af1ab8899329b3e41c41ea6e546
</code></pre>
<p><img src="python/enviroment/anaconda//res/conda/jupyter_1.png" alt="jupyter" /></p>
<h3 id="修改配置文件"><a class="header" href="#修改配置文件">修改配置文件</a></h3>
<pre><code>vi /root/.jupyter/jupyter_notebook_config.py
</code></pre>
<p>修改如下内容：</p>
<pre><code class="language-Shell"># 允许 作为root访问
c.NotebookApp.allow_root = True
# 允许访问的主机ip  * 随意访问
c.NotebookApp.ip='*'   
# 密钥：/root/.jupyter/jupyter_notebook_config.json 文件的内容
c.NotebookApp.password = u'sha1:03...  '
# 修改工作目录
c.NotebookApp.notebook_dir='filepath'
</code></pre>
<p>修改完之后，重新启动<code>jupyter notebook</code>，浏览器打开<code>127.0.0.1:8888</code>输入刚开始设置的密码就正常登录了</p>
<div style="break-before: page; page-break-before: always;"></div><p>修改镜像源为国内源，方便快速下载</p>
<p>直接创建环境，并下载<code>tensorflow-gpu</code></p>
<pre><code class="language-Shell">conda create -n tf2 tensorflow-gpu
</code></pre>
<p>激活环境</p>
<pre><code class="language-Shell">source activate

conda activate tf2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>生成配置文件：<code>conda config</code>命令</p>
<pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/

conda config --set show_channel_urls yes
</code></pre>
<p>会在用户根目录下生成<code>.condarc</code>文件</p>
<p><img src="python/enviroment/anaconda//res/conda/conda_1.png" alt="condarc" /></p>
<p><code>conda info </code> 查看是否生效</p>
<p><img src="python/enviroment/anaconda//res/conda/conda_2.png" alt="condarc" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>创建虚拟环境，并指定安装的model</p>
<pre><code>conda create -n env_name script_name
F:
conda create -n tensorflow tensorflow-gpu==2.1
</code></pre>
<p>指定要安装的<code>model</code>版本，conda会自动安装所有关联的包</p>
<div style="break-before: page; page-break-before: always;"></div><p>查看所有创建的虚拟环境</p>
<pre><code>conda info -e
or
conda env list
</code></pre>
<p>创建虚拟环境</p>
<pre><code>conda create -n envname
</code></pre>
<p>激活虚拟环境<br />
# centos 需要执行
source activate</p>
<pre><code>conda activate envname
</code></pre>
<p>关闭虚拟环境</p>
<pre><code>conda deactivate envname    
</code></pre>
<p>删除虚拟环境</p>
<pre><code>conda remove -n envname --all
</code></pre>
<p>重命名环境 =&gt; 先clone 再重建 == 克隆or移植环境</p>
<pre><code>conda create -n python_basic --clone matplotlib_basic
</code></pre>
<h2 id="在命令行提示符前出现-base-当前激活的环境名字"><a class="header" href="#在命令行提示符前出现-base-当前激活的环境名字">在命令行提示符前出现 (base) 当前激活的环境名字</a></h2>
<h3 id="关闭命令"><a class="header" href="#关闭命令">关闭命令</a></h3>
<pre><code>conda config --set changeps1 false
</code></pre>
<h3 id="打开提示命令"><a class="header" href="#打开提示命令">打开提示命令</a></h3>
<pre><code>conda config --set changeps1 true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>session 过期时间</p>
<pre><code class="language-python">def login():   
    session.permanent = True
    app.permanent_session_lifetime = timedelta(minutes=1) # 设置session到期时间
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="pip3-安装-uwsgi遇到异常"><a class="header" href="#pip3-安装-uwsgi遇到异常">pip3 安装 uwsgi遇到异常：</a></h3>
<blockquote>
<p><strong>Exception: you need a C compiler to build uWSGI</strong></p>
</blockquote>
<p><strong>解决办法</strong>：</p>
<pre><code>yum install gcc
</code></pre>
<h3 id="安装完c解释器后没有-又提示没找到python文件"><a class="header" href="#安装完c解释器后没有-又提示没找到python文件">安装完c解释器后没有 又提示没找到python文件</a></h3>
<blockquote>
<p>plugins/python/uwsgi_python.h:2:10: fatal error: Python.h: No such file or directory</p>
</blockquote>
<p><strong>解决办法</strong>：</p>
<blockquote>
<p>安装<code>python3-dev</code>,正常这么安装 提示找不到,先搜索</p>
</blockquote>
<pre><code class="language-shell">yum search python3 dev
</code></pre>
<p><img src="python/flask//res/python/uwsgi_1.png" alt="uwsgi1" /></p>
<blockquote>
<p>因为当前版本是<code>python3.6</code>, 所以最终找到<code>python36-devel</code> 并安装</p>
</blockquote>
<pre><code class="language-Shell">yum install python36-devel
</code></pre>
<p><img src="python/flask//res/python/uwsgi_2.png" alt="uwsgi2" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>1.本地测试需要修改<code>hosts文件</code>：<code>C:\Windows\System32\drivers\etc\hosts</code>目录</p>
<pre><code>127.0.0.1	zouni.vip
127.0.0.1	student.zouni.vip
</code></pre>
<p>2.代码中设置：
修改蓝图 <code>subdomain</code> 为指定的子域名</p>
<pre><code class="language-python">bp = Blueprint('cms', __name__,  subdomain='cms')
</code></pre>
<p>3.设置 <code>config</code> 配置 <code>SERVER_NAME=主域名</code></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="flask-migrate-坑"><a class="header" href="#flask-migrate-坑">flask-migrate 坑</a></h3>
<ol>
<li>字段长度更新会提示 <code>No changes in schema detected.</code></li>
</ol>
<p>解决办法：初始化Migrate的时候增加属性<code>compare_type</code>为True</p>
<pre><code class="language-python">Migrate(app=app, db=db,render_as_batch = True,compare_type = True)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="初始化-2"><a class="header" href="#初始化-2">初始化</a></h3>
<p>初始化迁移文件</p>
<pre><code>python manage.py db init
</code></pre>
<p>将模型映射 添加到文件中</p>
<pre><code>python manage.py db migrate
</code></pre>
<p>最后 映射到数据库中：</p>
<pre><code>python manage.py db upgrade
</code></pre>
<h3 id="managepy-添加数据"><a class="header" href="#managepy-添加数据">manage.py 添加数据</a></h3>
<p>命令行 添加数据</p>
<pre><code>python manage.py create_user -u yunhai -e cao_cgq@163.com -p 1234
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><p>ajax 收到服务器端返回请求<code>302</code>,服务端给定重定向地址</p>
<p>服务端返回</p>
<pre><code class="language-python">{'code': 302, 'data': '/cms/'}
</code></pre>
<p>前端处理</p>
<pre><code class="language-javascript">$(function () {
  var url = window.location.pathname
  $.ajax({
      url: url+'logout',
      type: 'get',
      dataType:'json'
      success: function (data,status) {
          // var datas = JSON.parse(data)
          if(data.code === 302){
              location.href = data.data;
          }
          alert('重定向')
      },
      error: function (data) {
          console.log(data.toString())
      }
  })  
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><p>蓝图自定义模板文件夹<code>template_folder</code>注意点：</p>
<p>如果<code>app/templates</code>中有<code>index.html</code><br />
并且<code>app/cms/templates</code>也有<code>index.html</code>文件<br />
渲染模板会优先查找<code>app/templates</code>目录下。<br />
蓝图如果要正常使用，创建规则必须是<code>app/cms/templates/cms/index.html</code>，渲染<code>render_template('cms/index.html')</code>
完整例子：</p>
<pre><code class="language-python">bp = Blueprint('cms', __name__, url_prefix='/cms', template_folder='templates')

@bp.route('/cms/index')
def index():
  return render_template('cms/index.html'）
</code></pre>
<p>flask模板查找规则是优先项目根目录``</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><p>docker run -itd --name=nginx -p 80:80 -d -v /usr/local/small/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /usr/local/small/nginx/conf.d:/etc/nginx/conf.d -v /usr/local/small/web/:/root/web/ -d nginx</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="supervisor是进程守护服务"><a class="header" href="#supervisor是进程守护服务">supervisor是进程守护服务</a></h3>
<p>安装supervisor有以下操作</p>
<p>supervisor必须用python2</p>
<pre><code class="language-Shell">pip2 install supervisor
</code></pre>
<p>创建supervisor.conf 配置文件</p>
<pre><code class="language-Shell"># supervisor的程序名字
[program:项目名字]
# supervisor执行的命令
command=uwsgi --ini uwsgi.ini
# 项目的目录
directory = /项目路径
# 开始的时候等待多少秒
startsecs=0
# 停止的时候等待多少秒
stopwaitsecs=0  
# 自动开始
autostart=true
# 程序挂了后自动重启
autorestart=true
# 输出的log文件
stdout_logfile=/var/log/supervisord.log
# 输出的错误文件
stderr_logfile=/var/log/supervisord.err

[supervisord]
# log的级别
loglevel=debug

[inet_http_server]
# supervisor的服务器
port = :9001
# 用户名和密码
username = admin
password = 123

# 使用supervisorctl的配置
[supervisorctl]
# 使用supervisorctl登录的地址和端口号
serverurl = http://127.0.0.1:9001

# 登录supervisorctl的用户名和密码
username = admin
password = 123

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

</code></pre>
<h4 id="supervisor命令操作"><a class="header" href="#supervisor命令操作">supervisor命令操作</a></h4>
<p>启动supervisor</p>
<pre><code class="language-Shell">supervisord -c filename
</code></pre>
<p>重启supervisor</p>
<pre><code class="language-Shell">supervisorctl -u admin -p 123 reload
or
ps -aux | grep supervisor
找到进程
kill -9 [supervisor pid]
</code></pre>
<p>进入supervisor控制台</p>
<pre><code class="language-Shell">supervisorctl -c filename
</code></pre>
<p>查看当前运行状态</p>
<pre><code class="language-Shell">status    
</code></pre>
<p>关闭在运行的程序</p>
<pre><code class="language-Shell">stop
</code></pre>
<p>重启应用</p>
<pre><code class="language-Shell">reload
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="编译配套-ssl的-uwsgi"><a class="header" href="#编译配套-ssl的-uwsgi">编译配套 ssl的 uwsgi</a></h3>
<h4 id="安装编译需要的环境"><a class="header" href="#安装编译需要的环境">安装编译需要的环境</a></h4>
<pre><code>yum install openssl
yum install openssl-devel
</code></pre>
<h4 id="安装-greenlet"><a class="header" href="#安装-greenlet">安装 greenlet</a></h4>
<pre><code>pip3 install greenlet
</code></pre>
<h3 id="找到-greenlet-位置"><a class="header" href="#找到-greenlet-位置">找到 greenlet 位置</a></h3>
<pre><code>/root/.virtualenvs/flask/include/site/python3.6
</code></pre>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<pre><code>CFLAGS="-I/root/.virtualenvs/flask/include/site/python3.6" UWSGI_PROFILE="asyncio" pip install uwsgi --no-use-wheel
</code></pre>
<p>or</p>
<pre><code>CFLAGS="-I/usr/include/openssl" UWSGI_PROFILE_OVERRIDE=ssl=true pip install uwsgi -I --no-cache-dir
</code></pre>
<p>CFLAGS="-I$/usr/bin/python3.6" UWSGI_PROFILE="asyncio" pip3 install uwsgi --no-use-wheel</p>
<p>CFLAGS="-I/usr/local/opt/openssl/include" LDFLAGS="-L/usr/local/opt/openssl/lib" UWSGI_PROFILE_OVERRIDE=ssl=true pip install uwsgi -I --no-cache-dir</p>
<p>CFLAGS="-I/usr/include/openssl" UWSGI_PROFILE_OVERRIDE=ssl=true pip install uwsgi -I --no-cache-dir</p>
<p>sudo CFLAGS="-I/usr/local/opt/openssl/include" LDFLAGS="-L/usr/local/opt/openssl/lib" UWSGI_PROFILE_OVERRIDE=ssl=true pip3 install uwsgi -I --no-cache-dir</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装虚拟环境"><a class="header" href="#安装虚拟环境">安装虚拟环境</a></h3>
<p>安装虚拟环境</p>
<pre><code class="language-Shell">pip2 install virtualenvwrapper
# **查找安装路径**   
which virtualenvwrapper.sh
</code></pre>
<p><img src="python/flask/%E9%83%A8%E7%BD%B2//res/python/bushu_1.png" alt="virtual" /></p>
<p>编辑<code>.bashrc</code></p>
<pre><code class="language-Shell">vim ~/.bashrc
# 增加以下环境变量
export WORKON_HOME=$HOME/.virtualenvs  
source /usr/local/bin/virtualenvwrapper.sh

</code></pre>
<p>立即生效</p>
<pre><code class="language-Shell">source .bashrc
</code></pre>
<p>查找python3路径</p>
<pre><code class="language-Shell">which python3
</code></pre>
<p><img src="python/flask/%E9%83%A8%E7%BD%B2//res/python/bushu_2.png" alt="python3" /></p>
<p>创建虚拟环境</p>
<pre><code class="language-Shell">mkvirtualenv --python=/usr/bin/python3 name-env

workon name-env
</code></pre>
<p>切换/激活 虚拟环境</p>
<pre><code class="language-Shell">workon name-evn

cd ~/.virtualenvs/name-env/bin/
</code></pre>
<p>退出虚拟环境</p>
<pre><code class="language-Shell">deactivate name-env
</code></pre>
<p>删除虚拟环境</p>
<pre><code class="language-shell">rmvirtualenv env-name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-配置-1"><a class="header" href="#mysql-配置-1">mysql 配置</a></h1>
<h3 id="首先查看centos是否已经安装了mysql源-1"><a class="header" href="#首先查看centos是否已经安装了mysql源-1">首先查看centos是否已经安装了mysql源</a></h3>
<pre><code>yum list installed mysql*
如果有就删除
yum remove mysql-community-*

</code></pre>
<h4 id="安装mysql源-1"><a class="header" href="#安装mysql源-1">安装mysql源	</a></h4>
<pre><code class="language-数据库官网地址">https://dev.mysql.com/downloads/repo/yum/
</code></pre>
<pre><code>wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
</code></pre>
<h4 id="安装mysql-1"><a class="header" href="#安装mysql-1">安装mysql</a></h4>
<pre><code>yum -y install mysql57-community-release-el7-10.noarch.rpm
</code></pre>
<h3 id="查看是否已经安装了数据库源-1"><a class="header" href="#查看是否已经安装了数据库源-1">查看是否已经安装了数据库源</a></h3>
<pre><code>yum repolist all | grep mysql
</code></pre>
<h3 id="查看数据库源-1"><a class="header" href="#查看数据库源-1">查看数据库源</a></h3>
<pre><code>/etc/yum.repos.d/mysql-community.repo
修改源可用 mysql80  enable = 1
</code></pre>
<h3 id="安装数据库服务-1"><a class="header" href="#安装数据库服务-1">安装数据库服务</a></h3>
<pre><code>yum install mysql-server
</code></pre>
<h4 id="启动mysql-1"><a class="header" href="#启动mysql-1">启动mysql</a></h4>
<pre><code>systemctl start mysqld.service
</code></pre>
<h4 id="查看状态-1"><a class="header" href="#查看状态-1">查看状态</a></h4>
<pre><code>systemctl status mysqld.service
</code></pre>
<h4 id="查看初始密码-1"><a class="header" href="#查看初始密码-1">查看初始密码</a></h4>
<pre><code>grep "password" /var/log/mysqld.log
</code></pre>
<h4 id="修改密码-1"><a class="header" href="#修改密码-1">修改密码</a></h4>
<pre><code>mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';
</code></pre>
<h5 id="注意密码设置必须要大小写字母数字和特殊符号等不然不能配置成功"><a class="header" href="#注意密码设置必须要大小写字母数字和特殊符号等不然不能配置成功">注意:密码设置必须要大小写字母数字和特殊符号（,/';:等）,不然不能配置成功</a></h5>
<h3 id="开启mysql的远程访问-两种方式-1"><a class="header" href="#开启mysql的远程访问-两种方式-1">开启mysql的远程访问 两种方式</a></h3>
<ul>
<li>方式1</li>
</ul>
<pre><code>grant all privileges on *.* to 'root'@'192.168.0.1' identified by 'password' with grant option;
</code></pre>
<pre><code>flush privileges;
</code></pre>
<ul>
<li>方式2</li>
</ul>
<pre><code>use mysql;
update user set host = '%' where user = 'root';
</code></pre>
<p><code>更细权限之后，一定要刷新一下，否则不会生效</code></p>
<pre><code>flush privileges;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="安装虚拟环境-1"><a class="header" href="#安装虚拟环境-1">安装虚拟环境</a></h3>
<p>安装虚拟环境</p>
<pre><code class="language-Shell">pip2 install virtualenvwrapper
# **查找安装路径**   
which virtualenvwrapper.sh
</code></pre>
<p><img src="python/flask/%E9%83%A8%E7%BD%B2//res/python/bushu_1.png" alt="virtual" /></p>
<p>编辑<code>.bashrc</code></p>
<pre><code class="language-Shell">vim ~/.bashrc
# 增加以下环境变量
export WORKON_HOME=$HOME/.virtualenvs  
source /usr/local/bin/virtualenvwrapper.sh

</code></pre>
<p>立即生效</p>
<pre><code class="language-Shell">source .bashrc
</code></pre>
<p>查找python3路径</p>
<pre><code class="language-Shell">which python3
</code></pre>
<p><img src="python/flask/%E9%83%A8%E7%BD%B2//res/python/bushu_2.png" alt="python3" /></p>
<p>创建虚拟环境</p>
<pre><code class="language-Shell">mkvirtualenv --python=/usr/bin/python3 name-env

workon name-env
</code></pre>
<p>切换/激活 虚拟环境</p>
<pre><code class="language-Shell">workon name-evn

cd ~/.virtualenvs/name-env/bin/
</code></pre>
<p>退出虚拟环境</p>
<pre><code class="language-Shell">deactivate name-env
</code></pre>
<h3 id="安装git用来传代码"><a class="header" href="#安装git用来传代码">安装git用来传代码</a></h3>
<p>安装git</p>
<pre><code class="language-Shell">yum install git
</code></pre>
<pre><code class="language-Shell"># 生成公钥
ssh-keygen -t rsa -C “email”
# 查看公钥
cat ~/.ssh/id_rsa.pub

#同步代码
git clone  
</code></pre>
<h3 id="uwsgi"><a class="header" href="#uwsgi">Uwsgi</a></h3>
<pre><code class="language-Shell">pip3 install uwsgi
</code></pre>
<p>在项目中创建uwsgi.ini配置文件</p>
<pre><code class="language-shell">  [uwsgi]

  # 必须全部为绝对路径
  # 项目的路径
  chdir = /root/flask_f/
  # Django的wsgi文件
  wsgi-file = /root/flask_f/app.py
  # 回调的app对象
  callable = app
  # Python虚拟环境的路径
  home = /root/.virtualenvs/small-env

  # 进程相关的设置
  # 主进程
  master = true
  # 最大数量的工作进程
  processes = 10

  # nginx 直接用socket
  #http            = :80
  socket = /root/flask_f/small.sock

  # 设置socket的权限
  chmod-socket = 666
  # 退出的时候是否清理环境
  vacuum = true
</code></pre>
<p>启动应用服务器 指定项目的<code>uwsgi.ini</code>配置文件</p>
<pre><code class="language-Shell">uwsgi --ini uwsgi.ini
</code></pre>
<h3 id="nginx"><a class="header" href="#nginx">Nginx</a></h3>
<p>Nginx 配置,目录下增加自定义配置文件</p>
<pre><code class="language-Shell">cd /etc/nginx/conf.d
</code></pre>
<pre><code class="language-shell">upstream small{

    server unix:///root/flask_f/small.sock;
}

# 配置服务器
server {
    # 监听的端口号
    listen      80;
    # 域名
    server_name 47.111.249.148;
    charset     utf-8;

    # 最大的文件上传尺寸
    client_max_body_size 75M;  

    # 静态文件访问的url
    location /static {
        # 静态文件地址
        alias /root/flask_f/static;
    }

    # 最后，发送所有非静态文件请求到django服务器
    location / {
        uwsgi_pass  small;
        # uwsgi_params文件地址
        include     /etc/nginx/uwsgi_params;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>查看当前运行的jupyter notebook <code>token</code></p>
<pre><code class="language-Shell">jupyter notebook list
</code></pre>
<p>http://0.0.0.0:8888/?token=3c1c5cc60766ae6c4aea6234268d73b869fb34072b051cef</p>
<p>http://127.0.0.1:8888/?token=3c1c5cc60766ae6c4aea6234268d73b869fb34072b051cef</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="动画"><a class="header" href="#动画">动画</a></h3>
<pre><code class="language-python">from matplotlib import animation,pyplot as plt
import numpy as np
fig,axe = plt.subplots()
x = np.arange(0,2*np.pi,0.01)
line, = axe.plot(x,np.sin(x))

def animations(i):
    line.set_ydata(np.sin(x+i/10))
    return line
def init():
    line.set_ydata(np.sin(x))
    return line

# func 动画更新函数回调
# frames : 帧数，共多少帧 播放完
# init_func : 初始化回调函数
# interval : 刷新间隔 ms 毫秒
# blit ：是否整体刷新
ani = animation.FuncAnimation(fig=fig,func=animations,frames=100,init_func=init,interval=20,blit=False)
plt.show()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="最简单方式创建子图"><a class="header" href="#最简单方式创建子图">最简单方式创建子图</a></h3>
<pre><code class="language-python">import numpy as np
from matplotlib import pyplot as plt

np.random.seed(123456)
# 随机生成1-20的随机数
x = np.random.randint(1, 20, 20)

xmax = x.max()
xmin = x.min()
xmax, xmin
# 数据缩放到0-1的 区间
xx = (x - xmin) / (xmax - xmin)
# 2,1,1,  代表 画子图 2行1列第一 个位置
# 参数中间的逗号可以免掉不写，211
plt.subplot(211)
plt.plot(x)
plt.subplot(2,1,2)
plt.plot(y)

plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt_1.png" alt="plt1" /></p>
<h3 id="创建子图"><a class="header" href="#创建子图">创建子图</a></h3>
<pre><code class="language-python">from matplotlib import pyplot as plt
# 第一个子图 将 整个图分成 2行1列，占据第1个位置
plt.subplot(211)
plt.plot([1,2],[3,4])
# 第二个子图 将整个图分成 2行3列 放在第4个位置，也就是2行第1位
plt.subplot(234)
plt.plot([1,2],[3,4])

plt.subplot(235)
plt.plot([1,2],[3,4])

plt.subplot(236)
plt.plot([1,2],[3,4])

plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt4.png" alt="子图" /></p>
<h3 id="在网格图中指定位置创建子图"><a class="header" href="#在网格图中指定位置创建子图">在网格图中指定位置创建子图</a></h3>
<pre><code class="language-python">from matplotlib import pyplot as plt
# 背景颜色 白色
plt.figure(facecolor='white')
# shape: 网格形状 2行3列 一共6个单元的网格
# loc: 子图要方的位置，[0,0] 表示第一个格子
sub = plt.subplot2grid(shape=[2,3],loc=[0,0],colspan=2)
sub.plot([1,2,3])
sub1 = plt.subplot2grid([2,3],[1,0])
sub1.plot([1,2,3])
sub2 = plt.subplot2grid([2,3],[1,1])
sub2.plot([1,2,3])
sub3 = plt.subplot2grid([2,3],[1,2])
sub3.plot([1,2,3])

plt.show()

</code></pre>
<p><img src="python/matplotlib//res/python/plt5.png" alt="网格子图" /></p>
<h3 id="切片创建子图"><a class="header" href="#切片创建子图">切片创建子图</a></h3>
<pre><code class="language-python">from matplotlib import pyplot as plt
from matplotlib import gridspec as gs
plt.figure(facecolor='white')
gs = gs.GridSpec(3,3)
plt.subplot(gs[0,2])
plt.subplot(gs[1,0])
plt.subplot(gs[2,1:])
plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt6.png" alt="切片子图" /></p>
<h3 id="subplots-创建子图共享xy"><a class="header" href="#subplots-创建子图共享xy">subplots 创建子图，共享x,y</a></h3>
<pre><code class="language-python">from matplotlib import pyplot as plt
# 创建子图 2行3列，共享x ,y 轴坐标
figure,subs = plt.subplots(nrows=2,ncols=3,sharex=True,sharey=True)
figure.set_facecolor('white')
subs[0,0].plot([1,2,3])
subs[1,1].plot([1,2,3])
plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt7.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>散点图</p>
<pre><code class="language-python">from matplotlib import pyplot as plt
x = [1, 2, 3]
y = [3, 4, 5]
plt.scatter(x, y)
plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt2.png" alt="散点图" /></p>
<p>meshgrid生成点阵图</p>
<pre><code class="language-python">from matplotlib import pyplot as plt
x = [1, 2, 3]
y = [3, 4, 5]
xxx, yyy = np.meshgrid(x, y)
plt.scatter(xxx, yyy)
plt.show()
</code></pre>
<p><img src="python/matplotlib//res/python/plt3.png" alt="meshgrid用法" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">import numpy as np

x = [1,2]
y = [2,3]
xx,yy = np.meshgrid(x,y)
# 生成对应的网格坐标点

</code></pre>
<p>Out:</p>
<pre><code class="language-python"># 对应输出坐标点：(1，2),(1,3),(2,2,),(2,3)
[[1 2]
 [1 2]]
[[2 2]
 [3 3]]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>查看数组有多少类别</p>
<pre><code class="language-python">import numpy as np
array = [1,2,3,2,1,2,1]
np.unique(array)

-------------------------
array([1, 2, 3])

</code></pre>
<pre><code class="language-python"># x
np.sum(x)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="图像融合"><a class="header" href="#图像融合">图像融合</a></h3>
<p><code>cv2.addWeighted(src1, alpha, src2, beta, gamma, dst=None, dtype=None)</code></p>
<ul>
<li><code>src1</code> : 图像</li>
<li><code>alpha</code> :  透明系数</li>
<li><code>src2</code> : 图像2</li>
<li><code>beta</code> : 透明系数</li>
<li><code>gamma</code> : 亮度调节</li>
</ul>
<pre><code class="language-python">import cv2
a = cv2.imread('images/aaa.png')
b = cv2.imread('images/bbb.png')
a = a[:b.shape[0],:b.shape[1],:]
res = cv2.addWeighted(src1=a,alpha=0.3,src2=b,beta=1,gamma=0.3)
cv2.imshow('a',a)
cv2.waitKey(1000)
cv2.imshow('b',b)
cv2.waitKey(1000)
cv2.imshow('res',res)
cv2.waitKey(1000)

cv2.destroyAllWindows()

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="读取图片"><a class="header" href="#读取图片">读取图片</a></h3>
<pre><code class="language-python">import cv2
img = cv2.imread('image_path')

</code></pre>
<h3 id="显示图片"><a class="header" href="#显示图片">显示图片</a></h3>
<pre><code class="language-python">
import cv2
img = cv2.imread('image_path')
cv2.imshow('name',img)
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<h3 id="图像形状"><a class="header" href="#图像形状">图像形状</a></h3>
<pre><code class="language-python">import cv2
img = cv2.imread('image_path')
img.shape

</code></pre>
<h3 id="图像分割通道拆分"><a class="header" href="#图像分割通道拆分">图像分割，通道拆分</a></h3>
<pre><code class="language-python">import cv2
img = cv2.imread('image_path')
b,g,r = cv2.split(img)

</code></pre>
<h3 id="图像运算"><a class="header" href="#图像运算">图像运算</a></h3>
<ul>
<li>cv2.add 方法 相加 取最大值255</li>
<li>img_a + img_b ,直接相加结果除255 取模</li>
</ul>
<pre><code class="language-python">import cv2
img_a = cv2.imread('image_a_path')
img_b = cv2.imread('image_b_path')
img_c = cv2.add(img_a,img_b)
img_d = img_a + img_b
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="图像缩放"><a class="header" href="#图像缩放">图像缩放</a></h3>
<ul>
<li>两种方式</li>
</ul>
<ol>
<li><code>dsize</code> : 元组，传入要缩放图像的宽高</li>
</ol>
<pre><code class="language-python">import cv2
img = cv2.imread('img_path')
img1 = cv2.resize(av,dsize=(100,100))
cv2.imshow('img',img)
cv2.imshow('img1',img1)
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<ol start="2">
<li><code>fx fy</code> 参数，分别 修改横列 缩放系数</li>
</ol>
<pre><code class="language-python">import cv2
img = cv2.imread('img_path')
img1 = cv2.resize(img,None,fx=2,fy=2)
cv2.imshow('img',img)
cv2.imshow('img1',img1)
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<h3 id="翻转变换"><a class="header" href="#翻转变换">翻转变换</a></h3>
<p><code>flipCode</code>:</p>
<ul>
<li><code>&gt;1</code> 沿着<code>y axis</code>左右变换</li>
<li><code>=0</code> 沿着<code>x axis</code>上下变换</li>
<li><code>&lt;0</code> 沿着<code>x axis</code>上下 翻转，再沿着<code>y axis</code> 左右反转</li>
</ul>
<pre><code class="language-python">import cv2
img = cv2.imread('img_path')
img1 = cv2.flip(img,flipCode=1)
cv2.imshow('img',img)
cv2.imshow('img1',img1)
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">import cv2
imgpath = 'd:/img.png'
x,y,x1,y1 = 641,165,752,278

img = cv2.imread(imgpath)
img.shape
linet = cv2.LINE_4
img = cv2.rectangle(img, (x, y), (x1, y1), (0, 0, 255), linet,2)
cv2.imshow('name', img)
cv2.waitKey()
cv2.destroyAllWindows()
</code></pre>
<p><img src="python/opencv//res/python/img.png" alt="originimg" />
<img src="python/opencv//res/python/img1.png" alt="originimg1" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><p>pycharm默认会显示 图像窗口在pycharm 上， 单独显示需要去掉以下设置</p>
<p><img src="python/pycharm//res/python/pycharm_2.png" alt="showt" /></p>
<p><img src="python/pycharm//res/python/pycharm_3.png" alt="showt" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>XCTXZDU09E-eyJsaWNlbnNlSWQiOiJYQ1RYWkRVMDlFIiwibGljZW5zZWVOYW1lIjoi5bGx5Lic55CG5bel5aSn5a2mIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlNDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU0YiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1YiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQREIiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFdTIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUFMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiRFBBIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjAwMzI2TFBBQTAwNTAwOCIsImhhc2giOiIxNjc5MTc3Mi8wOi0xNDczMTA4OTgxIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-FNMSclTw4g1JqWPPguaWKx52Mcp2N7DZUMhnWlUOTsNsiK/QdB2pwxX+FvNjEhKdCkAsO111gLa1Q1XXvXRIkMA8BFgYrlxZli9WSyqfbx0CBm35jw8TozH089e4S9iB5c82z6EMPOc+wxdmm1TxSqKOqP+qVmZVbt76vVhQoISb4Fx7EHPi06Po4+r8e40s+chXVGkGZihVcbxwjjSKe0p3ARj4BsXw5v9bznyxw9AU/2vLoyr+xyS49FzSFERnn+EZirf/93bcbzdFGFdNs2secIoi+q2JflgSs+8O6vLFaYx03PCs6W+405J9UziaT8866tgtbRhn/0nLigRq/A==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==</p>
<div style="break-before: page; page-break-before: always;"></div><p>##%  -&gt;   设置开启科学模式之后，就可以分段执行代码</p>
<div style="break-before: page; page-break-before: always;"></div><p>pycharm使用相对路径，要修改当前解释器的工作路径到当前项目路径</p>
<p><img src="python/pycharm//res/python/pycharm_1.png" alt="pycharm" /></p>
<p>修改完之后重启解释器，就可以了</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="pycharm-设置代理"><a class="header" href="#pycharm-设置代理">pycharm 设置代理</a></h4>
<p><img src="python/pycharm//res/python/proxy.png" alt="proxy" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 4</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="windows-平台-环境配置"><a class="header" href="#windows-平台-环境配置">windows 平台 环境配置</a></h3>
<ol>
<li>首先安装pyqt5</li>
</ol>
<pre><code>pip install sip    //这个是pyqt开发商提供的支持包
pip install pyqt5
pip install pyqt5-tools
</code></pre>
<h3 id="pycharm-配置pyqt-可拖拽控件工具"><a class="header" href="#pycharm-配置pyqt-可拖拽控件工具">pycharm 配置pyqt 可拖拽控件工具</a></h3>
<ol>
<li>
<p>打开<code>pycharm</code> 找到<code>Tools/External_Tools</code> 新增一个
<img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/external_tools.png" alt="external" /></p>
</li>
<li>
<p>找到<code>desiginer.exe</code>位置,我的是在anaconda3安装的，就在我的虚拟环境目录下面找到：</p>
<p>D:\Anaconda3\envs\python_basic\Scripts\designer.exe</p>
</li>
</ol>
<p><code>Working directory</code> 这个路径是工作路径，所以一般就填入<code>$FileDir$</code></p>
<p><img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/QtDesigner.png" alt="QtDesigner" /></p>
<ol start="3">
<li>编辑完UI后，还需要转换成<code>py</code>文件才行，所以需要配置pyui转换</li>
</ol>
<p>需要配置下参数：</p>
<pre><code>Program: python.exe 路径
Arguments: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py
Working directory: $FileDir$
</code></pre>
<p><img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/pyui.png" alt="pyui" /></p>
<ol start="4">
<li>第一次使用,先新建一个ui文件先</li>
</ol>
<p><img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/designer_2.png" alt="desiginer_2" /></p>
<p><img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/qtdesigner_1.png" alt="qtdesigner_1" />
妥妥拽拽一些控件华丽界面就完成了</p>
<ol start="5">
<li>
<p>最后一步，转换成<code>py</code>文件
<img src="python/pycharm/pyqt%E9%85%8D%E7%BD%AE//res/python/designer_3.png" alt="designer_3" /></p>
</li>
<li>
<p>end</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="举个例子先"><a class="header" href="#举个例子先">举个例子先</a></h3>
<pre><code class="language-python">
pyinstaller -F xxx.py
</code></pre>
<h3 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h3>
<p><code>-F</code> 打包单个文件
<code>-W</code> 去掉控制台窗口，就那个黑框 cmdshell
<code>-i</code> 图标</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 3</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="call函数使用方法"><a class="header" href="#call函数使用方法">call函数使用方法</a></h3>
<p><code>__call__</code> 函数一般用于实例对象的回调,至少看起来实例对象的调用方式和函数一样
<code>call</code> 函数一个普通的函数，一般实现父类的方法之后，会在父类的<code>__call__</code>函数中回调</p>
<pre><code>class Base():
def call(self):
    print('我是base')

def __call__(self, *args, **kwargs):
    self.call()


class A(Base):

    def __init__(self, name):
        self.name = name

    def call(self):
        print(self.name)
</code></pre>
<p>实例化：</p>
<pre><code>a = A('small')
a()
</code></pre>
<p>输出：</p>
<pre><code>small  
</code></pre>
<p>子类不实现call，则会输出：</p>
<pre><code>我是base
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="pyton对象转字符串"><a class="header" href="#pyton对象转字符串">pyton对象转字符串</a></h3>
<pre><code class="language-python">import json

json.dumps(object,default=lambda obj:obj.__dict__,sort_keys = False,indent = 4,ensure_ascii = False)
json.dumps()     # 对象转json

# lambda  是python类对象的方法  dict 保存的是对象的字典转成的字符串
</code></pre>
<h3 id="json字符串转对象"><a class="header" href="#json字符串转对象">json字符串转对象</a></h3>
<pre><code class="language-python">
# class必须试先init方法
classStus:
  list:list

  def__init__(self,d):
    self.__dict__=d
    jsons = {"list": [{"id": 1, "name": "cao", "age": 10, "profile": "曹的自我介绍"},{"id": 2, "name": "wang", "age": 20, "profile": "王的自我介绍"}]}
    jsons = json.dumps(jsons)    将python字典转成json串
    json.loads(jsons,object_hooks = class)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>获取<code>map</code>第一个元素的方法</p>
<pre><code class="language-python">map = {'a': 1, 'b': 2}
keys = map.keys()
# keys 是 dict_list类型 转成list
keys = list(keys)
# 利用第一个key来获取value
item1 = map[keys[0]]
print(item1)
</code></pre>
<p>打印结果：</p>
<pre><code class="language-shell">1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="open-函数"><a class="header" href="#open-函数">open 函数</a></h3>
<p><strong>open ： 如果文件 不存在，则创建</strong></p>
<pre><code class="language-python">open(filename,mode='')
## 常用mode
w 以写方式打开，

a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)

r+ 以读写模式打开

w+ 以读写模式打开 (参见 w )

a+ 以读写模式打开 (参见 a )

rb 以二进制读模式打开

wb 以二进制写模式打开 (参见 w )

ab 以二进制追加模式打开 (参见 a )

rb+ 以二进制读写模式打开 (参见 r+ )

wb+ 以二进制读写模式打开 (参见 w+ )

ab+ 以二进制读写模式打开 (参见 a+ )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><code>with</code>用法和原理：</p>
<pre><code class="language-python">class Sample:
    def __enter__(self):
        print("In __enter__()")
        return "Foo"
    def __exit__(self, type, value, trace):
        print("In __exit__()")
def get_sample():
    return Sample()
with get_sample() as sample:
    print ("sample:%s" % sample)
</code></pre>
<p>运行代码，输出如下</p>
<pre><code class="language-text">In __enter__()
sample: Foo
In __exit__()
</code></pre>
<p>先执行<code>__enter__</code>方法，最后执行<code>__exit__</code>方法退出</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="getsizeof"><a class="header" href="#getsizeof">getsizeof</a></h3>
<p>x: 对象
return : 对象的字节数
sys.getsizeof(x)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="u"><a class="header" href="#u">u</a></h3>
<p>unicode编码</p>
<h3 id="r"><a class="header" href="#r">r</a></h3>
<p>不转义字符</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">a = 0
try:
    2 / a
except Exception as e:
    print('a---', e)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-python">a = -1
# 断言 a&gt;0才正常执行，否则抛 异常
assert a&gt;0

</code></pre>
<p>[Out]:</p>
<pre><code>Traceback (most recent call last):
  File "D:\Anaconda3\envs\tensorflow\lib\site-packages\IPython\core\interactiveshell.py", line 3331, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File "&lt;ipython-input-45-013be11a8622&gt;", line 3, in &lt;module&gt;
    assert a&gt;0
AssertionError
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="res"><a class="header" href="#res">res</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>bookCollapseSection: true
weight: 2</h2>
<div style="break-before: page; page-break-before: always;"></div><h3 id="下载"><a class="header" href="#下载">下载</a></h3>
<pre><code class="language-shell">go install github.com/shadowsocks/go-shadowsocks2
</code></pre>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<pre><code class="language-shell">go-shadowsocks2 -s 'ss://AEAD_CHACHA20_POLY1305:qaz521..@:8488' -verbose
</code></pre>
<h3 id="客户端"><a class="header" href="#客户端">客户端</a></h3>
<pre><code class="language-shell">go-shadowsocks2 -c 'ss://AEAD_CHACHA20_POLY1305:qaz521..@[zouni.vip]:8488' -verbose -socks :1080 -u -udptun :8053=8.8.8.8:53,:8054=8.8.4.4:53 -tcptun :8053=8.8.8.8:53,:8054=8.8.4.4:53
</code></pre>
<p>go-shadowsocks2 -c 'ss://AEAD_CHACHA20_POLY1305:qaz521..@[zouni.vip]:8488' -redir :1082 -redir6 :1083</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
