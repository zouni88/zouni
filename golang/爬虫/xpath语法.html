<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>xpath语法 - zouni</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zouni</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="当涉及到网页抓取和解析htmlxml文档时xpath是一种强大的定位和提取数据的工具xpathxml-path-language是一种在xml文档中定位节点的语言下面是一些关于xpath的详细解释和案例"><a class="header" href="#当涉及到网页抓取和解析htmlxml文档时xpath是一种强大的定位和提取数据的工具xpathxml-path-language是一种在xml文档中定位节点的语言下面是一些关于xpath的详细解释和案例">当涉及到网页抓取和解析HTML/XML文档时，XPath是一种强大的定位和提取数据的工具。XPath（XML Path Language）是一种在XML文档中定位节点的语言。下面是一些关于XPath的详细解释和案例：</a></h2>
<h3 id="基本介绍"><a class="header" href="#基本介绍">基本介绍</a></h3>
<ol>
<li>XPath基础
XPath的基本语法如下：</li>
</ol>
<pre><code>/         # 从根节点开始
//        # 选择匹配的任何位置
.         # 当前节点
..        # 父节点
@         # 选择属性
[node]    # 选取所有node子元素
[@attr]   # 选取带有attr属性的所有元素
</code></pre>
<ol start="2">
<li>选取节点
使用XPath选取节点，例如：</li>
</ol>
<pre><code>//div          # 选择所有div元素
//div[@class]  # 选择带有class属性的div元素
//div[@id='myId']  # 选择id属性为'myId'的div元素
</code></pre>
<ol start="3">
<li>路径表达式
XPath使用路径表达式来选取节点。例如：</li>
</ol>
<pre><code>//div/p   # 选择所有div下的p元素
//div//p  # 选择所有div下的所有p元素
</code></pre>
<ol start="4">
<li>谓词
XPath中的谓词用于过滤节点。例如：</li>
</ol>
<pre><code>//div[@class='highlight']  # 选择class属性为'highlight'的div元素
//ul/li[position()&lt;3]      # 选择ul下的前两个li元素
</code></pre>
<ol start="5">
<li>通配符
使用通配符匹配元素，例如：</li>
</ol>
<pre><code>    //*        # 选择所有元素
    //div/*    # 选择所有div下的所有子元素
</code></pre>
<ol start="6">
<li>文本提取
使用XPath提取文本内容，例如：</li>
</ol>
<pre><code>//p/text()   # 提取p元素的文本内容
</code></pre>
<h2 id="xpath-简介"><a class="header" href="#xpath-简介">XPath 简介</a></h2>
<h3 id="什么是-xpath"><a class="header" href="#什么是-xpath">什么是 XPath</a></h3>
<h3 id="xpathxml-path-language即-xml-路径语言是一种用于在-xml-和-html-文档中查找信息的语言-它基于-xml-文档的树状结构提供了在数据结构树中找寻节点的能力通过-xpath你可以使用路径表达式来定位和选择文档中的节点或节点集这些节点可以是元素属性文本命名空间处理指令注释以及文档根节点等比如在一个图书管理系统的-xml-文档中你可以利用-xpath-快速定位到所有价格高于-50-元的图书节点获取它们的书名作者等信息"><a class="header" href="#xpathxml-path-language即-xml-路径语言是一种用于在-xml-和-html-文档中查找信息的语言-它基于-xml-文档的树状结构提供了在数据结构树中找寻节点的能力通过-xpath你可以使用路径表达式来定位和选择文档中的节点或节点集这些节点可以是元素属性文本命名空间处理指令注释以及文档根节点等比如在一个图书管理系统的-xml-文档中你可以利用-xpath-快速定位到所有价格高于-50-元的图书节点获取它们的书名作者等信息">XPath（XML Path Language）即 XML 路径语言，是一种用于在 XML 和 HTML 文档中查找信息的语言 。它基于 XML 文档的树状结构，提供了在数据结构树中找寻节点的能力。通过 XPath，你可以使用路径表达式来定位和选择文档中的节点或节点集，这些节点可以是元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点等。比如，在一个图书管理系统的 XML 文档中，你可以利用 XPath 快速定位到所有价格高于 50 元的图书节点，获取它们的书名、作者等信息。</a></h3>
<h3 id="xpath-的重要性"><a class="header" href="#xpath-的重要性">XPath 的重要性</a></h3>
<h4 id="xpath-在多个领域都有着举足轻重的地位"><a class="header" href="#xpath-在多个领域都有着举足轻重的地位">XPath 在多个领域都有着举足轻重的地位：</a></h4>
<ul>
<li>数据提取：在从 XML 或 HTML 文档中提取数据时，XPath 提供了一种简洁且强大的方式。比如从一个电商网站的产品列表页面提取商品名称、价格、评论数等信息，XPath 可以帮助我们精准定位到包含这些数据的 HTML 节点。
网页爬虫：在爬虫开发中，XPath 是常用的解析工具之一。通过编写 XPath 表达式，爬虫可以高效地从网页中提取所需的数据，为后续的数据分析、信息挖掘等提供数据支持 。以爬取新闻网站的文章为例，使用 XPath 可以轻松定位到文章的标题、正文、发布时间等关键信息。
XML 处理：在处理 XML 文档时，无论是验证文档结构、修改节点内容还是进行数据转换，XPath 都能发挥重要作用。例如，在一个企业的订单管理系统中，使用 XML 来存储订单信息，XPath 可以用于查询特定订单、更新订单状态等操作。</li>
</ul>
<p>准备工作<br />
工具推荐<br />
在学习和使用 XPath 的过程中，选择合适的工具可以事半功倍。以下为大家推荐几款常用工具 ：</p>
<p>Chrome 开发者工具：作为 Chrome 浏览器自带的强大工具，按下 F12 键即可呼出。在 “Elements” 面板中，通过鼠标悬停和点击，可以快速定位到网页的 HTML 元素，右键点击元素还能直接复制 XPath 表达式，方便验证和测试。比如在分析一个电商产品页面时，利用 Chrome 开发者工具能迅速获取商品名称、价格等元素的  XPath。<br />
Firefox 开发者工具：同样是浏览器自带工具，功能与 Chrome 开发者工具类似。它也能让你在页面中轻松定位元素，并查看和测试 XPath 表达式。对于习惯使用 Firefox 浏览器的开发者来说，这是一个不错的选择。<br />
在线 XPath 测试工具：如 “XPath Tester” 等在线工具，无需安装，打开网页即可使用。你只需将 XML 或 HTML 文档内容粘贴进去，输入 XPath 表达式，就能实时查看匹配结果。这种工具特别适合初学者快速上手，进行简单的 XPath 练习。<br />
XPath Helper 插件：以 Chrome 浏览器为例，安装 XPath Helper 插件后，在浏览网页时，它会在浏览器界面中添加一个浮动窗口，显示当前鼠标悬停元素的 XPath 路径，并且可以直接在窗口中编辑和测试 XPath 表达式，大大提高了开发效率。<br />
示例 HTML 文档<br />
为了更直观地讲解 XPath 语法，我们先准备一个简单的 HTML 文档示例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
 
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;XPath示例页面&lt;/title&gt;
&lt;/head&gt;
 
&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;h1&gt;欢迎来到XPath学习页面&lt;/h1&gt;
        &lt;p class="intro"&gt;这是一个用于学习XPath的示例页面。&lt;/p&gt;
        &lt;ul id="book-list"&gt;
            &lt;li class="book-item"&gt;
                &lt;a href="book1.html"&gt;《Python编程从入门到实践》&lt;/a&gt;
                &lt;p class="author"&gt;Eric Matthes&lt;/p&gt;
                &lt;p class="price"&gt;79.00元&lt;/p&gt;
            &lt;/li&gt;
            &lt;li class="book-item"&gt;
                &lt;a href="book2.html"&gt;《Effective Java》&lt;/a&gt;
                &lt;p class="author"&gt;Joshua Bloch&lt;/p&gt;
                &lt;p class="price"&gt;99.00元&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;a href="about.html"&gt;关于我们&lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
 
&lt;/html&gt;
</code></pre>
<p>在后续的 XPath 语法讲解中，我们将基于这个示例文档进行演示，通过实际操作来深入理解 XPath 的各种用法。</p>
<p>XPath 基础知识
基本路径表达式
XPath 使用路径表达式来选取 XML 或 HTML 文档中的节点或节点集。以下是一些常用的路径表达式符号及其含义 ：</p>
<p>nodename：选取此节点的所有子节点。例如，在我们的示例 HTML 文档中，ul 会选取所有的 <ul> 元素节点及其子节点。
/：从根节点选取。/html 表示从 HTML 文档的根节点 <html> 开始选取，它是一个绝对路径表达式 。
//：从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。//li 可以选取文档中所有的 <li> 元素节点，无论它们在文档的哪个层级 。
.：选取当前节点。假设我们已经定位到了某个 <div> 元素节点，使用 . 就表示当前这个 <div> 节点本身。
..：选取当前节点的父节点。如果当前节点是 <p> 元素节点，且它是某个 <div> 元素节点的子节点，那么 .. 就可以选取到这个 <div> 父节点。
@：选取属性。//a[@href] 会选取所有带有 href 属性的 <a> 元素节点；//@class 则会选取文档中所有的 class 属性 。
下面通过具体的示例来进一步理解这些路径表达式的用法：</p>
<p>选取所有的 <h1 id="元素节点h1在示例文档中这个表达式会找到-欢迎来到xpath学习页面"><a class="header" href="#元素节点h1在示例文档中这个表达式会找到-欢迎来到xpath学习页面"> 元素节点：//h1。在示例文档中，这个表达式会找到 <h1>欢迎来到XPath学习页面</a></h1> 这一节点。
选取根节点下的 <body> 元素节点的直接子节点 <div>：/html/body/div。这是一个绝对路径，从根节点 <html> 开始，依次经过 <body> 节点，找到其直接子节点 <div>。
选取所有带有 id 属性的 <li> 元素节点：//li[@id]。在示例文档中，虽然没有这样的 <li> 节点，但如果有，就可以通过这个表达式找到。
节点选择
在 XPath 中，可以根据节点的类型和属性来选择节点 ：</p>
<p>元素节点：直接使用元素名称即可选取。如 //book 选取所有的 <book> 元素节点；/html/body/div/ul/li 可以选取到示例文档中 <ul> 下的所有 <li> 元素节点，这是从根节点开始的相对路径选择。
属性节点：使用 @ 符号加上属性名称。//a[@href] 选取所有带有 href 属性的 <a> 元素节点；//li[@class='book-item'] 选取所有 class 属性值为 book-item 的 <li> 元素节点 。
文本节点：使用 text() 函数。//p[@class='intro']/text() 可以选取到 <p class="intro">这是一个用于学习XPath的示例页面。</p> 中的文本内容 “这是一个用于学习 XPath 的示例页面。”；//a/text() 则会选取所有 <a> 元素节点的文本内容 ，如 “《Python 编程从入门到实践》”“《Effective Java》” 等。
通过灵活运用这些节点选择方法，结合路径表达式，我们能够在复杂的 XML 或 HTML 文档中准确地定位到所需的节点，为数据提取和处理打下坚实的基础。</p>
<p>基本选择器
选择特定元素
在 XPath 中，通过标签名可以直接选择文档中的特定元素。例如，在我们的示例 HTML 文档中，要选择所有的<li>元素，可以使用以下 XPath 表达式：</p>
<p>//li</p>
<p>这个表达式会选取文档中所有的<li>元素节点，因为//表示从当前节点开始，无论在文档的哪个层级，都查找所有匹配的节点 ，而li就是我们要选择的标签名。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容"><a class="header" href="#假设html为读取的示例html文档内容">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面"><a class="header" href="#欢迎来到xpath学习页面">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择所有的<li>元素
lis = root.xpath('//li')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
上述代码中，首先使用etree.HTML()方法将 HTML 字符串转换为Element对象，然后通过xpath('//li')选择所有的<li>元素，并将其打印输出。
<p>选择特定路径上的元素
XPath 中可以使用绝对路径和相对路径来选择特定路径上的元素 。</p>
<p>绝对路径：从根节点开始，通过指定每个节点的层级关系来定位目标元素，以正斜杠（/）开头 。例如，在示例 HTML 文档中，要选择<body>元素下的<div>元素下的<h1>元素，可以使用绝对路径：
/html/body/div/h1</p>
<p>相对路径：相对于当前节点的路径，通常使用./表示从当前节点开始查找子节点，../表示查找父节点，//表示跨越多层级查找节点 。假设当前节点是<div>元素，要选择其下的<ul>元素，可以使用相对路径：
./ul</p>
<p>或者使用//跨层级查找：</p>
<p>//ul</p>
<p>绝对路径和相对路径的主要区别在于：绝对路径的定位非常精确，从根节点开始，路径表达明确，能够准确地定位到目标节点 ，但当文档结构发生变化时，路径可能会失效；相对路径更为灵活、简洁，并且具有良好的可维护性，当文档结构发生变化时，相对路径的调整相对简单，但可能无法像绝对路径那样精确定位某些节点，尤其是当文档结构比较复杂或存在多个相同节点名称时 。</p>
<p>通配符选择
XPath 中的通配符可以用于匹配未知的元素节点或属性节点，为我们在选择节点时提供了更大的灵活性 。</p>
<p><em>通配符：匹配任何元素节点。例如，要选择<div>元素下的所有子元素，无论它们是什么标签，可以使用：
//div/</em></p>
<p>在示例 HTML 文档中，这个表达式会选取<div id="content">下的<h1>、<p class="intro">、<ul id="book-list">和<a href="about.html">等所有子元素 。</p>
<p>@<em>通配符：匹配任何属性节点。如果要选择文档中所有元素的所有属性，可以使用：
//@</em></p>
<p>这将返回所有元素的属性，如<div>的id属性、<a>的href属性、<li>的class属性等 。通配符在实际应用中非常有用，特别是当我们不确定文档中某些节点的具体标签名或属性名时，可以借助通配符来进行更宽泛的选择 。</p>
<p>属性选择器
选择具有特定属性的元素
在 XPath 中，通过@符号选择具有特定属性的元素。例如，在我们的示例 HTML 文档中，要选择所有带有href属性的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[@href]</p>
<p>这个表达式中，//a表示选择所有的<a>元素，[@href]则表示筛选出带有href属性的元素。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-1"><a class="header" href="#假设html为读取的示例html文档内容-1">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-1"><a class="header" href="#欢迎来到xpath学习页面-1">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择所有带有href属性的<a>元素
as_with_href = root.xpath('//a[@href]')
for a in as_with_href:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[@href]')选择所有带有href属性的<a>元素，并将其打印输出。</p>
<p>选择特定属性值的元素
使用方括号筛选具有特定属性值的元素。在示例 HTML 文档中，若要选择class属性值为book-item的<li>元素，XPath 表达式为：</p>
<p>//li[@class='book-item']</p>
<p>在这个表达式里，//li表示选择所有的<li>元素，[@class='book-item']用于筛选出class属性值为book-item的元素 。Python 代码实现如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-2"><a class="header" href="#假设html为读取的示例html文档内容-2">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-2"><a class="header" href="#欢迎来到xpath学习页面-2">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值为book-item的<li>元素
lis = root.xpath('//li[@class="book-item"]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>运行这段代码，会输出所有class属性值为book-item的<li>元素内容。</p>
<p>选择具有特定属性的元素（无论值是什么）
使用@*选择具有任意属性的元素。比如，要选择示例 HTML 文档中所有具有属性的元素，可以使用：</p>
<p>//<em>[@</em>]</p>
<p>这个表达式中，//<em>表示选择所有元素，[@</em>]表示筛选出具有任意属性的元素 。在 Python 中，实现代码如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-3"><a class="header" href="#假设html为读取的示例html文档内容-3">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-3"><a class="header" href="#欢迎来到xpath学习页面-3">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择具有任意属性的元素
elements_with_attr = root.xpath('//*[@*]')
for element in elements_with_attr:
    print(etree.tostring(element, encoding='utf-8').decode('utf-8'))
<p>执行代码后，会打印出文档中所有具有属性的元素内容。</p>
<p>条件表达式
使用条件选择元素
在 XPath 中，方括号（[]）用于包含条件表达式，以此筛选出符合特定条件的元素。例如，在我们的示例 HTML 文档中，要选择<ul>下的第一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[1]</p>
<p>这里的[1]表示选择列表中的第一个元素。需要注意的是，在 XPath 中，索引从 1 开始，而不是 0。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-4"><a class="header" href="#假设html为读取的示例html文档内容-4">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-4"><a class="header" href="#欢迎来到xpath学习页面-4">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第一个<li>元素
first_li = root.xpath('//ul/li[1]')
for li in first_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[1]')选择<ul>下的第一个<li>元素，并将其打印输出。</p>
<p>使用 or 条件
在 XPath 中，or运算符用于实现多条件选择，只要满足其中一个条件的元素就会被选中。例如，在示例 HTML 文档中，若要选择class属性值为book-item或者href属性值为about.html的元素，可以使用以下 XPath 表达式：</p>
<p>//*[@class='book-item' or @href='about.html']</p>
<p>在这个表达式中，//*表示选择所有元素，[@class='book-item' or @href='about.html']表示筛选出class属性值为book-item或者href属性值为about.html的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-5"><a class="header" href="#假设html为读取的示例html文档内容-5">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-5"><a class="header" href="#欢迎来到xpath学习页面-5">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值为book-item或者href属性值为about.html的元素
elements = root.xpath('//*[@class="book-item" or @href="about.html"]')
for element in elements:
    print(etree.tostring(element, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//*[@class="book-item" or @href="about.html"]')选择符合条件的元素，并将其打印输出。</p>
<p>使用 not 函数
not()函数用于排除特定条件的元素。例如，在示例 HTML 文档中，要选择所有class属性值不为book-item的<li>元素，可以使用以下 XPath 表达式：</p>
<p>//li[not(@class='book-item')]</p>
<p>在这个表达式中，//li表示选择所有的<li>元素，not(@class='book-item')表示排除class属性值为book-item的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-6"><a class="header" href="#假设html为读取的示例html文档内容-6">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-6"><a class="header" href="#欢迎来到xpath学习页面-6">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择class属性值不为book-item的<li>元素
lis = root.xpath('//li[not(@class="book-item")]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//li[not(@class="book-item")]')选择符合条件的元素，并将其打印输出。</p>
<p>位置选择器
选择第一个元素
在 XPath 中，使用[1]可以选择列表中的第一个元素 。例如，在我们的示例 HTML 文档中，要选择<ul>下的第一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[1]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[1]表示在<ul>元素下选择第一个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-7"><a class="header" href="#假设html为读取的示例html文档内容-7">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-7"><a class="header" href="#欢迎来到xpath学习页面-7">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第一个<li>元素
first_li = root.xpath('//ul/li[1]')
for li in first_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[1]')选择<ul>下的第一个<li>元素，并将其打印输出 。</p>
<p>选择最后一个元素
使用last()函数选择列表中的最后一个元素 。例如，在示例 HTML 文档中，要选择<ul>下的最后一个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[last()]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[last()]表示在<ul>元素下选择最后一个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-8"><a class="header" href="#假设html为读取的示例html文档内容-8">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-8"><a class="header" href="#欢迎来到xpath学习页面-8">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的最后一个<li>元素
last_li = root.xpath('//ul/li[last()]')
for li in last_li:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[last()]')选择<ul>下的最后一个<li>元素，并将其打印输出 。</p>
<p>选择特定位置范围的元素
使用position()函数结合条件表达式来选择特定位置范围的元素 。例如，在示例 HTML 文档中，要选择<ul>下的第二个和第三个<li>元素，可以使用以下 XPath 表达式：</p>
<p>//ul/li[position() &gt; 1 and position() &lt; 4]</p>
<p>在这个表达式中，//ul表示选择所有的<ul>元素，li[position() &gt; 1 and position() &lt; 4]表示在<ul>元素下选择位置大于 1 且小于 4 的<li>元素，即第二个和第三个<li>元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-9"><a class="header" href="#假设html为读取的示例html文档内容-9">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-9"><a class="header" href="#欢迎来到xpath学习页面-9">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul>下的第二个和第三个<li>元素
lis = root.xpath('//ul/li[position() > 1 and position() < 4]')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul/li[position() &gt; 1 and position() &lt; 4]')选择<ul>下的第二个和第三个<li>元素，并将其打印输出 。</p>
<p>文本内容选择
选择包含特定文本的元素
在 XPath 中，使用contains()函数可以选择包含特定文本的元素 。例如，在我们的示例 HTML 文档中，要选择包含 “Python” 文本的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[contains(text(), 'Python')]</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，contains(text(), 'Python')表示筛选出文本内容中包含 “Python” 的元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-10"><a class="header" href="#假设html为读取的示例html文档内容-10">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-10"><a class="header" href="#欢迎来到xpath学习页面-10">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择包含“Python”文本的<a>元素
as_with_python = root.xpath('//a[contains(text(), "Python")]')
for a in as_with_python:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[contains(text(), "Python")]')选择包含 “Python” 文本的<a>元素，并将其打印输出 。</p>
<p>选择完全匹配文本的元素
使用text()函数结合条件表达式选择完全匹配文本的元素 。例如，在示例 HTML 文档中，要选择文本内容为 “关于我们” 的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[text()='关于我们']</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，text()='关于我们'表示筛选出文本内容完全为 “关于我们” 的元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-11"><a class="header" href="#假设html为读取的示例html文档内容-11">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-11"><a class="header" href="#欢迎来到xpath学习页面-11">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择文本内容为“关于我们”的<a>元素
a_with_text = root.xpath('//a[text()="关于我们"]')
for a in a_with_text:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[text()="关于我们"]')选择文本内容为 “关于我们” 的<a>元素，并将其打印输出 。</p>
<p>XPath 轴
子节点轴
使用child::轴选择当前节点的子节点，它用于定位某个节点的直接子元素。例如，在我们的示例 HTML 文档中，要选择<div id="content">下的所有直接子节点<h1>，可以使用以下 XPath 表达式：</p>
<p>//div[@id='content']/child::h1</p>
<p>在这个表达式中，//div[@id='content']用于定位id为content的<div>元素，child::h1则表示选择该<div>元素的直接子节点<h1>。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-12"><a class="header" href="#假设html为读取的示例html文档内容-12">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-12"><a class="header" href="#欢迎来到xpath学习页面-12">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<div id="content">下的所有直接子节点<h1>
h1s = root.xpath('//div[@id="content"]/child::h1')
for h1 in h1s:
    print(etree.tostring(h1, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@id="content"]/child::h1')选择<div id="content">下的所有直接子节点<h1>，并将其打印输出 。实际上，在 XPath 中，child::轴是默认轴，所以上述表达式也可以简写为：</p>
<p>//div[@id='content']/h1</p>
<p>父节点轴
使用parent::轴选择当前节点的父节点 。例如，在示例 HTML 文档中，要选择<p class="author">元素的父节点<li>，可以使用以下 XPath 表达式：</p>
<p>//p[@class='author']/parent::li</p>
<p>在这个表达式中，//p[@class='author']用于定位class为author的<p>元素，parent::li表示选择该<p>元素的父节点<li> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-13"><a class="header" href="#假设html为读取的示例html文档内容-13">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-13"><a class="header" href="#欢迎来到xpath学习页面-13">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<p class="author">元素的父节点<li>
lis = root.xpath('//p[@class="author"]/parent::li')
for li in lis:
    print(etree.tostring(li, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//p[@class="author"]/parent::li')选择<p class="author">元素的父节点<li>，并将其打印输出 。</p>
<p>兄弟节点轴
使用following-sibling::轴选择当前节点之后的兄弟节点，使用preceding-sibling::轴选择当前节点之前的兄弟节点 。例如，在示例 HTML 文档中，要选择<ul id="book-list">之后的兄弟节点<a href="about.html">，可以使用以下 XPath 表达式：</p>
<p>//ul[@id='book-list']/following-sibling::a</p>
<p>在这个表达式中，//ul[@id='book-list']用于定位id为book-list的<ul>元素，following-sibling::a表示选择该<ul>元素之后的兄弟节点<a> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-14"><a class="header" href="#假设html为读取的示例html文档内容-14">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-14"><a class="header" href="#欢迎来到xpath学习页面-14">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<ul id="book-list">之后的兄弟节点<a href="about.html">
as_after_ul = root.xpath('//ul[@id="book-list"]/following-sibling::a')
for a in as_after_ul:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//ul[@id="book-list"]/following-sibling::a')选择<ul id="book-list">之后的兄弟节点<a href="about.html">，并将其打印输出 。</p>
<p>若要选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>，可以使用以下 XPath 表达式：</p>
<p>//li[@class='book-item']/p[1]/preceding-sibling::a</p>
<p>在这个表达式中，//li[@class='book-item']/p[1]用于定位class为book-item的<li>元素中的第一个<p>元素，preceding-sibling::a表示选择该<p>元素之前的兄弟节点<a> 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-15"><a class="header" href="#假设html为读取的示例html文档内容-15">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-15"><a class="header" href="#欢迎来到xpath学习页面-15">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>
as_before_p = root.xpath('//li[@class="book-item"]/p[1]/preceding-sibling::a')
for a in as_before_p:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//li[@class="book-item"]/p[1]/preceding-sibling::a')选择<li class="book-item">中第一个<p>元素之前的兄弟节点<a>，并将其打印输出 。</p>
<p>祖先节点轴
使用ancestor::轴选择当前节点的祖先节点，它包括当前节点的父节点以及父节点的父节点等 。例如，在示例 HTML 文档中，要选择<a href="book1.html">元素的所有祖先节点<div>，可以使用以下 XPath 表达式：</p>
<p>//a[@href='book1.html']/ancestor::div</p>
<p>在这个表达式中，//a[@href='book1.html']用于定位href为book1.html的<a>元素，ancestor::div表示选择该<a>元素的所有祖先节点<div> 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-16"><a class="header" href="#假设html为读取的示例html文档内容-16">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-16"><a class="header" href="#欢迎来到xpath学习页面-16">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<a href="book1.html">元素的所有祖先节点<div>
divs = root.xpath('//a[@href="book1.html"]/ancestor::div')
for div in divs:
    print(etree.tostring(div, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[@href="book1.html"]/ancestor::div')选择<a href="book1.html">元素的所有祖先节点<div>，并将其打印输出 。</p>
<p>后代节点轴
使用descendant::轴选择当前节点的后代节点，它包括当前节点的子节点以及子节点的子节点等 。例如，在示例 HTML 文档中，要选择<div id="content">的所有后代节点<p>，可以使用以下 XPath 表达式：</p>
<p>//div[@id='content']/descendant::p</p>
<p>在这个表达式中，//div[@id='content']用于定位id为content的<div>元素，descendant::p表示选择该<div>元素的所有后代节点<p> 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-17"><a class="header" href="#假设html为读取的示例html文档内容-17">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-17"><a class="header" href="#欢迎来到xpath学习页面-17">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择<div id="content">的所有后代节点<p>
ps = root.xpath('//div[@id="content"]/descendant::p')
for p in ps:
    print(etree.tostring(p, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@id="content"]/descendant::p')选择<div id="content">的所有后代节点<p>，并将其打印输出 。</p>
<p>XPath 函数
字符串函数
XPath 提供了一系列字符串函数，用于处理和操作字符串。例如，contains()函数用于判断一个字符串是否包含另一个子字符串 ，starts-with()函数用于判断一个字符串是否以另一个子字符串开头 。在我们的示例 HTML 文档中，若要选择href属性值以 “book” 开头的<a>元素，可以使用以下 XPath 表达式：</p>
<p>//a[starts-with(@href, 'book')]</p>
<p>在这个表达式中，//a表示选择所有的<a>元素，starts-with(@href, 'book')表示筛选出href属性值以 “book” 开头的元素 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的示例html文档内容-18"><a class="header" href="#假设html为读取的示例html文档内容-18">假设html为读取的示例HTML文档内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPath示例页面</title>
</head>
<body>
    <div id="content">
        <h1 id="欢迎来到xpath学习页面-18"><a class="header" href="#欢迎来到xpath学习页面-18">欢迎来到XPath学习页面</a></h1>
        <p class="intro">这是一个用于学习XPath的示例页面。</p>
        <ul id="book-list">
            <li class="book-item">
                <a href="book1.html">《Python编程从入门到实践》</a>
                <p class="author">Eric Matthes</p>
                <p class="price">79.00元</p>
            </li>
            <li class="book-item">
                <a href="book2.html">《Effective Java》</a>
                <p class="author">Joshua Bloch</p>
                <p class="price">99.00元</p>
            </li>
        </ul>
        <a href="about.html">关于我们</a>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择href属性值以“book”开头的<a>元素
as_start_with_book = root.xpath('//a[starts-with(@href, "book")]')
for a in as_start_with_book:
    print(etree.tostring(a, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//a[starts-with(@href, "book")]')选择href属性值以 “book” 开头的<a>元素，并将其打印输出 。</p>
<p>数值函数
数值函数在 XPath 中用于处理数值类型的数据，比如sum()函数可以计算节点集合中数值的总和 ，floor()函数返回小于或等于给定数值的最大整数 。假设在一个电商订单的 XML 文档中，每个<item>元素都有一个<price>子元素表示商品价格，我们要计算所有商品的总价格，可以使用以下 XPath 表达式：</p>
<p>sum(//item/price)</p>
<p>在 Python 中，使用lxml库结合 XPath 来计算这个总价格的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设xml为读取的电商订单xml文档内容"><a class="header" href="#假设xml为读取的电商订单xml文档内容">假设xml为读取的电商订单XML文档内容</a></h1>
<p>xml = """
<order>
<item>
<price>29.9</price>
</item>
<item>
<price>49.5</price>
</item>
<item>
<price>19.8</price>
</item>
</order>
"""</p>
<h1 id="将xml字符串解析为element对象"><a class="header" href="#将xml字符串解析为element对象">将XML字符串解析为Element对象</a></h1>
<p>root = etree.XML(xml)</p>
<h1 id="使用xpath计算所有商品的总价格"><a class="header" href="#使用xpath计算所有商品的总价格">使用XPath计算所有商品的总价格</a></h1>
<p>total_price = root.xpath('sum(//item/price)')
print(f"所有商品的总价格为: {total_price}")</p>
<p>上述代码中，首先将 XML 字符串解析为Element对象，然后通过xpath('sum(//item/price)')计算所有<item>元素下<price>元素数值的总和，并将结果打印输出 。</p>
<p>组合函数
在实际应用中，常常需要组合使用多个函数来实现复杂的筛选逻辑 。例如，在一个新闻网站的 HTML 页面中，每个新闻<div>元素包含一个<h2>标题元素和一个<p>摘要元素，摘要元素的class属性值可能不同。如果我们要选择标题中包含 “人工智能” 且摘要长度大于 100 个字符的新闻<div>元素，可以使用以下 XPath 表达式：</p>
<p>//div[contains(.//h2/text(), '人工智能') and string-length(.//p/text()) &gt; 100]</p>
<p>在这个表达式中，//div表示选择所有的<div>元素，contains(.//h2/text(), '人工智能')用于筛选出<h2>标题元素文本中包含 “人工智能” 的<div>元素，string-length(.//p/text()) &gt; 100用于筛选出<p>摘要元素文本长度大于 100 个字符的<div>元素 ，通过and连接两个条件，实现了复杂的筛选逻辑 。在 Python 中，使用lxml库结合 XPath 来选择这些元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的新闻网站html页面内容"><a class="header" href="#假设html为读取的新闻网站html页面内容">假设html为读取的新闻网站HTML页面内容</a></h1>
<p>html = """</p>
<html>
<body>
    <div>
        <h2 id="人工智能在医疗领域的新突破"><a class="header" href="#人工智能在医疗领域的新突破">人工智能在医疗领域的新突破</a></h2>
        <p>人工智能技术近年来在医疗领域取得了显著进展，它正逐渐改变着疾病诊断、治疗方案制定等多个方面。随着大数据和机器学习算法的不断发展，人工智能能够处理海量的医疗数据，为医生提供更准确的诊断建议……</p>
    </div>
    <div>
        <h2 id="体育赛事精彩回顾"><a class="header" href="#体育赛事精彩回顾">体育赛事精彩回顾</a></h2>
        <p>昨天的体育赛事精彩纷呈，各支队伍展开了激烈的角逐……</p>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择标题中包含“人工智能”且摘要长度大于100个字符的新闻<div>元素
divs = root.xpath('//div[contains(.//h2/text(), "人工智能") and string-length(.//p/text()) > 100]')
for div in divs:
    print(etree.tostring(div, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[contains(.//h2/text(), "人工智能") and string-length(.//p/text()) &gt; 100]')选择符合条件的<div>元素，并将其打印输出 。</p>
<p>实际应用场景
为了更直观地展示 XPath 在实际中的应用，我们以一个电商网站的 HTML 页面为例，展示如何使用 XPath 提取各种信息。假设我们有如下 HTML 代码：</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1" class="product-name"><a class="header" href="#商品1">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2" class="product-name"><a class="header" href="#商品2">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3" class="product-name"><a class="header" href="#商品3">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="#">首页</a></li>
            <li><a href="#">商品分类</a></li>
            <li><a href="#">购物车</a></li>
            <li><a href="#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
<p>提取所有商品名称
使用 XPath 表达式提取所有商品名称：</p>
<p>//div[@class='product']/h3[@class='product-name']/text()</p>
<p>这个表达式首先通过//div[@class='product']定位到所有的商品<div>元素，然后在这些元素内部，通过h3[@class='product-name']定位到商品名称的<h3>元素，最后使用text()获取其文本内容 。在 Python 中，使用lxml库结合 XPath 来提取这些商品名称的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容"><a class="header" href="#假设html为读取的电商网站html页面内容">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-1" class="product-name"><a class="header" href="#商品1-1">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-1" class="product-name"><a class="header" href="#商品2-1">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-1" class="product-name"><a class="header" href="#商品3-1">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="#">首页</a></li>
            <li><a href="#">商品分类</a></li>
            <li><a href="#">购物车</a></li>
            <li><a href="#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取所有商品名称
product_names = root.xpath('//div[@class="product"]/h3[@class="product-name"]/text()')
for name in product_names:
    print(name)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"]/h3[@class="product-name"]/text()')提取所有商品名称，并将其打印输出 。</p>
<p>提取所有有货商品的价格
提取所有有货商品的价格：</p>
<p>//div[@class='product'][.//p[@class='stock' and text()='有货']]/p[@class='price']/text()</p>
<p>这个表达式中，//div[@class='product']先定位到所有商品<div>元素，然后通过[.//p[@class='stock' and text()='有货']]筛选出其中库存<p>元素文本为 “有货” 的商品<div>元素，最后通过p[@class='price']/text()获取这些有货商品的价格文本 。在 Python 中，使用lxml库结合 XPath 来提取这些有货商品价格的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-1"><a class="header" href="#假设html为读取的电商网站html页面内容-1">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-2" class="product-name"><a class="header" href="#商品1-2">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-2" class="product-name"><a class="header" href="#商品2-2">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-2" class="product-name"><a class="header" href="#商品3-2">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="#">首页</a></li>
            <li><a href="#">商品分类</a></li>
            <li><a href="#">购物车</a></li>
            <li><a href="#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取所有有货商品的价格
prices = root.xpath('//div[@class="product"][.//p[@class="stock" and text()="有货"]]/p[@class="price"]/text()')
for price in prices:
    print(price)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"][.//p[@class="stock" and text()="有货"]]/p[@class="price"]/text()')提取所有有货商品的价格，并将其打印输出 。</p>
<p>找出所有缺货商品
找出所有缺货商品：</p>
<p>//div[@class='product'][.//p[@class='stock' and text()='缺货']]</p>
<p>这个表达式通过//div[@class='product']定位到所有商品<div>元素，再通过[.//p[@class='stock' and text()='缺货']]筛选出其中库存<p>元素文本为 “缺货” 的商品<div>元素 。在 Python 中，使用lxml库结合 XPath 来找出这些缺货商品的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-2"><a class="header" href="#假设html为读取的电商网站html页面内容-2">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-3" class="product-name"><a class="header" href="#商品1-3">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-3" class="product-name"><a class="header" href="#商品2-3">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-3" class="product-name"><a class="header" href="#商品3-3">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="#">首页</a></li>
            <li><a href="#">商品分类</a></li>
            <li><a href="#">购物车</a></li>
            <li><a href="#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath找出所有缺货商品
out_of_stock_products = root.xpath('//div[@class="product"][.//p[@class="stock" and text()="缺货"]]')
for product in out_of_stock_products:
    print(etree.tostring(product, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@class="product"][.//p[@class="stock" and text()="缺货"]]')找出所有缺货商品，并将其打印输出 。</p>
<p>获取导航菜单项
获取导航菜单项：</p>
<p>//nav[@class='main-nav']//a/text()</p>
<p>这个表达式通过//nav[@class='main-nav']定位到导航栏的<nav>元素，然后通过//a/text()获取该<nav>元素下所有<a>元素的文本内容，即导航菜单项 。在 Python 中，使用lxml库结合 XPath 来获取这些导航菜单项的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站html页面内容-3"><a class="header" href="#假设html为读取的电商网站html页面内容-3">假设html为读取的电商网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>电商商品列表</title>
</head>
<body>
    <div class="product-list">
        <div class="product">
            <h3 id="商品1-4" class="product-name"><a class="header" href="#商品1-4">商品1</a></h3>
            <p class="price">59.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品2-4" class="product-name"><a class="header" href="#商品2-4">商品2</a></h3>
            <p class="price">79.99元</p>
            <p class="stock">有货</p>
        </div>
        <div class="product">
            <h3 id="商品3-4" class="product-name"><a class="header" href="#商品3-4">商品3</a></h3>
            <p class="price">49.99元</p>
            <p class="stock">缺货</p>
        </div>
    </div>
    <nav class="main-nav">
        <ul>
            <li><a href="#">首页</a></li>
            <li><a href="#">商品分类</a></li>
            <li><a href="#">购物车</a></li>
            <li><a href="#">个人中心</a></li>
        </ul>
    </nav>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath获取导航菜单项
nav_items = root.xpath('//nav[@class="main-nav"]//a/text()')
for item in nav_items:
    print(item)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//nav[@class="main-nav"]//a/text()')获取导航菜单项，并将其打印输出 。</p>
<p>XPath 调试技巧
在使用 XPath 的过程中，调试是非常重要的环节，它能帮助我们快速找出表达式中的问题，确保准确地提取到所需的数据。以下介绍几种实用的 XPath 调试技巧 。</p>
<p>分步构建复杂表达式
当面对复杂的 XPath 表达式时，建议逐步构建。例如，在提取电商网站中商品信息时，如果要选择价格大于 50 元且库存大于 10 的商品，可以先分别构建选择所有商品的表达式//div[@class='product']，然后在此基础上添加选择价格的条件//div[@class='product']/p[@class='price']，接着添加价格大于 50 元的条件//div[@class='product'][number(substring-after(p[@class='price']/text(), '元')) &gt; 50]，最后添加库存大于 10 的条件//div[@class='product'][number(substring-after(p[@class='price']/text(), '元')) &gt; 50 and number(.//p[@class='stock']/text()) &gt; 10]。这样分步构建，每一步都可以验证表达式的正确性，便于及时发现和解决问题 。</p>
<p>使用 Chrome 开发者工具的 Elements 面板
Chrome 开发者工具的 Elements 面板是调试 XPath 的有力工具。打开 Chrome 浏览器，按下 F12 键打开开发者工具，切换到 Elements 面板 。在页面中右键点击要调试的元素，选择 “Copy” -&gt; “Copy XPath”，即可获取该元素的 XPath 表达式。然后在 Elements 面板左上角的搜索框中输入 XPath 表达式，按回车键，被选中的元素会在页面中高亮显示，同时在 Elements 面板中也会定位到该元素 。如果表达式有误，不会有元素被选中，此时可以检查表达式的语法、路径是否正确，以及条件是否符合预期 。例如，在调试提取商品名称的 XPath 表达式//div[@class='product']/h3[@class='product-name']/text()时，若没有正确提取到商品名称，可以检查div和h3的class属性是否正确，路径分隔符是否有误等 。</p>
<p>使用 XPath Helper 插件
XPath Helper 是一款 Chrome 浏览器插件，能大大提高 XPath 调试的效率。安装 XPath Helper 插件后，在浏览网页时，按下 Ctrl + Shift + X（Mac 系统为 Command + Shift + X）组合键，即可打开 XPath Helper 面板 。将鼠标悬停在页面元素上，XPath Helper 会自动显示该元素的 XPath 路径 。在 XPath Helper 面板中，可以直接编辑 XPath 表达式，并实时查看匹配结果，匹配到的元素会在页面中高亮显示 。比如，在调试一个复杂的 XPath 表达式时，在 XPath Helper 面板中修改表达式的条件，如将//div[@class='product'][.//p[@class='stock' and text()='有货']]/p[@class='price']/text()中的 “有货” 改为 “缺货”，面板会立即显示修改后的匹配结果，方便我们快速验证不同条件下的表达式正确性 。</p>
<p>XPath 常见问题与解决方案
处理动态生成的内容
在实际网页抓取中，很多内容是通过 JavaScript 动态生成的，这给 XPath 直接提取带来了困难 。例如，在一些电商网站中，商品的评论数据是在页面加载后通过 AJAX 请求获取并动态添加到 DOM 中的。此时，单纯使用 XPath 无法直接获取这些动态生成的内容 。解决办法是结合 Selenium 等自动化测试工具，Selenium 可以模拟浏览器行为，等待页面动态内容加载完成后，再使用 XPath 进行数据提取 。以 Python 为例，使用 Selenium 和 XPath 提取动态生成的商品评论数据的代码示例如下：</p>
<p>from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC</p>
<h1 id="初始化浏览器驱动"><a class="header" href="#初始化浏览器驱动">初始化浏览器驱动</a></h1>
<p>driver = webdriver.Chrome()</p>
<h1 id="打开目标网页"><a class="header" href="#打开目标网页">打开目标网页</a></h1>
<p>driver.get('https://example.com/product/123')</p>
<h1 id="等待评论区域加载完成"><a class="header" href="#等待评论区域加载完成">等待评论区域加载完成</a></h1>
<p>wait = WebDriverWait(driver, 10)
wait.until(EC.presence_of_element_located((By.XPATH, '//div[@class="comments"]')))</p>
<h1 id="使用xpath提取评论内容"><a class="header" href="#使用xpath提取评论内容">使用XPath提取评论内容</a></h1>
<p>comments = driver.find_elements(By.XPATH, '//div[@class="comment-item"]/p[@class="comment-text"]')
for comment in comments:
print(comment.text)</p>
<h1 id="关闭浏览器"><a class="header" href="#关闭浏览器">关闭浏览器</a></h1>
<p>driver.quit()</p>
<p>在上述代码中，首先使用webdriver.Chrome()初始化 Chrome 浏览器驱动，然后打开目标商品页面 。通过WebDriverWait和EC.presence_of_element_located方法，等待评论区域的元素加载完成，确保动态内容已经添加到 DOM 中 。最后使用 XPath 表达式//div[@class="comment-item"]/p[@class="comment-text"]提取评论内容，并打印输出 。</p>
<p>处理 iframe 中的内容
当网页中包含 iframe 时，XPath 无法直接在主文档中定位 iframe 内的元素 。例如，在一个新闻网站中，文章内容可能嵌套在 iframe 中。要提取 iframe 中的内容，需要先切换到 iframe 中，然后再使用 XPath 。以 Python 和 Selenium 为例，切换到 iframe 并提取内容的代码示例如下：</p>
<p>from selenium import webdriver
from selenium.webdriver.common.by import By</p>
<h1 id="初始化浏览器驱动-1"><a class="header" href="#初始化浏览器驱动-1">初始化浏览器驱动</a></h1>
<p>driver = webdriver.Chrome()</p>
<h1 id="打开目标网页-1"><a class="header" href="#打开目标网页-1">打开目标网页</a></h1>
<p>driver.get('https://example.com/article')</p>
<h1 id="定位到iframe元素"><a class="header" href="#定位到iframe元素">定位到iframe元素</a></h1>
<p>iframe = driver.find_element(By.XPATH, '//iframe[@id="article-iframe"]')</p>
<h1 id="切换到iframe"><a class="header" href="#切换到iframe">切换到iframe</a></h1>
<p>driver.switch_to.frame(iframe)</p>
<h1 id="使用xpath提取iframe中的文章标题"><a class="header" href="#使用xpath提取iframe中的文章标题">使用XPath提取iframe中的文章标题</a></h1>
<p>title = driver.find_element(By.XPATH, '//h1[@class="article-title"]').text
print(title)</p>
<h1 id="切换回主文档"><a class="header" href="#切换回主文档">切换回主文档</a></h1>
<p>driver.switch_to.default_content()</p>
<h1 id="关闭浏览器-1"><a class="header" href="#关闭浏览器-1">关闭浏览器</a></h1>
<p>driver.quit()</p>
<p>在上述代码中，首先初始化浏览器驱动并打开目标网页 。然后通过 XPath 定位到 id 为article-iframe的 iframe 元素，使用driver.switch_to.frame(iframe)方法切换到该 iframe 中 。接着在 iframe 内使用 XPath 表达式//h1[@class="article-title"]提取文章标题并打印 。最后使用driver.switch_to.default_content()方法切换回主文档，关闭浏览器 。</p>
<p>XPath 性能优化
在处理大型 XML 或 HTML 文档时，优化 XPath 表达式的性能非常重要，以下是一些建议和方法：</p>
<p>使用绝对路径与相对路径：尽量使用相对路径，因为绝对路径从根节点开始遍历整个文档，相对路径则从当前节点开始，能减少不必要的节点遍历 。例如，./div[@class='product']比/html/body/div[@class='product']更高效 。
减少通配符使用：通配符*和@<em>会匹配所有元素或属性，增加了匹配的范围和时间。在明确知道标签名或属性名时，尽量使用具体的标签名和属性名 。例如，//a[@href]比//</em>[@href]更高效 。
避免复杂的条件表达式：复杂的条件表达式会增加计算量，降低性能。可以将复杂条件拆分成多个简单条件，分步筛选 。例如，//div[@class='product' and contains(.//p[@class='description']/text(), '关键词')]，如果可能，先筛选出class为product的<div>元素，再在这些元素中筛选包含关键词的元素 。
利用索引：如果 XML 文档中有索引机制，可以利用索引来加速 XPath 查询 。不过，并非所有 XML 解析器都支持索引，具体情况需根据使用的解析器来定 。
高级 XPath 技巧
使用索引动态选择元素
在实际的网页结构中，元素的位置可能会随着页面内容的更新或用户交互而发生变化，使用固定索引选择元素可能会导致提取失败。此时，我们可以结合其他条件来动态确定索引 。例如，在一个商品列表页面中，商品的排列顺序可能会根据用户的筛选条件而改变，但每个商品都有一个唯一的data-id属性。假设我们要选择data-id为123的商品的价格元素，该价格元素是商品<div>下的第三个<p>元素，我们可以使用以下 XPath 表达式：</p>
<p>//div[@data-id='123']/p[3]</p>
<p>这样，无论该商品在列表中的位置如何变化，只要其data-id不变，就能准确选择到对应的价格元素 。在 Python 中，使用lxml库结合 XPath 来选择这个元素的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的商品列表页面html内容"><a class="header" href="#假设html为读取的商品列表页面html内容">假设html为读取的商品列表页面HTML内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>商品列表</title>
</head>
<body>
    <div class="product" data-id="123">
        <h3 id="商品名称"><a class="header" href="#商品名称">商品名称</a></h3>
        <p>描述信息</p>
        <p>库存信息</p>
        <p class="price">99.99元</p>
    </div>
    <div class="product" data-id="456">
        <h3 id="另一个商品名称"><a class="header" href="#另一个商品名称">另一个商品名称</a></h3>
        <p>描述信息</p>
        <p>库存信息</p>
        <p class="price">129.99元</p>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择data-id为123的商品的价格元素
price = root.xpath('//div[@data-id="123"]/p[3]')
for p in price:
    print(etree.tostring(p, encoding='utf-8').decode('utf-8'))
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[@data-id="123"]/p[3]')选择data-id为123的商品的价格元素，并将其打印输出 。</p>
<p>使用多重条件
在复杂的网页结构中，单一条件往往无法准确筛选出我们需要的元素，这时就需要使用多重条件 。例如，在一个电商网站的商品评论页面，每个评论<div>元素可能包含评论者的姓名<span class="username">、评论内容<p class="comment-content">和评论时间<span class="comment-time">等信息 。如果我们要选择评论者为 “张三” 且评论时间在 “2024-01-01” 之后的评论内容，可以使用以下 XPath 表达式：</p>
<p>//div[.//span[@class='username' and text()='张三'] and.//span[@class='comment-time' and text() &gt; '2024-01-01']]/p[@class='comment-content']/text()
在这个表达式中，//div表示选择所有的<div>元素，.//span[@class='username' and text()='张三']用于筛选出评论者为 “张三” 的<div>元素，.//span[@class='comment-time' and text() &gt; '2024-01-01']用于筛选出评论时间在 “2024-01-01” 之后的<div>元素 ，通过and连接两个条件，确保同时满足这两个条件的<div>元素被选中，最后通过p[@class='comment-content']/text()获取这些<div>元素下的评论内容 。在 Python 中，使用lxml库结合 XPath 来选择这些评论内容的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的电商网站商品评论页面html内容"><a class="header" href="#假设html为读取的电商网站商品评论页面html内容">假设html为读取的电商网站商品评论页面HTML内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>商品评论</title>
</head>
<body>
    <div class="comment">
        <span class="username">李四</span>
        <p class="comment-content">这个商品很不错。</p>
        <span class="comment-time">2023-12-31</span>
    </div>
    <div class="comment">
        <span class="username">张三</span>
        <p class="comment-content">商品质量有待提高。</p>
        <span class="comment-time">2024-01-05</span>
    </div>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择评论者为“张三”且评论时间在“2024-01-01”之后的评论内容
comments = root.xpath('//div[.//span[@class="username" and text()="张三"] and.//span[@class="comment-time" and text() > "2024-01-01"]]/p[@class="comment-content"]/text()')
for comment in comments:
    print(comment)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//div[.//span[@class="username" and text()="张三"] and.//span[@class="comment-time" and text() &gt; "2024-01-01"]]/p[@class="comment-content"]/text()')选择符合条件的评论内容，并将其打印输出 。</p>
<p>使用 normalize-space () 处理空白
在从 HTML 文档中提取文本时，常常会遇到文本前后或中间包含空白字符的情况，这会影响数据的准确性和后续处理 。XPath 提供的normalize-space()函数可以去除文本中的前导和尾随空白字符，并将中间的多个连续空白字符替换为单个空格 。例如，在一个包含用户简介的 HTML 页面中，<p class="bio">元素的文本内容可能包含多余的空白字符：</p>
<p class="bio"> 张三， 资深软件工程师， 擅长Python和Java开发。 </p>
使用normalize-space()函数提取该文本时，可以得到整洁的内容 。XPath 表达式如下：
<p>normalize-space(//p[@class='bio']/text())
在 Python 中，使用lxml库结合 XPath 来提取并处理这个文本的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的包含用户简介的html页面内容"><a class="header" href="#假设html为读取的包含用户简介的html页面内容">假设html为读取的包含用户简介的HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户简介</title>
</head>
<body>
    <p class="bio">   张三，  资深软件工程师，  擅长Python和Java开发。   </p>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath提取并处理文本
bio = root.xpath('normalize-space(//p[@class="bio"]/text())')
print(bio)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('normalize-space(//p[@class="bio"]/text())')提取并处理文本，去除空白字符后，将结果打印输出 。</p>
<p>组合使用轴和函数
轴和函数的组合使用能实现非常复杂的节点定位 。例如，在一个博客网站的 HTML 页面中，每个博客文章<article>元素包含标题<h2>、正文<div class="content">和评论区域<div class="comments">，评论区域内每个评论<div class="comment-item">包含评论者<span class="commenter">和评论内容<p class="comment-text"> 。如果我们要选择所有评论者为 “李四” 的评论内容，并且这些评论所在的文章标题包含 “XPath”，可以使用以下 XPath 表达式：</p>
<p>//article[contains(h2/text(), 'XPath')]//div[@class='comment-item'][.//span[@class='commenter' and text()='李四']]/p[@class='comment-text']/text()
在这个表达式中，//article[contains(h2/text(), 'XPath')]用于选择标题包含 “XPath” 的文章<article>元素，//div[@class='comment-item'][.//span[@class='commenter' and text()='李四']]用于在这些文章中选择评论者为 “李四” 的评论<div>元素，最后通过p[@class='comment-text']/text()获取这些评论的内容 。这里既使用了contains()函数筛选文章标题，又使用了轴来定位评论元素，实现了复杂的节点定位 。在 Python 中，使用lxml库结合 XPath 来选择这些评论内容的代码示例如下：</p>
<p>from lxml import etree</p>
<h1 id="假设html为读取的博客网站html页面内容"><a class="header" href="#假设html为读取的博客网站html页面内容">假设html为读取的博客网站HTML页面内容</a></h1>
<p>html = """</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客页面</title>
</head>
<body>
    <article>
        <h2 id="xpath-高级技巧解析"><a class="header" href="#xpath-高级技巧解析">XPath 高级技巧解析</a></h2>
        <div class="content">文章正文内容……</div>
        <div class="comments">
            <div class="comment-item">
                <span class="commenter">张三</span>
                <p class="comment-text">很有帮助的文章。</p>
            </div>
            <div class="comment-item">
                <span class="commenter">李四</span>
                <p class="comment-text">希望能有更多实例。</p>
            </div>
        </div>
    </article>
    <article>
        <h2 id="其他技术文章"><a class="header" href="#其他技术文章">其他技术文章</a></h2>
        <div class="content">……</div>
        <div class="comments">
            <div class="comment-item">
                <span class="commenter">王五</span>
                <p class="comment-text">……</p>
            </div>
        </div>
    </article>
</body>
</html>
"""
# 将HTML字符串解析为Element对象
root = etree.HTML(html)
# 使用XPath选择符合条件的评论内容
comments = root.xpath('//article[contains(h2/text(), "XPath")]//div[@class="comment-item"][.//span[@class="commenter" and text()="李四"]]/p[@class="comment-text"]/text()')
for comment in comments:
    print(comment)
<p>上述代码中，首先将 HTML 字符串解析为Element对象，然后通过xpath('//article[contains(h2/text(), "XPath")]//div[@class="comment-item"][.//span[@class="commenter" and text()="李四"]]/p[@class="comment-text"]/text()')选择符合条件的评论内容，并将其打印输出 。</p>
<p>总结
回顾 XPath 语法要点
在本文中，我们全面深入地学习了 XPath 语法。从基本的路径表达式，如/表示从根节点选取，//用于在文档中任意位置选取节点，到各种选择器，包括通过标签名选择特定元素、使用通配符选择未知元素等，它们是 XPath 定位节点的基础 。属性选择器可以根据元素的属性及属性值来筛选元素，条件表达式则能结合逻辑运算符进行复杂条件的筛选 。位置选择器让我们能够精准地定位到特定位置的元素，文本内容选择器帮助我们根据元素的文本内容进行选择 。XPath 轴定义了节点之间的关系，如子节点轴、父节点轴、兄弟节点轴等，通过这些轴，我们可以在文档的节点树中灵活地导航 。此外，XPath 还提供了丰富的函数，包括字符串函数、数值函数等，这些函数与轴和其他语法的组合使用，使得我们能够实现非常复杂的节点定位和数据提取 。</p>
<p>强调实践的重要性
XPath 语法的学习不仅在于理论知识的掌握，更重要的是通过大量的实践来巩固和提升。建议读者在实际项目中，如网页爬虫开发、XML 数据处理等，积极运用 XPath。可以从简单的网页数据提取开始，逐步尝试处理复杂的网页结构和动态生成的内容 。在实践过程中，不断总结经验，遇到问题时，善于利用调试技巧和工具，如 Chrome 开发者工具、XPath Helper 插件等，快速定位和解决问题 。通过持续的实践，相信大家能够熟练掌握 XPath 语法，将其灵活运用到各种实际场景中，提高数据处理和开发的效率 。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../golang/爬虫/_index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../java-sb/_index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../golang/爬虫/_index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../java-sb/_index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>



    </div>
    </body>
</html>
